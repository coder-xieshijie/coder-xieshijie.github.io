<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>jdk 21 virtual thread doc reading</title>
    <link href="/2023/09/19/%E9%9A%8F%E7%AC%94/doc%20reading/jdk-21-virtual-thread-doc-reading/"/>
    <url>/2023/09/19/%E9%9A%8F%E7%AC%94/doc%20reading/jdk-21-virtual-thread-doc-reading/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://openjdk.org/jeps/444">jdk21 virtual thread</a></p><h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><ol><li>java的最初的线程模式是<code>thread-per-request style</code>，即每一个请求都使用一个线程去执行，这样的好处是资源独立，debugger，profile等方便获取。但是由于此时java的thread和操作系统的thread的基本上是一一对应的，而受限于操作系统的硬件限制，无法同时创造过多的thread，而创造和销毁thread的开销又十分巨大，所以此时的thread的并发性能并不理想</li><li>基于此，引入了thread pool和asynchronous<ol><li>thread pool 因此thread的创造和销毁开销巨大，那么就让thread的lifestyle拉长，多个task可以顺序地共用同一个线程。但是这个还是没办法避免掉线程并发数量上限低的问题</li><li>asynchronous，这个更多的是一种思想。<ol><li>对于一个request，其中最耗时的部分可以分为：cpu计算和io</li><li>cpu计算是受限于计算机的硬件，通过并发是没有办法显著提升性能</li><li>io(网络io)不受限于计算机，而是依赖一些外部资源，这个提升并发可以提升处理速度</li><li>asynchronized的思路就是需要开发者对request进行逻辑拆分，把计算和io部分拆分开，对io部分逻辑手动分配更多的并发线程资源，从而让整体的处理资源分配更加合理，通常会使用CompletableFuture这种异步编排的方式来加快request的处理速度</li><li>这种方式固然可以加速请求的处理效率，但是额外引入的更多的复杂度，而且request的多个部分由不同的线程来处理，对于排障和问题定位无疑是巨大挑战</li></ol></li></ol></li><li>virtual thread<ol><li>就像操作系统引入虚拟内存来使程序可以使用更大的内存，jdk21引入virtual thread来避免操作系统本身对thread的限制</li><li>virtual thread的创造和开销极小</li><li>virtual thread可以兼容绝大部分已有的线程使用方式，(可能只需要极小的改变)</li><li>virtual thread又回归到<code>thread-per-request style</code>模式，减少复杂度。</li><li>virtual thread的内部原理有点像asynchronous，对于io部分进行阻塞等待，所以如果是io密集型的request，使用virtual thread会获取极大的并发提升，因为此时可以并发执行，但是对于cpu密集型的request，virtual thread的并发效果并没有预期那么大，因为本质都是需要计算机cpu资源，这个并不会因为并发的提升而提升</li><li>Observing virtual threads<ol><li>thread dump不在适用，因为百万级别的thread list对用户是不可读的，jdk21听过jcmd命令提供一种更具可读性的thread dump</li></ol></li><li>Scheduling virtual threads<ol><li>不同于系统thread的调度方式，jdk21由一个carrier去调度virtual thread ：The JDK’s virtual thread scheduler is a work-stealing <a href="https://download.java.net/java/early_access/jdk21/docs/api/java.base/java/util/concurrent/ForkJoinPool.html"><code>ForkJoinPool</code></a> that operates in FIFO mode. The <em>parallelism</em> of the scheduler is the number of platform threads available for the purpose of scheduling virtual threads.The platform thread to which the scheduler assigns a virtual thread is called the virtual thread’s <em>carrier</em>.</li><li>在java代码视角上看，carrier 和 virtual thread 彼此独立；在native代码视角上看，二者均运行在同一个os thread上。In addition, from the perspective of Java code, the fact that a virtual thread and its carrier temporarily share an OS thread is invisible. From the perspective of native code, by contrast, both the virtual thread and its carrier run on the same native thread.</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
      <category>doc-reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jdk21</tag>
      
      <tag>doc-reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2 + oh my zsh 打造舒适终端体验</title>
    <link href="/2023/09/10/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/iterm2-oh-my-zsh-%E6%89%93%E9%80%A0%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/"/>
    <url>/2023/09/10/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/iterm2-oh-my-zsh-%E6%89%93%E9%80%A0%E8%88%92%E9%80%82%E7%BB%88%E7%AB%AF%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="iTerm2-Oh-My-Zsh-打造舒适终端体验"><a href="#iTerm2-Oh-My-Zsh-打造舒适终端体验" class="headerlink" title="iTerm2 + Oh My Zsh 打造舒适终端体验"></a>iTerm2 + Oh My Zsh 打造舒适终端体验</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>最终效果图：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-b95d0d4fb26dd9494f524c7bc9ebe7ed.webp"></p><p>本文严重抄袭自：<a href="https://link.zhihu.com/?target=https://www.jianshu.com/p/7de00c73a2bb">https://www.jianshu.com/p/7de00c73a2bb</a></p><p>因排版和原文中的一些bug，参照搜索引擎和原文有了本篇文章。</p><p>因为powerline以及homebrew均需要安装command line tool，网络条件优越的同学在执行本文下面内容之前，可以先安装XCode并打开运行一次（会初始化安装components），省去以后在iterm2中的等待时间。</p><p>另外，git也是必要的，各位可以自行下载安装，除了网络没有任何坑：</p><p><a href="https://link.zhihu.com/?target=https://git-scm.com">https://git-scm.com</a></p><p>介于此，本文默认各位同学已经安装了git环境和xcode（command line tools），遇到提示找不到git命令或需要安装command line tool的地方，文中不再赘述了。</p><h2 id="下载iTerm2"><a href="#下载iTerm2" class="headerlink" title="下载iTerm2"></a>下载iTerm2</h2><p>可以直接去官网下载：<a href="https://link.zhihu.com/?target=https://www.iterm2.com/">https://www.iterm2.com/</a></p><p>安装完成后，在&#x2F;bin目录下会多出一个zsh的文件。</p><p>Mac系统默认使用dash作为终端，可以使用命令修改默认使用zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>如果想修改回默认dash，同样使用chsh命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/bash<br></code></pre></td></tr></table></figure><p>OK，这就是iTerm2初始的样子，下面我们来美化它，让它变得更好用！</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-ff7136f04ddb586623274c66e0f940f8.webp"></p><p>安装Oh my zsh</p><p>安装方法有两种，可以使用curl或wget，看自己环境或喜好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># curl 安装方式</span><br>sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># wget 安装方式</span><br>sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>安装命令和安装完成后的截图：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-0da4ecd93252aa75f05fbd790197a1f7.webp"></p><p>oh-my-zsh开源地址：<a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a></p><h2 id="安装PowerLine"><a href="#安装PowerLine" class="headerlink" title="安装PowerLine"></a>安装PowerLine</h2><p>powerline官网：<a href="https://link.zhihu.com/?target=http://powerline.readthedocs.io/en/latest/installation.html">http://powerline.readthedocs.io/en/latest/installation.html</a></p><p>安装powerline的方式依然简单，也只需要一条命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install powerline-status --user<br></code></pre></td></tr></table></figure><p>没有安装pip的同学可能会碰到zsh: command not found: pip。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-33b6818fd0c72bcb4360de5b82d1883d.webp"></p><p>使用命令安装pip即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo easy_install pip<br></code></pre></td></tr></table></figure><p>安装后再次执行安装powerline的命令即可。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-0cb914c715cc0178757d8efff2a03b3c.webp"></p><h2 id="安装PowerFonts"><a href="#安装PowerFonts" class="headerlink" title="安装PowerFonts"></a>安装PowerFonts</h2><p>安装字体库需要首先将项目git clone至本地，然后执行源码中的install.sh。</p><p>在你习惯的位置新建一个文件夹，如：~&#x2F;Desktop&#x2F;OpenSource&#x2F;</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-4aa5a099ef7cda0b840263d93425ead0.webp"></p><p>在此文件夹下执行git clone命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># git clone</span><br>git <span class="hljs-built_in">clone</span> https://github.com/powerline/fonts.git --depth=1<br><span class="hljs-comment"># cd to folder</span><br><span class="hljs-built_in">cd</span> fonts<br><span class="hljs-comment"># run install shell</span><br>./install.sh<br></code></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-4db24d0c546f9343c2a90812dadbc9b0.webp"></p><p>安装好字体库之后，我们来设置iTerm2的字体，具体的操作是iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。有L、M、S可选，看个人喜好：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-6d78634a5bced9298f83b55901d5361d.webp"></p><h2 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装配色方案</h2><p>配色方案在使用VIM或Colorful Log时会变得非常有用，同时界面也不会一片黑绿一样死板。</p><p>同样使用git clone的方式下载源码进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/OpenSource<br>git <span class="hljs-built_in">clone</span> https://github.com/altercation/solarized<br><span class="hljs-built_in">cd</span> solarized/iterm2-colors-solarized/<br>open .<br></code></pre></td></tr></table></figure><p>在打开的finder窗口中，双击Solarized Dark.itermcolors和Solarized Light.itermcolors即可安装明暗两种配色：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-4afe7c08e8e431786712e5dd34d6497c.webp"></p><p>再次进入iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets中根据个人喜好选择这两种配色中的一种即可：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-d112977face4ddf345574f86cdc4b176.webp"></p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>下载agnoster主题，执行脚本安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/Desktop/OpenSource<br>git <span class="hljs-built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git<br><span class="hljs-built_in">cd</span> oh-my-zsh-agnoster-fcamblor/<br>./install<br></code></pre></td></tr></table></figure><p>执行上面的命令会将主题拷贝到oh my zsh的themes中：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-e8ec4dcd244b303fb939a3338ea3ee05.webp"></p><p>拷贝完成后，执行命令打开zshrc配置文件，将ZSH_THEME后面的字段改为agnoster。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi ~/.zshrc<br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-515a9a7cb04d15a59babef48275a7b46.webp"></p><p>修改完成后按一下esc调出vi命令，输入:wq保存并退出vi模式。</p><p>此时command+Q或source配置文件后，iTerm2变了模样：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-d5e20a5af20401667173d0a0ab551729.webp"></p><h2 id="安装高亮插件"><a href="#安装高亮插件" class="headerlink" title="安装高亮插件"></a>安装高亮插件</h2><p>这是oh my zsh的一个插件，安装方式与theme大同小异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/custom/plugins/<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git<br>vi ~/.zshrc<br></code></pre></td></tr></table></figure><p>这时我们再次打开zshrc文件进行编辑。找到plugins，此时plugins中应该已经有了git，我们需要把高亮插件也加上：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-8392e4caaa9d616b5708418e04bf5ad7.webp"></p><p>请务必保证插件顺序，zsh-syntax-highlighting必须在最后一个。</p><p>然后在文件的最后一行添加：source ~&#x2F;.oh-my-zsh&#x2F;custom&#x2F;plugins&#x2F;zsh-syntax-highlighting&#x2F;zsh-syntax-highlighting.zsh</p><p>按一下esc调出vi命令，输入:wq保存并退出vi模式。</p><p>执行命令使刚才的修改生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zshrc<br></code></pre></td></tr></table></figure><p>至此大功告成，请看最终效果图：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-b95d0d4fb26dd9494f524c7bc9ebe7ed.webp"></p><p>背景图片取自微软Surface Studio的4K壁纸(将近12MB大小)，非常漂亮，需要的可以自取：</p><p><a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA">https://pan.baidu.com/s/1LKd4ghGyyNI6UwHhOHvfaA</a> 提取码: snrd</p><p>更换背景图片方式：iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Window -&gt; BackGround Image勾选图片即可。</p><h2 id="可选择、命令补全"><a href="#可选择、命令补全" class="headerlink" title="可选择、命令补全"></a>可选择、命令补全</h2><p>跟代码高亮的安装方式一样，这也是一个zsh的插件，叫做zsh-autosuggestion，用于命令建议和补全。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/custom/plugins/<br>git <span class="hljs-built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions<br>vi ~/.zshrc<br></code></pre></td></tr></table></figure><p>找到plugins，加上这个插件即可：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-e4712214f05220545c9393d8d846b2d6.webp"></p><p>插件效果：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694336683-8627056a866fea557cd416f148f1ccb7.webp"></p><p>有同学说补全命令的字体不太清晰，与背景颜色太过相近，其实可以自己调整一下字体颜色。</p><p>Preferences -&gt; Profiles -&gt; Colors 中有Foreground是标准字体颜色，ANSI Colors中Bright的第一个是补全的字体颜色。</p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他技能</tag>
      
      <tag>zsh</tag>
      
      <tag>iterm2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打造高效Mac工作环境</title>
    <link href="/2023/09/09/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88Mac%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/09/09/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88Mac%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h1 id="打造高效Mac工作环境"><a href="#打造高效Mac工作环境" class="headerlink" title="打造高效Mac工作环境"></a>打造高效Mac工作环境</h1><p>文章摘要：作为一名开发同学我们每天都会携领我们的电脑和各式的代码和各样的问题打交道，手中Mac越是顺手和好用，我们的效率也会越高。最近入职领了新电脑，刚好借此把”折腾”电脑的过程记录下来留个备份，与大家一起探讨分享一些比较好用的工具和软件……</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名开发同学我们每天都会携领我们的电脑和各式的代码和各样的问题打交道，手中Mac越是顺手和好用，我们的效率也会越高。最近入职领了新电脑，刚好借此把”折腾”电脑的过程记录下来留个备份，与大家一起探讨分享一些比较好用的工具和软件，如果有不足或更好的推荐也欢迎大家在评论区补充~</p><h1 id="一、开发环境"><a href="#一、开发环境" class="headerlink" title="一、开发环境"></a>一、开发环境</h1><p>这个就不用多说啦，写代码的基础，内部有很多新人资料已经介绍的比较详细，在这里简单汇总过一下</p><h2 id="1、环境安装"><a href="#1、环境安装" class="headerlink" title="1、环境安装"></a>1、环境安装</h2><p>包括JDK、Maven等等，推荐参考内网的<a href="https://java-guide-docs.corp.kuaishou.com/">快手Java开发后端开发指南</a></p><h2 id="2、IDEA插件"><a href="#2、IDEA插件" class="headerlink" title="2、IDEA插件"></a>2、IDEA插件</h2><p>iead安装完成后，少不了需要各种插件来为软件添砖加瓦，个人重点推荐几个插件如下:</p><h3 id="Arthas-idea-plugin"><a href="#Arthas-idea-plugin" class="headerlink" title="Arthas-idea-plugin"></a>Arthas-idea-plugin</h3><p>Arthas作为后端开发的一个瑞士军刀，平时联调时查看调用链路、分析各环节耗时、排查线上的一些诡异问题时常常都少不了它的身影，该插件可解决我们自行去拼接命令的烦恼。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-6d19105726f7c2e74104ed9206cb2c48.jpg"></p><blockquote><p>扩展链接:<a href="https://arthas.aliyun.com/doc/">Arthas官方文档</a> 、<a href="https://kstack.corp.kuaishou.com/tech/web/article/info/1914">Karthas使用案例集锦</a></p></blockquote><h3 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h3><p>Java开发中经常会遇到依赖冲突问题，使用<code>mvn dependency:tree</code> 的相关命令生成的依赖树的方式不够高效和直观，可以将该插件作为包冲突时的首要分析解决工具<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-f4ebbd0c4ad6794063562d05afd4875b.gif"></p><blockquote><p>扩展链接:<a href="https://segmentfault.com/a/1190000017542396">Maven Helper使用方法</a>、<a href="https://blog.csdn.net/lisongjia123/article/details/77847816?spm=1001.2014.3001.5501">依赖冲突解决方式</a></p></blockquote><h3 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h3><p>这是一款增强idea对mybatis支持的插件，如果原先项目中已经有很多mapper xml文件，该插件最好用的一个功能便是可以直接从Java方法调用点跳到对应的mapper.xml文件的对应SQL位置，避免我们自己去检索。其次如果项目需要用到一些复杂SQL可以用该插件快速的生成mapper.xml文件，如果是新项目且没有特别复杂的SQL更加推荐使用<a href="https://mp.baomidou.com/">MyBatis-Plus框架</a>可以让项目实现Mybatis的去XML化。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-f641f82f8b7ca0427dcece07cb44e683.png"></p><blockquote><p>扩展链接: <a href="https://www.cnblogs.com/tdyang/p/12855971.html">Free Mybatis plugin介绍</a></p></blockquote><h3 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h3><p>这是一个智能的代码补齐软件，它基于AI学习的功能，增强了IDEA的自动补全功能，有点类似于Idea的<strong>Live Templates</strong>功能，但却更加强大，不仅有基础代码模板的生成还支持各种API的调用代码框架补全，能够跟据我们历史的编程习惯，对Idea的提示补全功能进行优先级排序。并且如果遇到一些不太熟悉的编码代码，如:不太清楚okHttp的SDK怎么使用，可以直接在idea中检索开源项目中okHttp是如何使用的，避免了我们在浏览器和idea间的来回切换，可以大大提高我们的编程效率。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-185588d13f019373e6ce40420ced0f7a.gif"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-cd85fae3425f5e4b422700d8af0206d1.png"></p><blockquote><p>扩展链接:<a href="https://www.codota.com/">codota官网</a>、<a href="https://blog.csdn.net/weixin_43314519/article/details/112604425">codota使用方式</a></p></blockquote><h3 id="Builder-Generator"><a href="#Builder-Generator" class="headerlink" title="Builder Generator"></a>Builder Generator</h3><p>对于一些大对象而言，初始化的可选参数往往很多，一个比较优雅的方式可以使用建造者模式来优化对象的创建方法。而我们自己去写对应的builder代码很麻烦，且重复繁琐，该插件可以通过简单的勾选一键生成对应的builder代码，十分的便利。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-1c5ef1ea7b28ca09aafdf7885c53e2ff.png"></p><blockquote><p>扩展链接:<a href="https://blog.csdn.net/qq_38366063/article/details/106076608">Builder Generator使用方式</a></p></blockquote><h3 id="IDEA美化相关"><a href="#IDEA美化相关" class="headerlink" title="IDEA美化相关"></a>IDEA美化相关</h3><p>在安装了工具类插件外，如果觉得已经看腻了长久已经没有做过更新Idea的UI界面，可以安装一些美化类插件来为自己的Idea换个皮肤，让其焕然一新，个人比较推荐下面的两个插件:</p><p><strong>Material Theme UI *_和 *_Atom Material Icons</strong> 一个是换界面UI的，一个是对默认图标进行替换，安装完成后的效果图如下:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-923bf949fd7e9d814e0159a598601ad5.jpg"></p><p>字体和背景色可以根据喜好自行在idea的设置中进行微调。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>对于一些其他好用插件推荐和使用技巧也可以参考下面几篇不错的文章，大家可以根据自己的个人偏好进行选择使用:</p><ul><li><a href="https://kstack.corp.kuaishou.com/tech/web/article/info/2983?userSource=engineer-group-bot">工欲善其事必先利其器，这16个idea技巧您值得拥有</a></li><li><a href="https://kstack.corp.kuaishou.com/tech/web/article/info/1174">推荐一款idea插件——pojo2proto</a></li><li><a href="https://blog.csdn.net/win7system/article/details/83508313">Idea值得推荐的十大插件</a></li></ul><h1 id="二、更强大的终端"><a href="#二、更强大的终端" class="headerlink" title="二、更强大的终端"></a>二、更强大的终端</h1><p>Mac相较于Windows作为开发电脑而言，一个很大的优点便是系统原生就有着良好的终端命令支持，如果习惯了使用终端很多事情是比可视化操作更加地方便快捷，下面是自己几款墙裂推荐的终端软件:</p><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><p>使用mac必备的一个软件管理工具，也是我们安装其他工具的一个前置步骤，对于新安装brew的小伙伴而言需要注意的一点是由于在安装brew的时候需要用到git的相关命令，所以我们需要前置安装 <strong>Git</strong>(<a href="https://git-scm.com/download/mac">Git软件下载地址</a>)，否则会报如下错误:</p><blockquote><p>&gt; &#x3D;&#x3D;&gt; Downloading and installing Homebrew…</p><p>remote: Enumerating objects: 13, done.</p><p>remote: Counting objects: 100% (13&#x2F;13), done.</p><p>remote: Compressing objects: 100% (10&#x2F;10), done.</p><p>error: RPC failed; curl 18 transfer closed with outstanding read data remaining</p><p>fatal: the remote end hung up unexpectedly</p><p>fatal: early EOF</p><p>fatal: index-pack failed</p><p>Failed during: git fetch origin master:refs&#x2F;remotes&#x2F;origin&#x2F;master –tags –force</p></blockquote><p>等Git安装安装完成后，便可以通过下面的命令安装 <strong>brew</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">ruby <span class="hljs-operator">-</span>e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;<br></code></pre></td></tr></table></figure><h2 id="on-my-zsh"><a href="#on-my-zsh" class="headerlink" title="on-my-zsh"></a>on-my-zsh</h2><p>当我们在终端敲下一个命令后，命令的执行离不开命令解析器，而mac和linux默认的命令解释器<strong>Bash</strong>比较基础，缺少很多自定义的扩展功能，我们第一步就需要先让基础的命令解释器更加的好用，目前比较流行的是<strong>ZSH</strong>。</p><p>ZSH有更多的自定义选项，并支持扩展，它可以实现更强大的命令补全，命令高亮等一系列酷炫功能，而更强大的功能和更多自由扩展往往需要的配置步骤也会更多，为了让大家更好快速的使用上更强大的ZSH，一个叫 robbyrussel 的用户在 GitHub 上制作了一个开源配置文件 oh-my-zsh的项目，这是目前最火的一套 Zsh 配置方案，可以让用户开箱即用的完成很多常用的ZSH功能配置。该过程的几个设置步骤如下:</p><h3 id="a、安装ZSH"><a href="#a、安装ZSH" class="headerlink" title="a、安装ZSH"></a>a、安装ZSH</h3><p>直接通过brew命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install zsh<br></code></pre></td></tr></table></figure><h3 id="b、安装on-my-zsh"><a href="#b、安装on-my-zsh" class="headerlink" title="b、安装on-my-zsh"></a>b、安装on-my-zsh</h3><p>通过curl来安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;<br></code></pre></td></tr></table></figure><h3 id="c、安装几个常用的ZSH插件"><a href="#c、安装几个常用的ZSH插件" class="headerlink" title="c、安装几个常用的ZSH插件"></a>c、安装几个常用的ZSH插件</h3><h4 id="智能目录跳转软件autojump"><a href="#智能目录跳转软件autojump" class="headerlink" title="智能目录跳转软件autojump"></a>智能目录跳转软件autojump</h4><p>使用brew来安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install autojump<br></code></pre></td></tr></table></figure><p>安装完成后在<code>~/.zshrc</code>文件的最后添加如下配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[[ -s $(brew --prefix)/etc/profile.<span class="hljs-property">d</span>/autojump.<span class="hljs-property">sh</span> ]] &amp;&amp; . $(brew --prefix)/etc/profile.<span class="hljs-property">d</span>/autojump.<span class="hljs-property">sh</span><br></code></pre></td></tr></table></figure><h4 id="命令补全工具-zsh-autosuggestions"><a href="#命令补全工具-zsh-autosuggestions" class="headerlink" title="命令补全工具 zsh-autosuggestions"></a>命令补全工具 zsh-autosuggestions</h4><p>执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><h4 id="终端命令高亮工具zsh-syntax-highlighting"><a href="#终端命令高亮工具zsh-syntax-highlighting" class="headerlink" title="终端命令高亮工具zsh-syntax-highlighting"></a>终端命令高亮工具zsh-syntax-highlighting</h4><p>执行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><h3 id="d、插件配置"><a href="#d、插件配置" class="headerlink" title="d、插件配置"></a>d、插件配置</h3><p>上面的步骤已经把比较常用的几个插件下载到了电脑上，我们修改下ZSH的配置文件启用这几个插件即可，打开<code>~/.zshrc</code>文件，然后找到plugins关键字，系统默认已经加载git文件，然后我们再追加下这三个插件即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">plugins=(git zsh-autosuggestions autojump zsh-syntax-highlighting)<br></code></pre></td></tr></table></figure><p>启用完成后重新打开终端，或者通过<code>source ~/.zshrc</code>命令重新引入终端的配置，就可以看到效果啦</p><h4 id="e、效果示例"><a href="#e、效果示例" class="headerlink" title="e、效果示例"></a>e、效果示例</h4><p>git命令直接使用缩写即可无需再打出完整的git命令，<a href="https://www.jianshu.com/p/a69efd5bc0b6">zsh中的git命令缩写</a>;<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-413b024b9aa13473d700af9070acea54.gif"></p><p>使用<code>j $&#123;目标目录名&#125;</code>便可以直接快速跳转到指定目录,如下图所示:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-abfa69e696a2d9c7051e4ed071216ec6.gif"></p><p>输入命令时有智能提示，且通过高亮效果能判断出命令是否输入正确等等。</p><h2 id="powerlevel9k"><a href="#powerlevel9k" class="headerlink" title="powerlevel9k"></a>powerlevel9k</h2><p>号称是Zsh下最漂亮的皮肤主题，项目地址<a href="https://github.com/Powerlevel9k/powerlevel9k">https://github.com/Powerlevel9k/powerlevel9k</a>，当然这个主题不仅仅是让终端看起来更加好看，更可以让命令行中透出更多的信息，例如:可以直接看到git的状态，是否需要拉代码、本地有几个变更还没有推送、git文件是否存在未解决的冲突等等，一个示例效果图如下:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-92205011cf0c7087808b1f95c6adbc68.jpg"></p><p>该主题的安装步骤只需按顺序执行下面三个命令即可:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew tap sambadevi/powerlevel9k<br><br>brew install powerlevel9k<br><br>echo &quot;source /usr/local/opt/powerlevel9k/powerlevel9k.zsh-theme&quot; &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure><p>不过需要注意的是系统的默认字体对于一些特殊符号的展示可能会存在问题，如下图:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-df79ef2f5b65506521f97423f1cea11d.jpg"></p><p>我们需要再安装下对应的主题字体便可以解决乱码问题，该步骤可以参考博客:<a href="https://www.jianshu.com/p/f84cf6132d1e">powerlevel字体配置</a></p><p>如果不喜欢主题默认的配色方案，可以访问开源项目<a href="https://github.com/mbadolato/iTerm2-Color-Schemes/tree/master/schemes">最舒服的终端配色方案</a>，找到自己比较喜欢的颜色风格，下载对应的颜色配置文件，然后在<strong>Iterm2</strong>中的设置(快捷键<code>CMD+i</code>)中导入即可。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-e89893db827fd05a66da7bbc7c1b454b.jpg"></p><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>在使用终端时常常会忘记某些命令的用法，例如，想使用find命令按照文件名来查找某个文件，但又忘记应该拼接什么参数。这时我们可以想到使用系统自带的<code>man</code>命令来查看该命令的用法，但使用过man命令的同学常常会有如下体会，我们就临时使用一个命令，但man命令的使用说明过于详细冗长，阅读到自己想要的功能几分钟已经过去了，并不适合作为一个命令的速查方式。上网找文章查看，又需要来回点击网页且需要在浏览器和终端间切换，效率不够高，这种场景下<strong>tldr</strong>工具便是一个极佳的选择，可以直接列出某个命令的高频用法，并给出对应的示例说明，效果图如下:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-8eeb9ebaad8b5632257f38553379370d.jpg"></p><p>有了<strong>tldr</strong>在绝大多数场景下便可以解决我们忘记命令的烦扰， 对于一些低频的命令也无需再去专门进行记忆，要用时在命令行速查即可。</p><p><strong>安装方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install tldr<br></code></pre></td></tr></table></figure><p><strong>项目地址</strong></p><blockquote><p><a href="https://github.com/tldr-pages/tldr">https://github.com/tldr-pages/tldr</a></p></blockquote><h2 id="thefuck"><a href="#thefuck" class="headerlink" title="thefuck"></a>thefuck</h2><p>上面<strong>tldr</strong>工具解决了我们记住了命令但对用法比较生疏的情况。而有时我们会遇到命令的拼写也记不太清，或者命令敲错的情况，例如，将python打成了ptyhon，执行apt-get install vim安装软件时忘记加上了sudo，这时便会想有没有什么工具无需让我们去查询命令的正确用法，或者无需再让我们重新敲一遍正确命令，而它直接替我们把错误的命令纠正过来。<strong>the fuck</strong>便是这样一个神器，在我们敲错命令时，直接对命令行说<code>fuck</code>，它便会基于自己的命令库检索功能来提我们修正错误的命令， 提升我们的工作效率，演示图如下:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-378e943f77a58f5c3807e93baf3e5241.gif"></p><p><strong>安装方式:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install thefuck<br></code></pre></td></tr></table></figure><p><strong>项目地址:</strong></p><blockquote><p><a href="https://github.com/nvbn/thefuck">https://github.com/nvbn/thefuck</a></p></blockquote><h2 id="Tmux"><a href="#Tmux" class="headerlink" title="Tmux"></a>Tmux</h2><p>终端复用的一款神器，要理解这款神器前先引用<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>大神的介绍，来让大家了解下Tmux的核心理念:</p><blockquote><h3 id="会话与进程"><a href="#会话与进程" class="headerlink" title="会话与进程"></a>会话与进程</h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p><p>会话的一个重要特点是，窗口与其中启动的进程是<a href="http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html">连在一起</a>的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p><p>一个典型的例子就是，<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">SSH 登录</a>远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p><p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><h3 id="Tumx的作用"><a href="#Tumx的作用" class="headerlink" title="Tumx的作用"></a>Tumx的作用</h3><p>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</p><p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p><p>（2） 它可以让新窗口”接入”已经存在的会话。</p><p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p><p>（4）它还支持窗口任意的垂直和水平拆分。</p></blockquote><p>原文链接:<a href="http://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux 使用教程</a></p><p>Tmux在我们需要SSH连接到远程服务器的场景中十分有用，一方面可以保持会话长久保活，避免长时间未操作而导致会话断开连接，类似于<strong>screen</strong>；另一方面我们去服务器排查问题和查日志时常常需要用到多个终端窗口来对照分析，如果需要我们一个去SSH连接打开的话特别费事，还需要在多个终端窗口间频繁切换，效率比较低，而有了<strong>Tmux</strong>这两个痛点便都可以解决</p><h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install tmux<br></code></pre></td></tr></table></figure><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>大家可以直接参考阮一峰老师上面的博客，介绍的已经比较详细了，其中自己遇到的一个问题时对窗口更名后，随便使用ls或cd命令后，发现window名称会随着目录的不同而变化，我们的自定义命名不起作用。网上搜了后发现这个是zsh下oh-my-zsh的特性导致的，需要我们将**~&#x2F;.zshrc**配置文件中的<code>DISABLE_AUTO_TITLE=&quot;true&quot;</code>这一行注释掉，然后执行<code>source ~/.zshrc</code>导入配置，再去用Tumx修改窗口的名称，便不会发生变化</p><h4 id="更加友好的个性化配置"><a href="#更加友好的个性化配置" class="headerlink" title="更加友好的个性化配置"></a>更加友好的个性化配置</h4><p>Tmux虽然功能十分强大，但不得不吐槽的是其默认的快捷键配置设计的并不是特别人性化，键位的组合以及窗口切换比较麻烦。为此，我们通过更改配置项让Tmux使用起来更加的高效，下面是一份常用的配置文件，直接将该配置复制到 <code>~/.tmux.conf</code>文件中即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs sql"># Send prefix<br><br># 把prefix的ctrl<span class="hljs-operator">+</span>b变为了ctrl<span class="hljs-operator">+</span>a，因为这样按起来方便些<br><br><span class="hljs-keyword">set</span><span class="hljs-operator">-</span>option <span class="hljs-operator">-</span>g prefix C<span class="hljs-operator">-</span>a<br><br>unbind<span class="hljs-operator">-</span>key C<span class="hljs-operator">-</span>a<br><br>bind<span class="hljs-operator">-</span>key C<span class="hljs-operator">-</span>a send<span class="hljs-operator">-</span>prefix<br><br># Use Alt<span class="hljs-operator">-</span>arrow keys <span class="hljs-keyword">to</span> switch panes<br><br># 不用按prefix，直接用alt<span class="hljs-operator">+</span>箭头在pane之间switch。实际用过之后才发现真是太方便了<span class="hljs-operator">!</span><br><br>bind <span class="hljs-operator">-</span>n M<span class="hljs-operator">-</span><span class="hljs-keyword">Left</span> <span class="hljs-keyword">select</span><span class="hljs-operator">-</span>pane <span class="hljs-operator">-</span>L<br><br>bind <span class="hljs-operator">-</span>n M<span class="hljs-operator">-</span><span class="hljs-keyword">Right</span> <span class="hljs-keyword">select</span><span class="hljs-operator">-</span>pane <span class="hljs-operator">-</span>R<br><br>bind <span class="hljs-operator">-</span>n M<span class="hljs-operator">-</span>Up <span class="hljs-keyword">select</span><span class="hljs-operator">-</span>pane <span class="hljs-operator">-</span>U<br><br>bind <span class="hljs-operator">-</span>n M<span class="hljs-operator">-</span>Down <span class="hljs-keyword">select</span><span class="hljs-operator">-</span>pane <span class="hljs-operator">-</span>D<br><br># 不用按prefix，直接用shift<span class="hljs-operator">+</span>箭头在<span class="hljs-keyword">window</span>之间switch。太方便了！<br><br># Shift arrow <span class="hljs-keyword">to</span> switch windows<br><br>bind <span class="hljs-operator">-</span>n S<span class="hljs-operator">-</span><span class="hljs-keyword">Left</span> previous<span class="hljs-operator">-</span><span class="hljs-keyword">window</span><br><br>bind <span class="hljs-operator">-</span>n S<span class="hljs-operator">-</span><span class="hljs-keyword">Right</span> next<span class="hljs-operator">-</span><span class="hljs-keyword">window</span><br><br># Mouse mode<br><br># 开启鼠标模式。用鼠标就能切换<span class="hljs-keyword">window</span>，pane，还能调整pane的大小<br><br><span class="hljs-keyword">set</span> <span class="hljs-operator">-</span>g mouse <span class="hljs-keyword">on</span><br><br># <span class="hljs-keyword">Set</span> easier <span class="hljs-keyword">window</span> split keys<br><br># prefix <span class="hljs-operator">+</span> v 代表竖着切，prefix <span class="hljs-operator">+</span> h 代表横着切,比默认的更加好用<br><br>bind<span class="hljs-operator">-</span>key v split<span class="hljs-operator">-</span><span class="hljs-keyword">window</span> <span class="hljs-operator">-</span>h<br><br>bind<span class="hljs-operator">-</span>key h split<span class="hljs-operator">-</span><span class="hljs-keyword">window</span> <span class="hljs-operator">-</span>v<br><br># 将<span class="hljs-keyword">window</span>的起始设置为<span class="hljs-number">1</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-operator">-</span>g base<span class="hljs-operator">-</span>index <span class="hljs-number">1</span><br><br># 将pane的起始下标设为<span class="hljs-number">1</span><br><br><span class="hljs-keyword">set</span> <span class="hljs-operator">-</span>g pane<span class="hljs-operator">-</span>base<span class="hljs-operator">-</span>index <span class="hljs-number">1</span><br><br># Easy config reload<br><br># 下一次如果修改了.tmux.conf的设置的话，不用关掉tmux。直接用prefix<span class="hljs-operator">+</span>r,<br><br>bind<span class="hljs-operator">-</span>key r source<span class="hljs-operator">-</span>file <span class="hljs-operator">~</span><span class="hljs-operator">/</span>.tmux.conf \; display<span class="hljs-operator">-</span>message &quot;tmux.conf reloaded&quot;<br></code></pre></td></tr></table></figure><blockquote><p>参考博客: <a href="https://www.jianshu.com/p/fd3bbdba9dc9">Tumx关键配置项</a></p></blockquote><h2 id="cloc"><a href="#cloc" class="headerlink" title="cloc"></a>cloc</h2><p>可以统计某个目录或者某个git版本下所用到的各种编程语言的代码行数，并可以识别出其中的空行和注释代码，十分的轻量简洁<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-b2b1fc0a2330161d7e55436aa0733f74.jpg"></p><p><strong>安装方式:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">brew install cloc<br></code></pre></td></tr></table></figure><p><strong>项目地址:</strong></p><blockquote><p><a href="https://github.com/AlDanial/cloc">https://github.com/AlDanial/cloc</a></p></blockquote><h1 id="三、系统软件"><a href="#三、系统软件" class="headerlink" title="三、系统软件"></a>三、系统软件</h1><h2 id="Clipy"><a href="#Clipy" class="headerlink" title="Clipy"></a>Clipy</h2><p>一款强大免费开源的系统剪切板增强软件，可以保存我们剪切板的历史记录，文本、图片等均可以保存下来，避免在一些复制粘贴的场景来回的去切换复制的上下文，并且也可以将我们一些常用的命令或者测试账号等文本片段保存在软件中，实现常用文本的随取随用。</p><p>演示效果:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-04741d836626a66b7eea04fe0332d2da.gif"></p><p>下载地址:</p><blockquote><p><a href="https://clipy.en.softonic.com/mac">https://clipy.en.softonic.com/mac</a></p></blockquote><h2 id="Magnet"><a href="#Magnet" class="headerlink" title="Magnet"></a>Magnet</h2><p>系统分屏软件，可以帮助我们快速整理桌面窗口应用，实现多窗口的协同工作</p><p>演示效果:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-a3930ec3ef04d3971390aaa69e1538bc.gif"></p><p>在AppStore中可以下载</p><h2 id="TotalSpace-2"><a href="#TotalSpace-2" class="headerlink" title="TotalSpace 2"></a>TotalSpace 2</h2><p>一款好用的桌面管理软件，自己使用mac的一个必装软件，有了Magnet解决了我们在一个桌面下多个窗口的协作问题，但工作中我们常常要在编程、记笔记、浏览器、终端等各个场景下切换，如果这些软件在一个桌面的多个窗口打开显得十分拥挤，且切换不够方便。那么可以根据我们的场景，在系统中划分出多个桌面，并将不同的软件划归到不同的桌面中，在每个桌面下只进行特定的工作场景，然后我们可以按使用场景通过快捷键或者鼠标动作来切换我们的工作桌面，这样就会让桌面和窗口间变得更加井井有条，不同场景所面对的窗口也更加的聚焦，真实效果可以参考下面的演示图:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-b900b423b9f1d770942e52f3cfc87783.gif"></p><p>下载地址:</p><blockquote><p><a href="https://totalspaces.binaryage.com/">https://totalspaces.binaryage.com/</a></p></blockquote><p>官网的售价比较贵，可以在淘宝上搜索该软件名，在荔枝软件等店铺购买激活码进行激活</p><h2 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h2><p>Mac下大名鼎鼎的经典效率神器，可以类比于Mac自带的聚焦搜索的”超级加倍”，Alfred中可以支持自定义的工作流，相当于插件机制，在默认搜索的功能的基础下可以下载网友开发的插件来进行功能扩展，实现诸如搜索Maven坐标、单词翻译、快捷搜索、文档API查询、URL编解码、搜索浏览器某个书签甚至可以进行变量起名，基本上有了Alfred工作中的大多数搜索都可以集成在这个万能搜索框中，效果图:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-fc9b424ce1885ec0728840438d873a42.jpg"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-9a1f9ff399cdf1243b5d37fefb23a37d.jpg"> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-7f1521e5a7ec19e06fe57afe7349b707.jpeg"></p><p>下载地址:</p><blockquote><p><a href="https://www.alfredapp.com/">https://www.alfredapp.com/</a></p></blockquote><p>WorkFlow插件仓库:</p><blockquote><p><a href="http://www.packal.org/workflow-search">http://www.packal.org/workflow-search</a></p></blockquote><p>常用WorkFlow推荐</p><blockquote><p><a href="https://www.jianshu.com/p/0e78168da7ab">https://www.jianshu.com/p/0e78168da7ab</a></p></blockquote><h2 id="TinyCal"><a href="#TinyCal" class="headerlink" title="TinyCal"></a>TinyCal</h2><p>日历时间软件，快速查看时间和日历，并可以增加对应的待办事项提醒，可以代替系统的日期&amp;时间以及日历软件，效果图如下:<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-8713eecad8d4f5b82d0de6ef0a14db69.jpg"></p><p>更加强大之处在于它也可以支持我们用dataPattern表达式自行定义想要展示的时间(<a href="https://wenchao.ren/posts/java%E4%B8%AD%E7%9A%84%E6%97%A5%E6%9C%9Fpattern/">日期Pattern大全</a>)</p><h2 id="LICECap"><a href="#LICECap" class="headerlink" title="LICECap"></a>LICECap</h2><p>一个开源免费的录制Gif工具，在IM沟通中描述某个现象和操作还是一个简单的录屏更加的直观快速，该软件不到1M大小，用起来很方便，该文章中的动图就是用该软件录屏的。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-f9bd830616aa4e8e1688acc5209c56bc.jpg"></p><p>下载地址:</p><blockquote><p><a href="https://www.cockos.com/licecap/">https://www.cockos.com/licecap/</a></p></blockquote><p>如果比较追求软件颜值和功能强大，也可以尝试<strong>Kap</strong></p><h1 id="四、浏览器插件"><a href="#四、浏览器插件" class="headerlink" title="四、浏览器插件"></a>四、浏览器插件</h1><h2 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a>FeHelper</h2><p>浏览器中常用的小工具集合，包括base64转换、二维码生成、JSON格式化、Crontab生成、颜色码提取等等<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-a84960ca8c9429111ed82386ca6eca41.jpg"></p><h2 id="Tampermonkey"><a href="#Tampermonkey" class="headerlink" title="Tampermonkey"></a>Tampermonkey</h2><p>必装神器，可以实现搜索引擎的结果多列展示、搜索结果自动翻页、去除知乎及CSDN等网址登录框提醒、屏蔽各种推广广告、解除网页的复制等限制等，网上插件库中有上千款网友开发的插件可以根据的自己的需要自行的下载安装。<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-f8d1ce89e5162e655d0d512286306ec0.jpg"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-ca1a3493c5346da3e4eba6c0a319b847.jpg"></p><p>插件库:</p><blockquote><p><a href="https://greasyfork.org/zh-CN/scripts">https://greasyfork.org/zh-CN/scripts</a></p></blockquote><h2 id="Stylish"><a href="#Stylish" class="headerlink" title="Stylish"></a>Stylish</h2><p>实现网页样式的自定义，可以下载一下网友的插件来实现让谷歌、百度等网页样式更加的清爽简洁<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-33debbafd6e50b7fbb4db73e1bb25b10.jpg"></p><p>样式库:</p><blockquote><p><a href="https://userstyles.org/styles/browse/google">https://userstyles.org/styles/browse/google</a></p></blockquote><h2 id="crxMouse"><a href="#crxMouse" class="headerlink" title="crxMouse"></a>crxMouse</h2><p>鼠标手势，快速实现前进、后退、关闭网页、撤销关闭、新建浏览器标签等操作<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-bf299075b1fa8a6d528b4b521952a9db.gif"></p><h2 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h2><p>用树状的项目结构来查看github中的代码<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1694265334-be8285c1d1202fdc56ce074a567ed2bc.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他技能</tag>
      
      <tag>MAC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch 概念介绍</title>
    <link href="/2023/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93/elasticsearch-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h2><ol><li>An index in Elasticsearch is similar to a table in a relational database.</li><li>A document is similar to a row in a table of a relational database.</li></ol><h2 id="Concept"><a href="#Concept" class="headerlink" title="Concept"></a>Concept</h2><p>Elasticsearch (often abbreviated as ES) is a search engine built on top of the open-source Lucene library. It is designed to handle large volumes of data, making it ideal for searching, filtering, and analyzing big data in real-time. Elasticsearch is commonly used in a variety of applications such as log and event data analysis, full-text search, and other real-time analytics use cases. It is developed in Java and is part of the Elastic Stack, which also includes Kibana, Beats, and Logstash (often abbreviated as the ELK Stack: Elasticsearch, Logstash, Kibana).</p><h3 id="Key-Features"><a href="#Key-Features" class="headerlink" title="Key Features:"></a>Key Features:</h3><ol><li><strong>Distributed Architecture</strong>: Elasticsearch is designed to be run on a cluster of machines. Data is automatically distributed across nodes and can be scaled horizontally.</li><li><strong>Real-time Indexing</strong>: It allows real-time read and write operations, making sure the data is always available for searching and analysis.</li><li><strong>High Availability</strong>: Elasticsearch clusters are resilient — they are designed to be fault-tolerant and can handle some level of hardware or software failure.</li><li><strong>JSON-based API</strong>: Elasticsearch supports a RESTful API, which means you can interact with it using standard HTTP methods like GET, POST, PUT, DELETE.</li><li><strong>Advanced Query Language</strong>: Elasticsearch Query DSL (Domain Specific Language) allows for complex queries and aggregations.</li><li><strong>Speed</strong>: It is optimized for high-velocity data and can execute complex queries extremely fast.</li></ol><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts:"></a>Basic Concepts:</h3><ul><li><strong>Node</strong>: A single instance of Elasticsearch.</li><li><strong>Cluster</strong>: A group of one or more node instances that are networked together.</li><li><strong>Index</strong>: A collection of documents that have somewhat similar characteristics.</li><li><strong>Document</strong>: A basic unit of information that can be indexed. It is expressed in JSON.</li><li><strong>Shard</strong>: Elasticsearch distributes your data into multiple pieces called shards. These are basic units of storage and search in Elasticsearch.</li><li><strong>Replica</strong>: A copy of a shard for high availability.</li></ul><h3 id="Quick-Example-in-Python"><a href="#Quick-Example-in-Python" class="headerlink" title="Quick Example in Python:"></a>Quick Example in Python:</h3><p>You can use the <code>elasticsearch</code> Python package to interact with an Elasticsearch instance. Here’s a quick example to index and search for a document:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pythonCopy code<br><span class="hljs-keyword">from</span> elasticsearch import Elasticsearch<br><br><span class="hljs-comment"># Initialize Elasticsearch client</span><br>es = Elasticsearch([&#123;<span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-string">&#x27;port&#x27;</span>: 9200&#125;])<br><br><span class="hljs-comment"># Index a document</span><br>doc = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: 30, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;engineer&#x27;</span>&#125;<br>res = es.index(<span class="hljs-attribute">index</span>=<span class="hljs-string">&#x27;people&#x27;</span>, <span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">body</span>=doc)<br><br><span class="hljs-comment"># Search for a document</span><br>res = es.search(<span class="hljs-attribute">index</span>=<span class="hljs-string">&#x27;people&#x27;</span>, body=&#123;<span class="hljs-string">&#x27;query&#x27;</span>: &#123;<span class="hljs-string">&#x27;match&#x27;</span>: &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;John&#x27;</span>&#125;&#125;&#125;)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Search results:&quot;</span>, res)<br></code></pre></td></tr></table></figure><h3 id="Use-Cases-for-Fast-Search"><a href="#Use-Cases-for-Fast-Search" class="headerlink" title="Use Cases for Fast Search:"></a>Use Cases for Fast Search:</h3><ol><li><strong>Full-Text Search</strong>: Search through articles, blogs, descriptions, etc.</li><li><strong>Log Analysis</strong>: Fast searching through logs to find errors, exceptions, or specific conditions.</li><li><strong>Real-Time Analytics</strong>: Query large datasets in real-time to get insights.</li><li><strong>Auto-Suggest&#x2F;Completion</strong>: Providing type-ahead suggestions in search bars.</li></ol><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>An index in Elasticsearch is similar to a table in a relational database. It is a collection of documents that share a set of common fields and are related in some way. An index is identified by a unique name, and you can define various settings and mappings (schema) for the index to specify how the data should be stored and indexed. Here are some aspects to consider:</p><ul><li><strong>Settings</strong>: You can define settings like the number of shards and replicas when creating an index. These settings impact how data is distributed and replicated across the cluster.</li><li><strong>Mapping</strong>: This is the schema definition, which describes the fields or properties that documents in the index will have, as well as how those fields should be indexed and stored. This is important for query performance and relevance.</li><li><strong>Aliases</strong>: An index can have one or more aliases, which are alternate names that you can use to perform read and write operations. This can be useful for reindexing data without application downtime.</li><li><strong>Lifecycle</strong>: Indices can have lifecycles managed by Elasticsearch’s Index Lifecycle Management (ILM), where you can define policies for automatic actions like rollover, shrink, or deletion of indices based on specified criteria.</li></ul><p>Here is an example of how to create an index in Elasticsearch using its RESTful API:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">jsonCopy</span> <span class="hljs-meta">code</span><br><span class="hljs-symbol">PUT</span> /my_index<br>&#123;<br>  <span class="hljs-string">&quot;settings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;number_of_shards&quot;</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-string">&quot;number_of_replicas&quot;</span>: <span class="hljs-number">2</span><br>  &#125;,<br>  <span class="hljs-string">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span> &#125;,<br>      <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span> &#125;,<br>      <span class="hljs-string">&quot;email&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span> &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Inverted-Index"><a href="#Inverted-Index" class="headerlink" title="Inverted Index"></a>Inverted Index</h3><p>The most crucial feature that enables fast text search is the use of an “inverted index”. When you index a document, Elasticsearch takes the text in its fields and breaks it down into a list of terms (or “tokens”). These terms are then used to build an inverted index, essentially a mapping from terms to their locations in documents. This enables very quick look-ups when you query for a term, as Elasticsearch can go straight to the locations of the term in the inverted index rather than scanning every document.</p><h2 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h2><p>A document is akin to a row in a table of a relational database. It is a JSON object that contains the data for the fields described in the index’s mapping. Each document is a collection of fields, which are the key-value pairs that contain your data. Each document is identified by a unique ID within an index.</p><ul><li><strong>Fields</strong>: Each field in a document is a key-value pair, where the key is the field name and the value is the data value for that field. Field data types are defined in the index mapping.</li><li><strong>Meta Fields</strong>: Elasticsearch also adds some meta fields to each document, like <code>_id</code> for the document ID and <code>_index</code> for the index name.</li><li><strong>Nested and Complex Types</strong>: Elasticsearch supports nested fields and complex types like arrays and objects to model more complex data relationships.</li></ul><p>Here’s how you can index (add) a new document to an existing index:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">jsonCopy code<br>POST <span class="hljs-regexp">/my_index/</span>_doc<br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">30</span>,<br>  <span class="hljs-string">&quot;email&quot;</span>: <span class="hljs-string">&quot;john.doe@example.com&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>And here’s an example of how you could search for that document based on a match query:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">jsonCopy code<br>GET <span class="hljs-regexp">/my_index/</span>_search<br>&#123;<br>  <span class="hljs-string">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;match&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here’s a simplified example of what the JSON response might look like:</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs fsharp">jsonCopy <span class="hljs-keyword">code</span><br>&#123;<br>  <span class="hljs-string">&quot;took&quot;</span><span class="hljs-operator">:</span> 30,<br>  <span class="hljs-string">&quot;timed_out&quot;</span><span class="hljs-operator">:</span> <span class="hljs-literal">false</span>,<br>  <span class="hljs-string">&quot;_shards&quot;</span><span class="hljs-operator">:</span> &#123;<br>    <span class="hljs-string">&quot;total&quot;</span><span class="hljs-operator">:</span> 3,<br>    <span class="hljs-string">&quot;successful&quot;</span><span class="hljs-operator">:</span> 3,<br>    <span class="hljs-string">&quot;skipped&quot;</span><span class="hljs-operator">:</span> 0,<br>    <span class="hljs-string">&quot;failed&quot;</span><span class="hljs-operator">:</span> 0<br>  &#125;,<br>  <span class="hljs-string">&quot;hits&quot;</span><span class="hljs-operator">:</span> &#123;<br>    <span class="hljs-string">&quot;total&quot;</span><span class="hljs-operator">:</span> &#123;<br>      <span class="hljs-string">&quot;value&quot;</span><span class="hljs-operator">:</span> 1,<br>      <span class="hljs-string">&quot;relation&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;eq&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;max_score&quot;</span><span class="hljs-operator">:</span> 1.0,<br>    <span class="hljs-string">&quot;hits&quot;</span><span class="hljs-operator">:</span> [<br>      &#123;<br>        <span class="hljs-string">&quot;_index&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;my_index&quot;</span>,<br>        <span class="hljs-string">&quot;_type&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;_doc&quot;</span>,<br>        <span class="hljs-string">&quot;_id&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-string">&quot;_score&quot;</span><span class="hljs-operator">:</span> 1.0,<br>        <span class="hljs-string">&quot;_source&quot;</span><span class="hljs-operator">:</span> &#123;<br>          <span class="hljs-string">&quot;name&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;John Doe&quot;</span>,<br>          <span class="hljs-string">&quot;age&quot;</span><span class="hljs-operator">:</span> 30,<br>          <span class="hljs-string">&quot;email&quot;</span><span class="hljs-operator">:</span> <span class="hljs-string">&quot;john.doe@example.com&quot;</span><br>        &#125;<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here’s a breakdown of the key parts of this response:</p><ul><li><strong>took</strong>: The time in milliseconds it took to execute the query.</li><li><strong>timed_out</strong>: Indicates whether the query execution timed out. In this case, it did not.</li><li><strong>_shards</strong>: Information about shard participation in the query, including the total number of shards queried, how many were successful, etc.</li><li><strong>hits</strong>: This section contains the actual results.<ul><li><strong>total</strong>: The total number of matching documents. Here it indicates that there is one document that matches the query.</li><li><strong>max_score</strong>: The maximum relevance score of all hits.</li><li><strong>hits</strong>: An array containing the documents that match the query. Each hit includes:<ul><li><strong>_index</strong>: The name of the index containing the document.</li><li><strong>_type</strong>: The type of the document, usually “_doc” in modern versions of Elasticsearch.</li><li><strong>_id</strong>: The unique ID of the document.</li><li><strong>_score</strong>: The relevance score for this document in relation to the query.</li><li><strong>_source</strong>: The original document source (the data).</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>es</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code Review终极大法</title>
    <link href="/2023/08/28/DevOps/Git/Code-Review%E7%BB%88%E6%9E%81%E5%A4%A7%E6%B3%95/"/>
    <url>/2023/08/28/DevOps/Git/Code-Review%E7%BB%88%E6%9E%81%E5%A4%A7%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="腾讯-13-年，我所总结的Code-Review终极大法"><a href="#腾讯-13-年，我所总结的Code-Review终极大法" class="headerlink" title="腾讯 13 年，我所总结的Code Review终极大法"></a>腾讯 13 年，我所总结的Code Review终极大法</h1><h2 id="为什么技术人员需要CR"><a href="#为什么技术人员需要CR" class="headerlink" title="为什么技术人员需要CR"></a>为什么技术人员需要CR</h2><p>谚语曰: “Talk Is Cheap, Show Me The Code”。知易行难，知行合一难。嘴里要讲出来总是轻松，把别人讲过的话记住，组织一下语言，再讲出来，很容易。设计理念你可能道听途说了一些，以为自己掌握了，但是你会做么？有能力去思考、改进自己当前的实践方式和实践中的代码细节么？不客气地说，很多人仅仅是知道并且认同了某个设计理念，进而产生了一种虚假的安心感——自己的技术并不差。但是他根本没有去实践这些设计理念，甚至根本实践不了这些设计理念，从结果来说，他懂不懂这些道理&#x2F;理念，有什么差别？变成了自欺欺人。  </p><p>代码，是设计理念落地的地方，是技术的呈现和根本。同学们可以在 review 过程中做到落地沟通，不再是空对空的讨论，可以在实际问题中产生思考的碰撞，互相学习，大家都掌握团队里积累出来最好的实践方式！当然，如果 leader 没有时间写代码，仅仅是通过 review 代码指出团队内其他同学某些实践方式不好，需要给出建议的话，leader 本身也需要沉淀很多相关思考。</p><h2 id="为什么要在CR中思考和总结"><a href="#为什么要在CR中思考和总结" class="headerlink" title="为什么要在CR中思考和总结"></a>为什么要在CR中思考和总结</h2><p>我这里先给一个我自己的总结：所谓架构师，就是掌握大量设计理念和原则、落地到各种语言及附带工具链（生态）下的实践方法、垂直行业模型理解，定制系统模型设计和工程实践规范细则，进而控制30万+行代码项目的开发便利性、可维护性、可测试性、运营质量的资深研发群体。</p><p>厉害的技术人，主要可以分为下面几个方向：  </p><p><strong>奇技淫巧：</strong>掌握很多技巧，以及发现技巧一系列思路的人。很多编程大赛比的就是这个，但是这个方向对软件工程用处似乎并不是很大。</p><p><strong>领域奠基：</strong>比如约翰·卡马克，他创造出了现代计算机图形高效渲染的方法论。先不提假设没有他，之后会不会有人发明该方法，从结果上看他就是第一个发明者。1999年，卡马克登上了美国时代杂志评选出来的科技领域50大影响力人物榜单，并且名列第10位。但是类似的殿堂级位置，凤毛麟角，不够大家分，也没我们的事儿。</p><p><strong>理论研究：</strong>八十年代李开复博士坚持采用隐含马尔可夫模型的框架，成功地开发了世界上第一个大词汇量连续语音识别系统 Sphinx。我辈工程师，好像擅长这个的很少。</p><p><strong>产品成功：</strong>小龙哥是标杆。</p><p><strong>最佳实践：</strong>按照上面架构师的定义，这个是大家都可以做到的。在这条路上走得好，就能为任何公司构建技术团队，组织建设高质量的系统。</p><p>从上面的讨论中可以看出，我们普通工程师的进化之路，就是不断打磨最佳实践方法论、落地细节。</p><h2 id="代码变化的根源"><a href="#代码变化的根源" class="headerlink" title="代码变化的根源"></a>代码变化的根源</h2><p>在讨论什么代码是好代码之前，我们先讨论什么是不好的。计算机是人造的学科，我们自己制造了很多问题，进而去思考解法。  </p><h4 id="重复的代码"><a href="#重复的代码" class="headerlink" title="重复的代码"></a>重复的代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plain">// BatchGetQQTinyWithAdmin 获取QQ uin的tinyID, 需要主uin的tiny和登录态<br>// friendUins 可以是空列表, 只要admin uin的tiny<br>func BatchGetQQTinyWithAdmin(ctx context.Context, adminUin uint64, friendUin []uint64) (<br>  adminTiny uint64, sig []byte, frdTiny map[uint64]uint64, err error) &#123;<br>  var friendAccountList []*basedef.AccountInfo<br>  for _, v := range friendUin &#123;<br>    friendAccountList = append(friendAccountList, &amp;basedef.AccountInfo&#123;<br>      AccountType: proto.String(def.StrQQU),<br>      Userid:      proto.String(fmt.Sprint(v)),<br>    &#125;)<br>  &#125;<br><br>  req := &amp;cmd0xb91.ReqBody&#123;<br>    Appid:       proto.Uint32(model.DocAppID),<br>    CheckMethod: proto.String(CheckQQ),<br>    AdminAccount: &amp;basedef.AccountInfo&#123;<br>      AccountType: proto.String(def.StrQQU),<br>      Userid:      proto.String(fmt.Sprint(adminUin)),<br>    &#125;,<br>    FriendAccountList: friendAccountList,<br>  &#125;<br></code></pre></td></tr></table></figure><p>因为最开始协议设计得不好，第一个使用接口的人，没有类似上面这个函数的代码，自己实现了一个嵌入逻辑代码的填写请求结构结构体的代码，在最开始效果还可以。但当有第二、第三个人干了类似的事情，我们将无法重构这个协议，只能麻烦地向前兼容。并且每个同学，都要理解一遍上面这个协议怎么填，理解有问题，就触发 bug。或者如果某个错误的理解普遍存在，我们就得找到所有这些重复的片段，去修改一遍。</p><p>当你要读一个数据，发现两个地方都有，不知道该选哪个。当你要实现一个功能，发现两个 rpc 接口、两个函数都能做到，不知道该选哪个。你有面临过这样的“人生难题”么？其实怎么选已经不重要了，你写的代码已经在走向 shit 的道路上迈出了坚实的一步。</p><h4 id="早期有效的决策不再有效"><a href="#早期有效的决策不再有效" class="headerlink" title="早期有效的决策不再有效"></a>早期有效的决策不再有效</h4><p>很多时候，我们第一版代码写出来，是没有太大的问题的。比如下面这个代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs plain">// Update 增量更新<br>func (s *FilePrivilegeStore) Update(key def.PrivilegeKey,<br>  clear, isMerge bool, subtract []*access.AccessInfo, increment []*access.AccessInfo,<br>  policy *uint32, adv *access.AdvPolicy, shareKey string, importQQGroupID uint64) error &#123;<br>  // 获取之前的数据<br>  info, err := s.Get(key)<br>  if err != nil &#123;<br>    return err<br>  &#125;<br><br>  incOnlyModify := update(info, &amp;key, clear, subtract, <br>    increment, policy, adv, shareKey, importQQGroupID)<br>  stat := statAndUpdateAccessInfo(info)<br>  if !incOnlyModify &#123;<br>    if stat.groupNumber &gt; model.FilePrivilegeGroupMax &#123;<br>      return errors.Errorf(errors.PrivilegeGroupLimit, <br>        &quot;group num %d larger than limit %d&quot;,<br>        stat.groupNumber, model.FilePrivilegeGroupMax)<br>    &#125;<br>  &#125;<br><br>  if !isMerge &#123;<br>    if key.DomainID == uint64(access.SPECIAL_FOLDER_DOMAIN_ID) &amp;&amp;<br>      len(info.AccessInfos) &gt; model.FilePrivilegeMaxFolderNum &#123;<br>      return errors.Errorf(errors.PrivilegeFolderLimit, <br>        &quot;folder owner num %d larger than limit %d&quot;,<br>        len(info.AccessInfos), model.FilePrivilegeMaxFolderNum)<br>    &#125;<br>    if len(info.AccessInfos) &gt; model.FilePrivilegeMaxNum &#123;<br>      return errors.Errorf(errors.PrivilegeUserLimit, <br>        &quot;file owner num %d larger than limit %d&quot;,<br>        len(info.AccessInfos), model.FilePrivilegeMaxNum)<br>    &#125;<br>  &#125;<br><br>  pbDataSt := infoToData(info, &amp;key)<br>  var updateBuf []byte<br>  if updateBuf, err = proto.Marshal(pbDataSt); err != nil &#123;<br>    return errors.Wrapf(err, errors.MarshalPBError,<br>      &quot;FilePrivilegeStore.Update Marshal data error, key[%v]&quot;, key)<br>  &#125;<br>  if err = s.setCKV(generateKey(&amp;key), updateBuf); err != nil &#123;<br>    return errors.Wrapf(err, errors.Code(err),<br>      &quot;FilePrivilegeStore.Update setCKV error, key[%v]&quot;, key)<br>  &#125;<br>  return nil<br>&#125;<br></code></pre></td></tr></table></figure><p>现在看这个代码挺好的，长度没超过80行，逻辑比较清晰。但是当 isMerge 这里判断逻辑，如果加入更多的逻辑，把局部行数撑到50行以上，这个函数味道就坏了。由此出现两个问题：</p><p>函数内代码不在一个逻辑层次上，阅读代码，本来在阅读着顶层逻辑，突然就掉入了长达50行的 isMerge 的逻辑处理细节，还没看完，读者已经忘了前面的代码讲了什么，需要来回看，挑战自己大脑的 cache 尺寸。</p><p>代码有问题后，再新加代码的同学，是改还是不改前人写好的代码呢？要不要往里面填屎，堆屎山呢？出 bug 谁来背？这是一个灵魂拷问。</p><h4 id="对合理性没有苛求"><a href="#对合理性没有苛求" class="headerlink" title="对合理性没有苛求"></a>对合理性没有苛求</h4><p>“两种写法都ok，你随便挑一种吧”，“我这样也没什么吧”，这是我经常听到的话。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">// Get 获取IP<br>func (i *IPGetter) Get(cardName string) string &#123;<br>  i.l.RLock()<br>  ip, found := i.m[cardName]<br>  i.l.RUnlock()<br><br>  if found &#123;<br>    return ip<br>  &#125;<br><br>  i.l.Lock()<br>  var err error<br>  ip, err = getNetIP(cardName)<br>  if err == nil &#123;<br>    i.m[cardName] = ip<br>  &#125;<br>  <br>  i.l.Unlock()<br>  return ip<br>&#125;<br></code></pre></td></tr></table></figure><p>i.l.Unlock()可以放在当前的位置，也可以放在 i.l.Lock()下面，做成 defer。两种在最初构造的时候好像都行，这个时候很多同学态度就变得不坚决。实际上，这里必须是 defer 的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">i.l.Lock()<br>defer i.l.Unlock()<br><br>var err error<br>ip, err = getNetIP(cardName)<br>if err != nil &#123;<br>  return &quot;127.0.0.1&quot;<br>&#125;<br><br>i.m[cardName] = ip<br>return ip<br></code></pre></td></tr></table></figure><p>这样的修改，是极有可能发生的，它还是要变成 defer，那为什么不一开始就是 defer，进入最合理的状态？不一开始就进入最合理的状态，在后续协作中，其他同学很可能犯错！</p><h4 id="总是面向对象-总喜欢封装"><a href="#总是面向对象-总喜欢封装" class="headerlink" title="总是面向对象&#x2F;总喜欢封装"></a>总是面向对象&#x2F;总喜欢封装</h4><p>我是软件工程科班出身，学的第一门编程语言是 C++，教材是《C++程序设计:程序设计和面向对象设计入门(第3版)》 。当时自己读完教材，初入程序设计之门，对于里面讲的“封装”，惊为天人，多么美妙的设计啊；面向对象，多么智慧的设计啊。但是这些年来，我看到了大牛“云风”对于“毕业生使用 mysql api 就喜欢搞个 class 封装再用”的嘲讽；看到了各种莫名其妙的 class 定义；体会到了经常要去看一个莫名其妙的继承树，必须要把整个继承树整体读明白才能确认一个细小的逻辑分支；多次体会到了需要辛苦地压抑住抵触情绪，去细读一个自作聪明的被封装的代码，确认我的 bug。除了 UI 类场景，我认为应该少用继承、多用组合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">template&lt;class _PKG_TYPE&gt;<br>class CSuperAction : public CSuperActionBase &#123;<br>  public:<br>    typedef _PKG_TYPE pkg_type;<br>    typedef CSuperAction&lt;pkg_type&gt; this_type;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这是 sspp 的代码。CSuperAction 和 CSuperActionBase，一会儿 super，一会儿又 base，Super 和 SuperBase 是在怎样的两个抽象层次上，不通读代码，没人能读明白。我想确认任何细节，都要把多个层次的代码都通读了，有什么封装性可言？</p><p>好，你说是作者没有把 class name 取好。那问题是，你能取好么？一个刚入职的新人同学能把 class name、class 树设计得好么？即使是对简单的业务模型，也需要无数次“坏”的对象抽象实践，才能培养出一个具有合格的 class 抽象能力的同学，这对于大型却松散的团队协作，难道不是破坏性的？已经有了一套继承树，想要添加功能就只能在这个继承树里添加，以前的继承树不再适合新的需求，这个继承树上所有的 class，以及使用它们的地方，你都去改？不，是个正常人都会放弃，然后开始堆屎山。</p><p>封装，就是我可以不关心实现，但是做一个稳定的系统，每一层设计都可能出问题。abi，总有合适的用法和不合适的用法，真的存在我们能完全不关心封装的部分是怎么实现的？不，你不能。bug 和性能问题，常常就出现在，你选择了错误的用法去使用一个封装好的函数。即使是  Android、iOS 的 api，Golang、Java 现成的 api，我们常常都要去探究实现，才能把 api 用好。那我们是不是该一上来，就做一个透明性很强的函数才更为合理？使用者想知道细节，进来吧，我的实现很易读，你看看就明白，使用时不会迷路！对于逻辑复杂的函数，我们还要强调函数内部工作方式“可以让读者在大脑里想象呈现完整过程”的可显性，让使用者轻松读懂，有把握，使用时，不迷路！</p><h4 id="根本没有设计"><a href="#根本没有设计" class="headerlink" title="根本没有设计"></a>根本没有设计</h4><p>这个最可怕，所有需求，上手就是一顿撸。“设计是什么东西？我一个文件5w行，一个函数5k行，干不完需求？”从第一行代码开始，就是无设计的，随意地踩着满地的泥坑。对于旁人的眼光没有感觉，一个人独舞，产出的代码完成了需求，毁灭了接手自己代码的人本该用来休息的夜晚~ 这个就不举例了，每个同学应该都能在自己的项目里发现这种代码。</p><h2 id="需要形而上的思考"><a href="#需要形而上的思考" class="headerlink" title="需要形而上的思考"></a>需要形而上的思考</h2><p>同学们常常听演讲、公开课，就喜欢听一些细枝末节的“干货”。这没有问题。但是你干了几年活，学习了多少干货知识点？构建起自己的技术思考“面”，进入立体的“工程思维”，把技术细节和系统要满足的需求在思考上连接起来了么？当听到一个需求的时候，你能思考到自己的 code package 该怎么组织，函数该怎么组织了么？</p><p>技术点要怎么和需求连接起来呢？答案很简单，你需要在时间里总结，总结出一些明确的原则、思维过程。思考怎么去总结，特别像是在思考哲学问题。从一些琐碎的细节中，由具体情况上升到一些原则、公理。同时，大家在接受原则时，不应该是接受和记住原则本身，而应该是解构原则，让这个原则在自己这里重新推理一遍，自己完全掌握这个原则的适用范围。</p><p>再进一步具体地说，对于工程最佳实践的形而上的思考过程，就是：</p><p>把工程实践中遇到的问题，从<strong>问题类型</strong>和<strong>解法类型</strong>两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。当你这套方案能适应 30w+行代码的项目，超过 30 人的项目，你就入门架构师了！当你这个项目是多端、多语言，代码量超过 300w 行，参与人数超过 300 人，代码质量依然很高，代码依然在高效地自我迭代，每天消除掉过时的代码，填充高质量的替换旧代码和新生的代码。恭喜你，你已经是一个很高级的架构师了！再进一步，你对某个业务模型有独到或者全面的理解，构建了一套行业第一的解决方案，结合刚才高质量实现的能力，实现了这么一个项目，恭喜你，你已经成为专家工程师了！</p><p>那么，我们要从头开始积累思考和总结吗？不，有一本书叫做《 Unix 编程艺术》，我在不同的时期分别读了 3 遍，文中的很多原则，正好就能作为 code review 时大家判定代码质量的准绳。但在那之前，我得讲一下另外一个很重要的话题，模型设计。</p><h2 id="model思考"><a href="#model思考" class="headerlink" title="model思考"></a>model思考</h2><p>没读过 oauth2.0 RFC，就去设计第三方授权登陆的人，终归还要再发明一个蹩脚的 oauth。</p><p>2012 年我刚毕业，和一个去了广州联通公司的华南理工毕业生聊天。当时他说他工作很不开心，因为工作里不经常写代码，而且认为自己有 ACM 竞赛金牌级的算法熟练度+对 CPP 代码的熟悉，写下一个个指针操作内存，还有什么程序写不出来，什么事情做不好。当时我觉得，挺有道理，编程工具在手，我什么事情做不了？</p><p>现在我会告诉他，复杂如 Linux 操作系统、Chromium 引擎、Windows Office，你做不了。原因是他根本没进入软件工程的工程世界，不是会搬砖就能修出港珠澳大桥。但是这么回答并不好，举证用的论据离我们太遥远了。我现在会回答，你做不了，简单如一个权限系统，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？简单如一个共享文件管理，你知道怎么做么？堆积一堆逻辑层次一维展开的 if else？你公司有上万台服务器，你要怎么写一个管理平台？堆积一堆逻辑层次一维展开的 if else？</p><p>上来就是干，能实现上面提到的三个看似简单的需求么？想一想，亚马逊、腾讯云们折腾了多少年，最后才找到了容器+Kubernetes 的大杀器。这里需要谷歌多少年在 BORG 系统上的实践，提出了优秀的服务编排领域模型。权限领域，有 RBAC、DAC、MAC 等等模型，到了业务，又会有细节的不同。如 Domain Driven Design 说的，没有良好的领域思考和模型抽象，逻辑复杂度就是 n^2 指数级的，你得写多少 if else，得思考多少可能的 if 路径，来 cover 所有的不合符预期的情况。你必须要有 Domain 思考探索、model 拆解&#x2F;抽象&#x2F;构建的能力。有人问过我，要怎么有效地获得这个能力？这个问题我没能回答，就像是在问我，怎么才能获得 MIT 博士的学术能力？我无法回答。唯一回答就是，进入某个领域，就是首先去看前人的思考，站在前人的肩膀上，再用上自己的通识能力，去进一步思考。至于怎么建立好的通识思考能力，可能得去常青藤读个书吧 :），或者就在工程实践中思考和锻炼自己的这个能力！</p><p>同时，基于 model 设计的代码，能更好地适应产品经理不断变更的需求。比如说，一个 calendar（日历）应用，随便想想，不要太简单！以“userid_date”为 key 记录一个用户的每日安排不就完成了么？只往前走一步，设计了一个任务，上限分发给 100w 个人，创建这么一个任务，是往 100w 个人下面添加一条记录？你得改掉之前的设计，换 db。再往前走一步，要拉出某个用户和某个人一起要参与的所有事务，是把两个人的所有任务来做 join？好像还行。如果是和 100 个人一起参与的所有任务呢？100 个人的任务来 join？不现实了吧。好，你引入一个群组 id，那么，你最开始的“userid_date”为 key 的设计，是不是又要修改和做数据迁移了？经常来一个需求，你就得把系统推翻重来，或者根本就只能拒绝用户的需求，这样的战斗力，还好意思叫自己工程师？你一开始就应该思考自己面对的业务领域，思考自己的日历应用可能的模型边界，把可能要做的能力都拿进来思考，构建一个 model，设计一套通用的 store 层接口，基于通用接口的逻辑代码。当产品不断发展，就是不停往模型里填内容，而不是推翻重来。思考模型边界，构建模型细节，就是两个很重要的能力，也是绝大多数产品经理不具备的能力。你面对产品经理时，就听取他们出于对用户体验负责思考出的需求点，到你自己这里，用一个完整的模型去涵盖这些零碎的点。</p><p>model 设计，是形而上思考中的一个方面，也是一个特别重要的方面。在这里，强烈推荐大家去精读几遍《Unix 编程艺术》这本经典著作，书中提到的 KISS 原则、组合原则、吝啬原则、透明性原则、通俗原则、缄默原则、 补救原则等，都是随着软件工程不断发展，历久弥新的经典原则，值得反复揣摩深思。在自己的 coding&#x2F;code review 中，站在巨人的肩膀上去思考。不重复地发现经典力学，而是往相对论挺进。</p><h2 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h2><p>前文列举了很多大的原则和思考方向，这里再来给大家简单列举几个细节执行点。下面主要针对 Golang 语言，另外我一时也想不全我所执行的所有细则，这就是我强调“原则”的重要性，原则是可枚举的。</p><p>▶︎ 对于代码格式规范，100%严格执行，眼中容不得一点沙。</p><p>▶︎ 文件绝不能超过 800 行，超过一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。</p><p>▶︎ 函数对决不能超过 80 行，超过一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。</p><p>▶︎ 代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">if !needContinue &#123;<br>  doA()<br>  return<br>&#125; else &#123;<br>  doB()<br>  return<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">if !needContinue &#123;<br>  doA()<br>  return<br>&#125;<br><br>doB()<br>return<br></code></pre></td></tr></table></figure><p>下面这个就是 early return，把两端代码从逻辑上解耦了。</p><p>▶︎ 从目录、package、文件、struct、function 一层层下来 ，信息一定不能出现冗余。比如 file.FileProperty 这种定义。只有每个“定语”只出现在一个位置，才为“做好逻辑、定义分组&#x2F;分层”提供了可能性。</p><p>▶︎ 多用多级目录来组织代码所承载的信息，即使某一些中间目录只有一个子目录。</p><p>▶︎ 随着代码的扩展，老的代码违反了一些设计原则，应该立即原地局部重构，维持住代码质量不滑坡。比如：拆文件、拆函数、用 Session 来保存一个复杂的流程型函数的所有信息、重新调整目录结构。</p><p>▶︎ 基于上一点考虑，我们应该尽量让项目的代码有一定的组织、层次关系。我个人的当前实践是除了特别通用的代码，都放在一个 git 里。特别通用、修改少的代码，逐渐独立出 git，作为子 git 连接到当前项目 git，让 Golang 的 Refactor 特性、各种 Refactor 工具能帮助我们快速、安全局部重构。</p><p>▶︎ 自己的项目代码，应该有一个内生的层级和逻辑关系。flat 平铺展开是非常不利于代码复用的。怎么复用、怎么组织复用，肯定会变成“人生难题”。</p><p>▶︎ 如果被 review 的代码虽然简短，但是你看了一眼却发现不咋懂，那就一定有问题。自己看不出来，就找高级别的同学交流。这是你与他人共同 review 代码、共同成长的宝贵时刻。</p><p>▶︎ 日志要少打，要打日志就要把关键索引信息带上，必要的日志必须打。</p><p>▶︎ 有疑问就立即问，不要怕问错，让代码作者给出解释，不要怕问出低级问题。</p><p>▶︎ 不要说“建议”，提问题就直接提，有错误就得改！</p><p>▶︎ 请积极使用 trpc。总是要和老板站在一起！只有和老板达成的对于代码质量建设的共识，才能在团队里更好地做好代码质量建设。</p><p>▶︎ 消灭重复！消灭重复！消灭重复！</p><h2 id="主干开发"><a href="#主干开发" class="headerlink" title="主干开发"></a>主干开发</h2><p>最后我来为“主干开发”多说一句话。道理很简单，只有每次被 review 代码不到 500 行，reviewer 才能快速地看完，而且几乎不会看漏。超过 500 行，reviewer 就不能仔细看，只能大概浏览了。而且让你调整 500 行代码内的逻辑比调整 3000 行甚至更多的代码，容易很多，降低不仅仅是 6 倍，而是一到两个数量级。有问题在刚出现的时候就调整了，不会给被 review 的人带来大的修改负担。</p><p>关于 CI(continuous integration)，还有很多好的资料和书籍，大家应该及时去学习学习。</p><h2 id="Unix编程艺术"><a href="#Unix编程艺术" class="headerlink" title="Unix编程艺术"></a>Unix编程艺术</h2><p>建议大家把《Unix 编程艺术》这本书找出来读一读。你们已经积累了大量的代码实践，亟需对“工程性”做思考总结。很多工程方法论都过时了，这本书的内容是例外中的例外，它所表达出的内容没有因为软件技术的更替而过时。</p><p>佛教禅宗讲“不立文字”（不立文字，教外别传，直指人心，见性成佛），很多道理和感悟是不能用文字传达的。大家常常因为“自己听说过、知道某个道理”而产生一种安心感，认为“我懂了这个道理”，但是自己却不能在实践中做到。知易行难，知道却做不到，在工程实践里，就和“不懂这个道理”没有任何区别。</p><p>曾经我面试过一个别的公司的总监，讲得好像一套一套，代码拉出来遛一遛，根本就没做到，仅仅会道听途说。他在工程实践上的探索前路可以说已经基本断绝了。我只能祝君能做好向上管理，走自己的纯管理道路吧。请不要再说自己对技术有追求，是个技术人了！</p><p>所以大家不仅仅是看看我这篇文章，而是在实践中去不断践行和积累自己的“教外别传”吧。</p><p>《Software Engineering at Google》也是一本必读好书，在这里推荐给大家。</p><p>-End-</p><p>原创作者｜林强</p>]]></content>
    
    
    <categories>
      
      <category>devops</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>cr</tag>
      
      <tag>code review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络概念详解</title>
    <link href="/2023/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="一文熟知网络-–-文章巨长，但是很详细"><a href="#一文熟知网络-–-文章巨长，但是很详细" class="headerlink" title="一文熟知网络 – 文章巨长，但是很详细"></a>一文熟知网络 – 文章巨长，但是很详细</h1><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h3><p>网络是一个比较有趣的事情，但是其内容确相对的枯燥，决定写这篇文章的时候，忽然想起来，网络才是我当年的本专业呀，写了这么多文章的，好像就网络没怎么说过，趁着最近对F5的好奇心就展开描述一下吧。</p><p>网络有趣的点在于它的落地应用，网络枯燥的事儿在于那些字典般的协议，所以本文就穿插着讲吧，少说一点原理，多一点实践；就从一个最常见的场景来描述网络：“你点了一个链接”。</p><h3 id="1-我点了一个链接"><a href="#1-我点了一个链接" class="headerlink" title="1.我点了一个链接"></a>1.我点了一个链接</h3><p>当你开了一个链接，比如点了下<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a>或者某个钓鱼邮件。</p><p>这里放一下“我点了一个链接” 全局的链路图，大家可以前置看下会涉及哪些点，可以节选阅读。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-bbfe99ab1f184972f57e7051950aaa11.webp"></p><h3 id="1-1这是个链接？"><a href="#1-1这是个链接？" class="headerlink" title="1.1这是个链接？"></a>1.1这是个链接？</h3><p>首先你的浏览器得知道你要进行什么资源访问，就是要根据你的url地址解析出：“你要什么？” 这里的url（资源定位符），就是一种用于找资源的协议：</p><p><code>protocol : // hostname[:port] / path / [;parameters][?query]#fragment</code></p><p>浏览器能对这段字符串做识别和解析并完成一个请求，这里最常见的就是各种http&#x2F;https链接。但除此以外，每个app 都会有的URL scheme，我们也可以定义自己的私有协议，app 间开屏跳来跳去大家一定感受过吧，本质上就是触发了其他app的 url scheme 访问，这里有兴趣可以搜一搜“chrome 自定义 protocol” 、 “url scheme”。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-9b699fb7d415aa51bd80631152b3b739.webp"></p><p>除了协议相关，浏览器还会尝试对于链接进行合法性校验，保证执行的正确性。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-b1dc4632ed78f78fe6e44543ae667714.webp"></p><p>继续说http，检测到是http协议时则会尝试进行host的解析，极小部分是直接ip:host访问的，但是由于ip（Internet Protocol，互联网定位用的协议）这东西记起来相当费劲，并且可能会有多个ip地址，所以就诞生了域名（Domain Name）。</p><p>要想解析域名就需要DNS（Domain Name System）。接下来就看下这个过程是怎么发生的，是如何找到服务者的。</p><h3 id="1-2谁来提供服务"><a href="#1-2谁来提供服务" class="headerlink" title="1.2谁来提供服务"></a>1.2谁来提供服务</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-12c9798853ef0b45541f49b7460f5845.webp"></p><h3 id="1-2-1-DNS的由来"><a href="#1-2-1-DNS的由来" class="headerlink" title="1.2.1 DNS的由来"></a>1.2.1 DNS的由来</h3><p>名称到IP的映射，最原始的方式就是本地维护一个hosts文件，用来记录域名到ip的映射。但是随着域名数量越来越大，完全依赖本地文件已经<code>庞大难以维护</code>，并且没有集中式的维护，<code>名称会冲突</code>，就算有集中的站点，这个站点也扛不了这么大的访问量。</p><p>所以，DNS就诞生了，由DNS完成域名到映射的集中存储，并且建设了一个高可用的、合理组织的集群部署。</p><h3 id="1-2-2-DNS的架构"><a href="#1-2-2-DNS的架构" class="headerlink" title="1.2.2 DNS的架构"></a>1.2.2 DNS的架构</h3><p>接下来就看下这个服务是怎么落地的：</p><h3 id="dns命名"><a href="#dns命名" class="headerlink" title="dns命名"></a>dns命名</h3><p>首先DNS规范了命名，DNS规定的命名是一种层次结构，首先是顶级域名，然后是二级域名，然后三级，以此类推。</p><p>目前已有250个顶级域名，二级&#x2F;三级的数量基本是指数级膨胀。这些域名ICANN 负责管理，例如<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a> 一级域是com、二级域是<a href="https://link.zhihu.com/?target=http://baidu.com">http://baidu.com</a>、三级域是<a href="https://link.zhihu.com/?target=http://www.baidu.com">http://www.baidu.com</a></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>站在最上层来看，最初名称和IP的映射，存储的数据结构就是一个大MAP，NAME：IP 或者 NAME：List，后来随着上面所说问题的愈演愈烈，DNS孕育而生，此时简单的map结构存储已经不满足需求了，后来就变成一种树形的存储结构（非本地），这颗树要尽可能的扁平。</p><p>整体来看就是一个大的索引结构，叶子结点就是真正的映射信息，至于为什么这么来设计，主要是管理效率和部署设计上的考量，单就效率和存储而言map没啥问题。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-59803e43510254e0127c839ceb213c4b.webp"></p><h3 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h3><p>单机无论是带宽、计算能力、存储极限都不可能承载全球的流量访问，而这个问题的解决方案就是 “将服务集群化，并把不同的数据按照层次及地域属性等，合理分布到各地域的服务器集群上”，简单来看就是做了一个DNS映射数据的分布式数据库。</p><h3 id="解析流程"><a href="#解析流程" class="headerlink" title="解析流程"></a>解析流程</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-9faf08a32973cd9478982b724868d939.webp"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1. 客户端发起一个DNS请求，先查看本地浏览器是否有这个域名的缓存，有解析结束<br>2. 没有则去看操作系统是否有缓存，有解析结束<br>3. 没有则去看本地host文件，有解析结束<br>4. 没有则发送该请求到本地DNS服务器，如果本地DNS服务器存在则返回<br>5. 不存在本地DNS服务器则请求根域名服务器，比如请求&quot;www.baidu.com&quot;，根域名服务器告诉本地DNS “.com” 顶级域名服务器的位置<br>6. 本地DNS服务器收到顶级域名服务器位置后则向顶级域名服务器请求&quot;www.baidu.com&quot;的IP地址，顶级域名服务器收到后则告诉本地DNS服务器&quot;www.baidu.com&quot;的权威域名服务器地址<br>7. 本地DNS服务器再向权威DNS服务器发起请求，权威DNS服务器查询后将对应的IP地址告诉本地DNS<br>8. 本地DNS服务器缓存该域名与对应IP然后返回IP给客户端<br>9. 浏览器根据TTL缓存该值<br></code></pre></td></tr></table></figure><h3 id="劫持"><a href="#劫持" class="headerlink" title="劫持"></a>劫持</h3><p>整体的访问流程中加了DNS这一层，优点不言而喻，但是加这一层也带来了不少的问题，比如说可用性、安全、性能等问题，可用性、性能这些都是可以通过技术手段压到最小。</p><p>但是安全性问题是一直存在的，本机、DNS服务都有概率被劫持，并且DNS 劫持指向钓鱼网站，如果是单调的转发倒是还行，如果骗你输入点密码啥的就比较有趣了。</p><h3 id="为什么是UDP？为什么是TCP？"><a href="#为什么是UDP？为什么是TCP？" class="headerlink" title="为什么是UDP？为什么是TCP？"></a>为什么是UDP？为什么是TCP？</h3><p>接下来看下DNS底层的协议细节，DNS 域名解析过程的传输层协议是基于UDP的，DNS服务内部通信是基于TCP的。</p><p>为什么这样操作呢？</p><h3 id="详细聊聊差异"><a href="#详细聊聊差异" class="headerlink" title="详细聊聊差异"></a>详细聊聊差异</h3><p>首先对于传递方式而言，TCP是面向连接的，基于一个个的有序数据包从而构成可靠的传输；而UDP 是基于数据报、无序的而导致不可靠的传输方式；而这些差异也从侧面说明了实现上的差异，首先TCP要想面向连接，就得有连接建立的过程，要想有序就要有确认机制，而这些就要求是双工的。</p><p>对于传输效率上，上面说的这些工作必然导致了TCP必然比UDP的头部开销（或者叫元数据开销）要大的多，而且准备工作更多，也就意味着对于一条消息传递，UDP没这么多事儿，要简单得多，效率也就更高。</p><p>对于数据传输上，TCP是面向连接的，可以切成多个数据包来传，而UDP面向报文的，一次性不可能传过大的信息。</p><p>对于可靠性上，TCP 基于连接和确认机制可以保证更可靠，而UDP对于发出去的消息是否成功毫不关注（可以应用层解决的）。</p><p>这就导致了使用场景上的差异，首先对实时性要求极高，比如游戏场景、语音场景、实时视频等，还有多点通讯场景 UDP刚刚好，偶尔的丢失也问题不大。其他场景如果对可靠性较高，那就直接TCP吧。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-38e77fb6686eba22932c5b30d32b5469.webp"></p><h3 id="根据场景来判定"><a href="#根据场景来判定" class="headerlink" title="根据场景来判定"></a>根据场景来判定</h3><p>DNS此时最核心的问题是效率和可靠性的取舍，上面提到过DNS的解析过程是一个迭代查询的过程，尤其对于一些冷门域名，通常需要查询多次，才能查询到对应的权威服务器。基于这个查询过程，UDP 是基于报文广播的，相对于TCP面向连接的处理过程，UDP 少了握手的过程（尤其对于小数据传输场景），头字段更短，效率也就更高了。</p><p>而对于服务内部，信息同步的可靠性是非常必要的，并且内部传递的信息包长也比较大，所以这里就直接用TCP了，那直接用UDP不行吗，也行，在应用层之上补齐ACK机制就可以啦，很多IM应用就是这么做的。</p><p>当然啦，UDP 也有自己的劣势，由于某些原因（协议限制、以太网数据帧限制、UDP发送缓冲区），最小的MTU是576，而DNS为了不超576，把报文长度限制到了512，一旦超过512就会截断，也就导致了报文的不完整。</p><p>针对这种情况，DNS 启用了TCP 重试机制，就目前而言，DNS 是完整支持TCP 和 UDP的，不仅是降级重试使用。虽然RFC6891 中引入了 EDNS 机制，它允许我们使用 UDP 最多传输 4096 字节的数据，但仅仅是从UDP的角度而言。由于MTU 的限制，导致的传输数据分片以及丢失，这个过程是不可靠的，存在被切片和丢弃的可能。</p><p>TCP 和 UDP 的效率差异本质上是相对而言的，如果要传输的数据包越大、建立的连接越少，链接所产生的开销影响也就越小，要根据具体场景分析来看哈，就一次连接尝试分析来看：</p><p>TCP 协议（共 330 字节）:</p><p><em>三次握手 — 14×3(Ethernet) + 20×3(IP) + 44 + 44 + 32 字节</em></p><p>查询协议头 — 14(Ethernet) + 20(IP) + 20(TCP) 字节</p><p>响应协议头 — 14(Ethernet) + 20(IP) + 20(TCP) 字节</p><p>UDP 协议（共 84 字节）</p><p><em>查询协议头 — 14(Ethernet) + 20(IP) + 8(UDP) 字节</em></p><p>响应协议头 — 14(Ethernet) + 20(IP) + 8(UDP) 字节</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-9e71f930ba78cf15b3b951e1e89a7df4.webp"></p><h3 id="1-3手剥笋"><a href="#1-3手剥笋" class="headerlink" title="1.3手剥笋"></a>1.3手剥笋</h3><p>拿到具体的IP地址之后，下一步就是开始发起调用了，整体协议层次是HTTP -&gt; TCP -&gt; IP -&gt; 更底层的协议（暂时就先说到IP哈）。 要研究这个，过程非常像手剥笋的逆过程，先是具体请求内容，然后把请求内容包进HTTP请求中，再把HTTP 请求报文包进TCP 数据包，然后再抱进IP 数据报，然后再往下执行包装和传输。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-3ed2150ecf376fde584094f14358cf1b.webp"></p><h3 id="1-3-1-HTTP-是怎么工作的"><a href="#1-3-1-HTTP-是怎么工作的" class="headerlink" title="1.3.1 HTTP 是怎么工作的"></a>1.3.1 HTTP 是怎么工作的</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-e93169981f03f26c1f1c79f06de9913f.webp"></p><h3 id="HTTP-概要"><a href="#HTTP-概要" class="headerlink" title="HTTP 概要"></a>HTTP 概要</h3><p>一个http请求通常由Request-Line、Header、Body 构成</p><p>Request-Line：请求方法、Request-URI、HTTP-version、CRLF构成</p><p>Header：一堆键值对 </p><p>Body：请求的业务数据</p><p>然后返回也相对类似，返回的Status-Line（http-version、status-code、Reason-Phrase）、Header、Body 先来看一个HTTP 请求：</p><p><code>curl -H “Content-Type: application/json” -H “Cookie: cc=2333” -X POST —data ‘&#123;&#125;’ http://localhost:8080/say-hello</code></p><h3 id="HTTP-拆解"><a href="#HTTP-拆解" class="headerlink" title="HTTP 拆解"></a>HTTP 拆解</h3><p>构建一个http 请求报文，先生成一个request-line，指定好uri、version等，会有部分数据存放于URI中，这里会进行对应的urlEncode</p><p>进行header的填充，常用的比如有keep-alive 可以让链接保活（复用下层链接）；User-agent 标示一下客户端信息、Accept表明一下要接受什么数据、Cookie 记录的端信息等、Content-Type表明body编码，你也可以自定一些业务属性的header来封装一些共性的逻辑，避免每次都操作Body</p><p>然后把业务数据放到body中，body通常会有三种编码格式：application&#x2F;json、application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、raw、binary，具体的类型可以看下请求的content type，表达方式不同而已，在使用上会有差异，但是对于网络本身都差不多，对于使用上，基于约定、做好统一就OK了。</p><p>然后请求按照不同的Method 发起请求，比如最常见的get&#x2F;post，再或者依赖HTTP语义（get&#x2F;post&#x2F;put&#x2F;delete等）的RestFull使用方式。</p><p>至此就完成了一个HTTP请求，然后把报文交给下一层了，然后等HTTP Response 就好了。</p><h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>等请求返回时，如写一般，获取对应的header、body信息即可，但是Status-line 相对Requet-Line多了一部分状态标示。这里放一点经常会出现的错误码，比如200、302。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">1XX 标示一些中间状态码，比如100收到header、101协议切换、102 处理中等等<br><br>2XX 标示成功，200成功返回、201创建资源成功、204返回了寂寞、202处理中等等<br><br>3XX 标示重定向，常见的有301/308永久重定向（记得刚开始学编程时，发现301很多浏览器会对于post请求丢失body）、302/303 临时重定向、304 未发生变化、307临时重定向，通常用于upload场景的定向，具体重定向的实现要看浏览器，标准是标准，实现是实现<br><br>4XX 标示客户端错误，400 bad request 格式有问题、401 需要认证信息、403 无权限、404 uri资源丢失、405 不支持的方法、408 接受请求超时<br><br>5XX 标示服务端错误，500 server端异常、502 访问代理正常但是Server丢了、504 代理访问server超时、505 不支持对应的http版本<br></code></pre></td></tr></table></figure><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>提到HTTP不得不提的就是https，https其实就是在http体系之中插了一层SSL协议（Secure Socket Layer），SSL 是作用于传输层的，对于传输层进行加密完成应用层的安全传输。</p><p>SSL分为记录协议和握手协议，其中记录协议建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。而握手协议建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</p><p>本质上是在传输层协议和应用层协议之间的一层处理切面，是对于传输层进行加密，进而赋能应用层。至于更高层的协议是什么，SSL是不关注的，所以认为它是传输层的协议。</p><p>SSL基于非对称加密，提供信息加密服务；同时利用机密共享和hash策略提供完整性校验；并且SSL是双向认证的，握手时交换各自的识别号，避免冒名。</p><h3 id="1-3-2-TCP-是怎么工作的"><a href="#1-3-2-TCP-是怎么工作的" class="headerlink" title="1.3.2 TCP 是怎么工作的"></a>1.3.2 TCP 是怎么工作的</h3><p>拿到http 等应用层报文之后，下一步是将这些报文放到TCP数据包中。数据包的组装还原都是由操作系统完成的，应用程序并不感知具体的TCP细节，操作系统负责TCP 数据的完整性，对应的TCP中的具体数据完全由应用程序感知，操作系统毫不关心。</p><p>TCP 是面向连接的，并且TCP是可靠的数据传输，核心原因是TCP的连接机制和ACK校验机制。 记住：when in doubt，use TCP。</p><h3 id="TCP-包格式"><a href="#TCP-包格式" class="headerlink" title="TCP 包格式"></a>TCP 包格式</h3><p>大体看一下TCP的包结构，不用刻意去记，碰到具体场景，就知道是做什么的了</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-49df378dece10e306f8ae8958b8ae9b0.webp"></p><h3 id="链接建立"><a href="#链接建立" class="headerlink" title="链接建立"></a>链接建立</h3><p>首先是三次握手 建立连接，发送端一个seq&#x3D;x，然后接受端收到之后，会应答一个SYN&#x3D;1,ack&#x3D;1,并回执一个seq &#x3D; y,ack&#x3D;x+1，然后发送端应答一个SYN&#x3D;0, ack&#x3D;1，并回执一个seq&#x3D;y+1,ack&#x3D;y+1 这个握手过程是为了校验两端的发送&#x2F;接受状态是否ok，如果校验通过则完成连接建立，3次数字是一个刚刚好的值，多了冗余，少了不够用。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-cc37d0f416a2259defbcbc9abd2a06b3.webp"></p><p>尝试翻译一下，先是发送端发送没问题，然后接收端接受没问题，回执告知接收没问题，验证接受端发送没问题，然后回执告知接收端发动端接收没问题，至此两端就知道了双方都没问题，开启传送。</p><h3 id="可靠性与效率的兼顾：ACK-慢重启"><a href="#可靠性与效率的兼顾：ACK-慢重启" class="headerlink" title="可靠性与效率的兼顾：ACK &amp; 慢重启"></a>可靠性与效率的兼顾：ACK &amp; 慢重启</h3><p>网络传输当然是越快越好，发送、传输、接受都是有限制的，并且硬件不完全是可靠的，过热、缓冲溢出，如果拥堵程度过高或者硬件不稳定时，很有可能发生丢包。</p><p>发的越快，丢的越多，重试的也就越多，效率反而底下，还不如慢慢发，但是磨磨叽叽的也不合适，那就需要找一个最佳的传输速度。而这个传输速度完全是试出来的，怎么试呢？</p><p>收到消息时，接受端会回执一个ACK，这个ACK中包含两个信息，一个是序号，另一个是接收窗口的剩余容量。</p><p>定义丢包：接受到数据包时，就会回执下一个消息的需要，如果发送端发现持续在回执已发送的一个序号，那说明此前发过的包就丢了。包丢了怎么办呢，就从那个位置开始重新发送。</p><p>接受窗口：发送端和接受端的窗口通常是不相通的，我们发送的数据包不能超过窗口的大小。</p><p>就以这两个信息未基准，开始慢慢启动，寻找最优速率，通常从第10个数据包启动（这个是 TCP_INIT_CWND 这个常量定义的），即时带宽很大，TCP 主要是兼顾可靠性和传输效率。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-dea2ea7424cab0587f9f68bd765afee1.webp"></p><h3 id="可靠性与效率的兼顾：拥塞避免-快恢复"><a href="#可靠性与效率的兼顾：拥塞避免-快恢复" class="headerlink" title="可靠性与效率的兼顾：拥塞避免 &amp; 快恢复"></a>可靠性与效率的兼顾：拥塞避免 &amp; 快恢复</h3><p>大量的持续性拥塞会导致丢包数量加剧，这会导致整个传输的可用性下降，除了慢重启探索最佳的传输效率，另外两个手段是拥塞避免和快恢复。</p><p>首先对于是否拥塞，TCP 有个变量记录拥塞窗口（cwnd），本质上就是个发送方发送数据的滑动窗口。</p><p>这里有个阈值（ssthresh），到达阈值之前慢重启指数级增量探索cwnd，然后在用拥塞避免算法线性增加窗口，如果发现丢包啦，也就是开始重传了。</p><p>这里丢包的原因可能有两个， 一个是确实网络环境差（没有收到回执），一个是偶现丢失（重复的ACK），对于这两种情况处理策略是不同的。</p><p>对于网络环境确实差，直接重新慢启动。</p><p>对于偶现的丢包，把cwnd&#x2F;2+3，ssthresh&#x3D;cwnd，进入快速恢复阶段，等收到新数据的ACK之后，再从慢重启阈值进入拥塞避免阶段。</p><p>TCP差不多就是这样来兼顾可靠性和效率，以此榨干带宽的。</p><h3 id="怎么看下TCP的过程呢？"><a href="#怎么看下TCP的过程呢？" class="headerlink" title="怎么看下TCP的过程呢？"></a>怎么看下TCP的过程呢？</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-4a24bf9b65aecd94bcb0bd9612d17392.webp"></p><h3 id="1-3-3-IP-是怎么工作的"><a href="#1-3-3-IP-是怎么工作的" class="headerlink" title="1.3.3 IP 是怎么工作的"></a>1.3.3 IP 是怎么工作的</h3><p>在拿到TCP的包之后，下一步就是对于这个包进行再包装，加上IP的头，这个IP的头里包含了IP相关的信息（核心是自身IP和目标IP）</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-1676f7e35f4820a6b7c7bfc238167b60.webp"></p><p>IP协议下是怎么工作的呢？</p><p>首先最早期的网络是通过MAC地址进行传输的，但是如果机器不在一个子网络内是无法知道对方mac地址的，怎么办呢，IP就诞生了，用来连接多个子网络。</p><p>首先电脑要想上网，有这么几个信息必须要关注：本机的IP地址、子网掩码、网关的IP地址。</p><h3 id="本机IP"><a href="#本机IP" class="headerlink" title="本机IP"></a>本机IP</h3><p>本机IP 分两种，静态分配和动态获得，所谓的动态IP就是基于DHCP协议，发送一个DHCP数据包申请对应的IP地址和对应的网络参数。</p><p>DHCP 是一个应用层协议，建立在UDP之上，设置自己的MAC地址后，直接对外广播（无目的IP和MAC地址），只有DHCP知道是发给自己的，然后按照对应的MAC地址分配IP执行应答。</p><h3 id="子网掩码-网关"><a href="#子网掩码-网关" class="headerlink" title="子网掩码 &amp; 网关"></a>子网掩码 &amp; 网关</h3><p>子网掩码是用来校验要访问的目的IP是否为子网内的IP，他会对于自己的IP进行AND运算，然后对目的IP也进行AND运算，如果结果不同，则不是一个子网，必须通过访问网关来访问其他的子网络。</p><p>然后数据包就根据这些目标IP和网关之间各种大街小巷的传递了 netstat&#x2F;route 可以看对应的信息</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-79f766ff9fc67c08919a7d0d997897c7.webp"></p><h3 id="扯点下一层"><a href="#扯点下一层" class="headerlink" title="扯点下一层"></a>扯点下一层</h3><p>仅仅知道IP是不够的，真正的物理层传输还是需要MAC地址的，拿到IP地址后怎么知道访问哪台机器呢，ARP协议、RARP协议就是干这个事儿的，每个主机内部都维护了个映射表，用于解析出IP对应的是哪个地址。再往下一层就是介质访问协议了。</p><h3 id="1-4-到达服务端"><a href="#1-4-到达服务端" class="headerlink" title="1.4 到达服务端"></a>1.4 到达服务端</h3><p>你的请求兜兜转转终于到了服务端，但是最初接触到的并不是直接的服务者，我们日常访问的网站，背后的服务器都是数以万计的，并且这些服务承载着各种各样的职责，比如说流量接入、各种业务功能提供（登录、处理你的请求）、数据存储、缓存提速、协同、负载均衡、数据计算等等若干的能力。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-bbfe99ab1f184972f57e7051950aaa11.webp"></p><p>再回顾一下这个图，接下来就看下冰山一角的背后到底发生了什么？</p><h3 id="1-4-1-流量接入"><a href="#1-4-1-流量接入" class="headerlink" title="1.4.1 流量接入"></a>1.4.1 流量接入</h3><p>首先一台机器是不可能扛的了百万、甚至千万的qps的，必然要做集群，再后来为了系统的可维护性、可用性，并且由于康威定律等因素按照功能进行了拆分，每个业务系统一个或者多个业务Server集群，多个Server合作构成整体的服务，呈分布式架构。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-a1ca5132b8ad8c904d655167f9ba93f4.webp"></p><p>最初的web互联网，功能相对简单，流量也小，DNS做流量分发足够了。但是后来，我们有了多个业务Server集群，完全按照DNS进行分发是不现实的。</p><p>同一个服务不同功能用不同域？ 一个域名解出2w台机器？ 业务Server不可用了DNS发现不了呀！ 这个功能的机器32核？ 这个功能2核心？这DNS去哪知道 想在流量入口处加一点通用逻辑？对不起，每个Server都改一下吧 加了台机器，好久才生效啊！</p><p>怎么整呢？起一个单独的集群来搞定这件事儿吧，把负载均衡这个事儿控制控制在自己手里吧。</p><p>首先我们要做的事儿是把负载合理的分摊到各个后端的服务上。现状是，主机和主机的通信是基于ip+端口的，软件能实现的流量分发只能在4-7层，再向下第2-3层 需要相关的硬件支持。</p><h3 id="1-4-1-1-负载均衡"><a href="#1-4-1-1-负载均衡" class="headerlink" title="1.4.1.1 负载均衡"></a>1.4.1.1 负载均衡</h3><p>负载均衡主要是三大应用场景：</p><p>链路负载均衡（LLB）：运营商的链路选择，通常用于企业或数据中心的网络出口，选择不同的网络运营商，完成负载分担，并且流量的源进源出做到同源，来降低时延。</p><p>全局负载均衡（GLB）：全局负载均衡的本质是智能DNS，当解析流量到达各个数据中心GLB时，GLB会根据用户local DNS的具体区域来返回对应的IP</p><p>服务器负载均衡（SLB）：就是本片要说的内容，如何将负载合理的分摊到后端的服务上。</p><h3 id="1-4-1-2-每一层的负载均衡"><a href="#1-4-1-2-每一层的负载均衡" class="headerlink" title="1.4.1.2 每一层的负载均衡"></a>1.4.1.2 每一层的负载均衡</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-6ec94f9a068c2524499302a180894fd4.webp"></p><p>在第二层做负载均衡：单臂 硬件可以直接对MAC地址进行处理，对外虚拟一个MAC地址，然后接受请求后分配真实的MAC地址，业务请求处理完成后直接返回给客户端。</p><p>在第三层做负载均衡：单臂 跟MAC地址的处理类似，提供虚拟IP，接受请求后分配真实的IP地址。通常用于一个路由域内，同样业务请求处理完成后直接返回给客户端。</p><p>在第四层做负载均衡： 在网络层之上，也就是传输层加以逻辑做处理，修改数据包中的IP + 端口，转发给对应的后端服务。</p><p>再高层做负载均衡： 基于应用层协议，起一个专门做流量入口然后分发到各个服务的请求处理集群，或者直接做一个应用，然后让它来代理业务Server，把分发的职责给落地。比如HTTP，根据URI进行请求的转发。</p><p>对于SLB而言，最佳的落地是传输层负载均衡（四层）和应用层负载均衡（七层），接下来看为什么及业界的最佳实践。</p><h3 id="1-4-1-3-基于硬件的负载均衡"><a href="#1-4-1-3-基于硬件的负载均衡" class="headerlink" title="1.4.1.3 基于硬件的负载均衡"></a>1.4.1.3 基于硬件的负载均衡</h3><p>直接基于硬件去做，比如F5 Network Big-IP，从硬件层面做了优化，可以理解为就是一个非常强大的网络交换机，每秒百万级的处理轻轻松松，完整的网络处理解决方案，易用性、功能丰富度都不错，省心省力，就是贵。</p><h3 id="1-4-1-4-基于软件的负载均衡-–-LVS"><a href="#1-4-1-4-基于软件的负载均衡-–-LVS" class="headerlink" title="1.4.1.4 基于软件的负载均衡 – LVS"></a>1.4.1.4 基于软件的负载均衡 – LVS</h3><p>首当其冲的就是LVS，分为DR模式、IP TUNNEL模式、NAT模式 DR模式就如上面说的，直接对于MAC地址进行虚拟和分配，要求负载均衡服务和后端服务必须在一个VLAN内，由于数据包由后端服务器直接返回给客户端，因此也会要求后端服务器必须绑定公网 IP，这个模式性能最好，但是对于组网要求非常苛刻。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-e8d4532589df09cdd457593d07f94f69.webp"></p><p>IP TUNNEL模式，将客户端请求数据包报文首部再封装一层 IP 报文，目标地址为后端服务，包通信通过 TUNNEL 模式实现，可以完成跨VLAN通信，但TUNNEL 模式走的隧道模式，运维起来比较困难，在实际应用中不常用。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-735d7915a0e964df175b0ec32659d5ef.webp"></p><p>NAT模式，在传输层对于IP和端口进行修改（以虚拟IP对外提供访问，然后篡改目标IP地址，可以理解为三层+四层负载，在四层上干了点三层的事儿，就一次链接），中间完整插了一层LVS Server，请求和响应都需要经过LVS Server。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-f1341cf7c64f26a0df32590c7f3a0199.webp"></p><p>还有一种更加彻底的 NAT 模式：即均衡器在转发时，不仅修改目标IP 地址，连源IP 地址也一起改了，源地址就改成均衡器自己的 IP，称作 Source NAT（SNAT）。</p><p>阿里云对LVS增加了一种模式，封装了个SLB，新增转发模式 FULLNAT，实现了NAT下跨VLAN通信，有兴趣可以查一下。</p><h3 id="1-4-1-5-基于软件的负载均衡-–-HAProxy"><a href="#1-4-1-5-基于软件的负载均衡-–-HAProxy" class="headerlink" title="1.4.1.5 基于软件的负载均衡 – HAProxy"></a>1.4.1.5 基于软件的负载均衡 – HAProxy</h3><p>NGINX&#x2F;HAProxy下的四层负载均衡，直接暴露的是负载均衡服务的IP地址（纯粹的四层负载），会单独同后端服务新建立连接，所以能跨VLAN了。算上最初的请求，整体会有两次链接发生。很多mysql集群的接入就是用HAProxy来做的。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-e56d4cb2efc2d6578922dce8a5605e34.webp"></p><h3 id="1-4-1-6-基于软件的负载均衡-–-Nginx"><a href="#1-4-1-6-基于软件的负载均衡-–-Nginx" class="headerlink" title="1.4.1.6 基于软件的负载均衡 – Nginx"></a>1.4.1.6 基于软件的负载均衡 – Nginx</h3><p>估计是大家接触最多的一个应用啦，实现于应用层，属于第七层负载，根据HTTP协议内容进行相关的负载均衡工作。 首先客户端同Nginx Server建立连接，然后nginx server 同后端Server建立连接，会有两次链接发生，同时由于是应用层协议，会多1次拆包、装包的过程，处理应用层协议的过程。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-5aecd81acf18f257a47a558f7396965a.webp"></p><h3 id="1-4-1-7-业界的通常实践"><a href="#1-4-1-7-业界的通常实践" class="headerlink" title="1.4.1.7 业界的通常实践"></a>1.4.1.7 业界的通常实践</h3><p>直接拿F5&#x2F;LVS NAT做入口负载均衡，然后再挂一层nginx 做具有业务属性的负载均衡，然后然后内网中使用LVS DR或者NAT或者HAProxy再针对服务集群单独做负载均衡。 就是最开始看到的这样子：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-a1ca5132b8ad8c904d655167f9ba93f4.webp"></p><h3 id="1-4-1-8-负载均衡算法"><a href="#1-4-1-8-负载均衡算法" class="headerlink" title="1.4.1.8 负载均衡算法"></a>1.4.1.8 负载均衡算法</h3><p>轮询法： 将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。</p><p>随机法： 通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。</p><p>源地址哈希法： 源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。</p><p>加权轮询法： 不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</p><p>加权随机法： 与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。</p><p>最小连接数法： 最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前。</p><h3 id="1-4-1-9-部署方式汇总"><a href="#1-4-1-9-部署方式汇总" class="headerlink" title="1.4.1.9 部署方式汇总"></a>1.4.1.9 部署方式汇总</h3><p>有三种部署方式：路由模式、桥接模式、服务直接返回模式。</p><p>路由模式： 路由模式的部署方式，服务器的网关必须设置成负载均衡机的LAN口地址，且与WAN口分署不同的逻辑网络。因此所有返回的流量也都经过负载均衡。</p><p>桥接模式： 桥接模式配置简单，不改变现有网络。负载均衡的WAN口和LAN口分别连接上行设备和下行服务器。LAN口不需要配置IP（WAN口与LAN口是桥连接），所有的服务器与负载均衡均在同一逻辑网络中。</p><p>服务直接返回模式： 这种安装方式负载均衡的LAN口不使用，WAN口与服务器在同一个网络中，互联网的客户端访问负载均衡的虚IP（VIP），虚IP对应负载均衡机的WAN口，负载均衡根据策略将流量分发到服务器上，服务器直接响应客户端的请求。因此对于客户端而言，响应他的IP不是负载均衡机的虚IP（VIP），而是服务器自身的IP地址。也就是说返回的流量是不经过负载均衡的。因此这种方式适用大流量高带宽要求的服务。</p><h3 id="1-4-2-业务Server-开始处理"><a href="#1-4-2-业务Server-开始处理" class="headerlink" title="1.4.2 业务Server 开始处理"></a>1.4.2 业务Server 开始处理</h3><p>经过n层的负载均衡处理之后，接下来真正进入业务Server的处理流程，首先到达的API Web Server，这些业务通常是运行在web容器中的，比如说tomcat、apache，后这些API Server 背后，通过网络依赖了各种功能职责的基于RPC框架的业务Server，然后业务逻辑的处理过程中会用到各种各样的中间件，比如Redis、Kafka、Mysql，这些技术中间件也有着自己的部署集群，要想访问也大多存在网络过程，这些API服务、RPC服务、中间件服务共同完成了业务功能。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-426f8afe9ace3b659a99d599dccc4de8.webp"></p><h3 id="1-4-2-1-网络IO"><a href="#1-4-2-1-网络IO" class="headerlink" title="1.4.2.1 网络IO"></a>1.4.2.1 网络IO</h3><p>站在业务Server实现的角度而言，处理跨越千山万水而来的请求，首先第一步是接受请求、第二步解析请求、第三步处理业务逻辑、第四步写入响应并返回。而接受请求的处理，就是如何去处理网络IO（发起请求也是一样的，叙述顺序放在这里感觉更流畅）。</p><p>在TCP完成握手之后，接收缓冲区就开始不断的被写入数据，然后应用程序就从缓冲区（内核）中读取数据，复制到进程缓冲区（用户），这个过程就是指网络IO的处理过程。</p><p>网络IO的处理模式发展到现在，常见的有这么几种：阻塞IO、非阻塞IO、多路复用的IO。</p><h3 id="盘盘概念-—-阻塞-非阻塞"><a href="#盘盘概念-—-阻塞-非阻塞" class="headerlink" title="盘盘概念 — 阻塞&#x2F;非阻塞"></a>盘盘概念 — 阻塞&#x2F;非阻塞</h3><p>阻塞IO就是在应用程序创建一个线程&#x2F;进程读取缓冲时，如果数据没准备好，那（线程&#x2F;进程）就一直等着。 非阻塞IO就是应用程序创建一个线程&#x2F;进程读取缓冲时，如果数据没准备好，那（线程&#x2F;进程）不会等待，先去干点别的。</p><p>至于IO多路复用，就是应用程序创建一个或者几个线程&#x2F;进程 去读取缓冲，在非阻塞的基础上，去读那些准备好的数据，常见的有select、poll、epoll。</p><h3 id="盘盘概念-—-同步-异步"><a href="#盘盘概念-—-同步-异步" class="headerlink" title="盘盘概念 — 同步&#x2F;异步"></a>盘盘概念 — 同步&#x2F;异步</h3><p>阻塞&#x2F;非阻塞的参考标准是执行对象（线程&#x2F;进程），被挂起等待就是阻塞的，反之非阻塞；相信大家肯定还看过“同步&#x2F;异步”这俩词儿，参考标准是事儿的执行对象是谁，同步是当前线程&#x2F;进程是操作的执行者，异步是非当前线程&#x2F;进程作为执行者。</p><p>很清晰，同步异步指的是执行者是否为当前线程，阻塞非阻塞指的是当前线程是否被挂起，组合一下有这么三种模式：</p><p>同步阻塞IO，每次起一个线程&#x2F;进程，夯在那里读数据，开销极高，性能比较差。</p><p>同步非阻塞IO，select、poll、epoll模式都是同步非阻塞的，由当前线程不断的检查是否有数据可读并完成读取，根本差异是对于活跃链接、非活跃链接的维护方式不同。</p><p>比如epoll红黑树存放监听链接、双向链表存放就绪链接，当tcp三次握手，对端反馈ack，socket进入rcvd状态时标为可读、established状态时标为可读、</p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>异步IO需要内核的支持，一次性把数据读取这个事儿做完，然后通知应用线程&#x2F;进程。</p><p>不少编程语言在同步非阻塞之上利用通知机制做出了异步编程模型。</p><h3 id="1-4-2-2-C10K-epoll"><a href="#1-4-2-2-C10K-epoll" class="headerlink" title="1.4.2.2 C10K &amp; epoll"></a>1.4.2.2 C10K &amp; epoll</h3><p>想要高效就用epoll吧。</p><p>往前数大约20年，网络方面最头疼的问题应该是C10K问题，目前单机处理1w连接不是什么难事儿，但是20年前如何单机如何突破网络处理的性能极限，如何小资源成本完成大连接数的处理，是一个业界最大的难题。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-b31ca36a43c2171b1dd7b129c5be62ce.webp"></p><p>C10K问题最核心的是早期基于进程&#x2F;线程处理模型的BIO模式，如果要扛10k链接，就需要10k个线程或进程，但是进程是一个极耗资源的操作，一台机器常驻10k网络处理的进程是不现实的，虽然可以用分布式来解决单机极限，但是机器成本确无法忽视，并且一味的提升机器配置也不解决问题，链接数膨胀所带来的额外开销是指数级上升的。</p><p>C10K 问题本质上是操作系统的问题，早期的操作系统并没有提供小成本的网络链接处理方法，BIO模式所带来的线程&#x2F;进程上下文切换、数据拷贝的成本极高，导致CPU消耗过高，以至于极少链接就会到达CPU处理极限。</p><p>对于这个问题的解决就是IO多路复用，用有限的线程&#x2F;进程处理无限的网络链接，如果单线程处理多链接，首先要解决的就是阻塞问题，一个阻塞就大家就都没的玩了，落地的实现有select、poll、epoll。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-75b5a759865ed2044f33d3a9a954e893.webp"></p><h3 id="首先是select："><a href="#首先是select：" class="headerlink" title="首先是select："></a>首先是select：</h3><p>用一个fd_set 结构体来告诉内核同时监控多个文件句柄（网络链接），当其中有文件句柄的状态发生指定变化（例如某句柄由不可用变为可用）或超时，则调用返回。这种模式对于处理上有小规模的提升，但是句柄数量的上限是有限的，并且遍历检查每个句柄效率比较低。</p><h3 id="然后是poll："><a href="#然后是poll：" class="headerlink" title="然后是poll："></a>然后是poll：</h3><p>poll 的处理模式跟select一致，主要是解决了句柄数量上限的问题，通过一个 pollfd 数组向内核传递需要关注的事件消除文件句柄上限，但是遍历检查效率低的问题依旧没有解决。</p><h3 id="最后憋了个大招，epoll："><a href="#最后憋了个大招，epoll：" class="headerlink" title="最后憋了个大招，epoll："></a>最后憋了个大招，epoll：</h3><p>既然轮询所有的文件句柄效率太低，那么是不是可以只关注活跃的链接，epoll就是这个思路，把链接分为活跃和非活跃，当链接有事件发生时，回调epoll的api，把链接放到遍历的双向链表中，由于现实情况活跃链接在整体链接中的占比相对较小，epoll能处理的链接数要远超poll、select，比起BIO更是高了几个数量级。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-4be9313f6d0f283218c136e93b31969e.webp"></p><p>目前基于epoll落地的编程模型就是异步非阻塞回调模型，也可以叫做Reactor、事件驱动、事件轮询。epoll 本身是同步非阻塞的哈，nginx、libevent、node.js 都是当时epoll产生之后的产物。</p><p>epoll是linux上的产物，win有对应的IOCP、Solaris推出了&#x2F;dev&#x2F;poll。</p><h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>C10K问题的研究是一个非常好的开端，下一个时代，网络应用继续膨胀，我们要面临的可能就是C10M问题了，我们现在看C10M，就同20年前看C10K是一样的，一座大山，上来了，也就上来了。盲猜一下解决的角度，首先是协议的角度；其次是对于数据包的处理模式（内核的角度）；CPU核心处理的专用优化（硬件的角度）。</p><h3 id="1-4-2-3-Web容器-—-api-Server"><a href="#1-4-2-3-Web容器-—-api-Server" class="headerlink" title="1.4.2.3 Web容器 — api Server"></a>1.4.2.3 Web容器 — api Server</h3><p>web容器顾名思义，存放web服务的容器，业界最常使用的web容器应该就是Tomcat了，tomcat就是在Java EE的JSP、Servlet标准下的web服务器，从上学那会儿就是必看科目，工作这么些年了，还是它。</p><p>tomcat 涉及到的内容非常多，对应的servlet规范、网络处理模型、work模型等等，这里不展开，仅说和网络相关的内容。</p><p>首先Tomcat由Java语言实现，处理的是HTTP请求，站在实现的角度而言就是处理网络IO，解析出请求后进行业务处理。</p><p>Java 中对于网络IO的处理发展到现在有：BIO、NIO、AIO BIO就是同步阻塞式IO，性能很差，NIO（New IO）指得是同步非阻塞IO，通常我们的服务是部署在Linux之上的，NIO是基于epoll实现的。</p><h3 id="举个例子tomcat-处理模型"><a href="#举个例子tomcat-处理模型" class="headerlink" title="举个例子tomcat 处理模型"></a>举个例子tomcat 处理模型</h3><p>接下来看下tomcat整体的处理细节，tomcat是一个web server，然后其中运行的服务是service，然后每个service有两大关键部分，connector、container，connector负责链接的处理、container负责具体的业务请求处理。 我们要关注网络相关的，最核心的就是connector。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-33e5e321e25bebda642aa71ef0c80104.webp"></p><p>首先连接器中的acceptor监听对应的socket链接，然后handler处理接受到的scoket，内部调用，交由processor处理生成对应的Request对象，然后将request交付对应Servlet进行处理。</p><p>根据协议和端口确定Service和engine，根据域名找到对应的host，然后根据uri找到对应的context和对应的Servlet实例。</p><p>engine是运行servlet处理器的引擎，host就是主机的能力，context代表应用程序，wrapper是一个servlet实例。</p><p>springMVC里面就一个Servlet，所以模型大致是这样子：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-43ca4efef7756af3115ac270e84548c1.webp"></p><h3 id="1-4-2-4-rpc框架-—-分布式利器"><a href="#1-4-2-4-rpc框架-—-分布式利器" class="headerlink" title="1.4.2.4 rpc框架 — 分布式利器"></a>1.4.2.4 rpc框架 — 分布式利器</h3><p>在微服务&#x2F;分布式架构下，由若干个服务共同构成了完整的服务功能，而服务和服务之间的协作&#x2F;通信就是依赖rpc框架来完成的。rpc全称是远程过程调用，说白了就是像使用本地方法一样使用隔着网络远端的方法，这个调用就被称为rpc，rpc框架的意义就是能忽略网络相关的细节，隐藏网络编程细节。</p><p>常见的框架有dubbo、sofa、grpc、brpc等，实现原理都差不多，但底层细节差异较大。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-6febb8e3bc31b9204e002749273bf32e.webp"></p><p>对于同一个事物，在使用的时候细节更重要，在学习时“设计方法”更重要，所以，看rpc的本质就好了，对于RPC核心工作是隐藏网络细节：</p><p>对于网络高效操作，最核心的就是编解码、网络链接处理，只要把这两点搞定了就问题不大； 对于隐藏，尽可能的提升易用性，减少声明、调用时的难度，符合大家的开发习惯就问题不大。</p><p>这里主要说网络相关的，一个rpc协议比较核心的通常是通信协议、编码协议、序列化格式，客户端对传输内容（数据+指令） 进行序列化、协议编码、网络传输到远程服务器端，服务端接受输入对传输内容进行解码、反序列化完成数据的逻辑计算，产生输出后，同样方式传递给客户端，完成整个RPC调用。</p><p>除此之外，一个RPC框架除实现RPC协议外，通常提供了负载均衡、容错机制、服务注册发现等附加功能：（这些功能并不是RPC所必需的）</p><p>在调用过程中，为了解决分布式环境下机器&amp;服务数量巨大&amp;状态繁多导致的难以管理的问题，RPC框架通常还集成了 “如何鉴别调用哪些机器，哪些机器是死是活” 的服务注册&amp;发现功能。对于分布式环境下必然存在的网络不稳定问题，提供了一定的容错机制。针对合理使用机器&amp;网络资源，保证各个机器的稳定程度，提供了一定的负载均衡功能。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>在通信协议方面，RPC跨越了传输层和应用层，像grpc 就直接基于http 2.0的协议、dubbo在tcp基础上研发的应用层传输协议。</p><h3 id="编码协议"><a href="#编码协议" class="headerlink" title="编码协议"></a>编码协议</h3><p>首先RPC协议是语言无关的，客户端的实现语言与服务端的实现语言可以是相同的也可以是不同的，在RPC调用时必然需要一种标准的编码协议来约定接口数据格式、处理传输内容的编码解码操作，具体要看框架的实现程度和支持。 后续会对业界常见的 基于文本编码的json、xml、基于二进制编码protobuf 为例进行介绍。</p><h3 id="举个例子，看看grpc-网络实现"><a href="#举个例子，看看grpc-网络实现" class="headerlink" title="举个例子，看看grpc 网络实现"></a>举个例子，看看grpc 网络实现</h3><p>GRPC 框架完全是基于HTTP2.0的，而http2.0相对于http1.x，编码格式是二进制的，相对于纯明文传输体积是要小的，并且http2.0是完全多路复用的，一个链接实现多http报文传输，链接利用率更高，并且解决了队头阻塞的问题，并且http2.0头部开销更小。 链接处理方面，GRPC基于边缘触发的epoll，将epoll的性能发挥到了极致，epoll的数据读取分为两种，边缘触发是缓冲区发生变化时就会通知读取，需要一次性读完，而水平触发是只要可读就会通知。边缘触发比起水平触发 通知次数更少，并要求一次性读完，性能更好，但可能存在数据丢失的情况，但是可解。</p><h3 id="1-4-2-5-epoll的使用-—-关于netty的小白常问"><a href="#1-4-2-5-epoll的使用-—-关于netty的小白常问" class="headerlink" title="1.4.2.5 epoll的使用 — 关于netty的小白常问"></a>1.4.2.5 epoll的使用 — 关于netty的小白常问</h3><p>问题一： 为什么需要netty，netty是对于Java网络相关库的一种补充，基于Java NIO实现，隐藏了部分网络编程的细节，netty写出来的程序，通常不会太差，让不擅长网络编程的同学能够网络编程。</p><p>可以看下大致的过程，注册channel就是注册文件描述符，loop中会调Selectors.select方法，对应就会在内核中调用epoll_wait函数，内部事件就是epoll维护的就绪队列，靠中断激活然后回调加入队列。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-09c6fb1320d226149c728b96a621fb29.webp"></p><p>要没有netty，你得自己实现这些东西，JDK还有bug…</p><p>落地实现有三种线程模型，单线程模式、多线程模式、主从reactor多线程，单线程是由一个线程完成链接读写和业务处理（跟单线程redis的处理模式很像）；多线程是reactor只负责链接读写，业务动作找到handler后提交到worker线程池处理；主reactor接受链接，分发给子reactor进行读写，然后业务动作由worker线程池处理。</p><p>这三种模式的差异主要是面临IO场景下：链接建立、IO读写、业务处理占比及成本情况。 一些RPC 框架通常是后两种，业务代价太高，如果读写也同样很大的话，可能就是第三种，区分版本&#x2F;配置查看，通常都支持。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-7b7f2affb1145a1a203064910175af18.webp"></p><p>问题二： 为什么同样的机器配置，tomcat比netty落地的rpc框架性能差这么多，首先不能这么比哈，一个是web 容器、一个是通信框架。</p><p>非得比的话，核心原因是tomcat的servlet规范，虽然网络处理性能在NIO之后就提上来了，但是完成链接处理后的tomcat，阻塞的业务处理模式下由于servlet规范依旧很差，除此之外，还有编码&#x2F;序列化协议的差异性，那为什么还用tomcat，因为稳定和替换代价。在多线程业务阻塞处理模型下，rpc框架的处理复杂度、协议跟tomcat一致了，性能其实差不多。</p><p>对啦，如果觉着当前同步模式下的编程方式性能差，试试reactive编程吧。</p><p>问题三： 为什么看上去proactor比reactor 性能更好呀，为什么大量的应用还是reactor啊，因为proactor写不明白呀，复杂度过高，还需要操作系统支持，linux支持的还不太好。不过，一些中间件还是适合用proactor的，给业务用的框架，还是乖乖reactor吧。</p><h3 id="看个完整的从入口到tomcat再到gRPC的调用demo"><a href="#看个完整的从入口到tomcat再到gRPC的调用demo" class="headerlink" title="看个完整的从入口到tomcat再到gRPC的调用demo"></a>看个完整的从入口到tomcat再到gRPC的调用demo</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-80745a795634ac151a30531e9ec5e559.webp"></p><h3 id="1-4-2-6-关于长链接"><a href="#1-4-2-6-关于长链接" class="headerlink" title="1.4.2.6 关于长链接"></a>1.4.2.6 关于长链接</h3><p>http长链接、tcp长链接，是一回事儿嘛，为什么要有长链接呢？keepalive是怎么保活的呢？</p><p>链接的建立是需要成本的，即时这个成本很小，很多场景下确无法忽略。端到端负载较小时还好，当负载很大时，同一个端不同请求链接建立的成本所带来的CPU成本就无法忽略了；当时延要求较高的场景，链接建立所带来的时间开销也无法忽略。</p><h3 id="TCP长链接"><a href="#TCP长链接" class="headerlink" title="TCP长链接"></a>TCP长链接</h3><p>http长链接是long-polling实现的，在应用层http请求中我们可以指定<code>“Connection: keep-alive”</code>开启长链接，当设置keepalive时，tcp链接就不会主动断开，并且启用 long-polling，保证链接存活。</p><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><p>首先HTTP 的keepalive保活和TCP的保活不是一回事儿，HTTP保活是为了不断开链接，而TCP保活是保证连接是正常存活的。</p><p>启用 TCP Keepalive的一端会启动一个计时器，当这个计时器数值到达0之后，一个 TCP 探测包便会被发出。这个 TCP 探测包是一个纯ACK包，其Seq号与上一个包是重复的，所以其实探测保活报文不在窗口控制范围内。</p><p>这么做主要是为了避免过多的半打开连接，因为当连接的任意一方崩溃时，这个链接就进入了半开状态，如果不探活，这类链接会越来越多。</p><p>很多时候为了让链接是活的，需要在应用层再挂一层保活机制，因为TCP默认的两小时活跃并不可靠，运营商经常会回收空闲链接。</p><h3 id="什么时候需要长链接"><a href="#什么时候需要长链接" class="headerlink" title="什么时候需要长链接"></a>什么时候需要长链接</h3><p>长链接的长期维护对Server端是具有较大开销的，常规的web应用短链足够了，但对于游戏场景时延要求极高&amp;大量同一端到端请求&amp;具有推送诉求、Server端服务和服务间的调用、mysql的调用就比较适合使用长链接了（将链接入池） 看个demo</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-23114aa49447bbd6697863ea62f2cc88.webp"></p><h3 id="1-4-3-到中间件了"><a href="#1-4-3-到中间件了" class="headerlink" title="1.4.3 到中间件了"></a>1.4.3 到中间件了</h3><p>请求从客户端启动，找到地址，发起请求，到达接入层入口，执行4层负载均衡，到达nginx Server，执行7层负载均衡，然后到达API Server，通过RPC client发起调用，到达RPC Server，然后在RPC Server间兜兜转转，有的逻辑访问了Redis，有的逻辑调用了mysql，接下来看下对于这些中间件是怎么调用的。</p><h3 id="1-4-3-1-redis调用"><a href="#1-4-3-1-redis调用" class="headerlink" title="1.4.3.1 redis调用"></a>1.4.3.1 redis调用</h3><p>常见的redis集群架构有两种，豌豆荚的codis模式、redis-cluster模式，两者的网络链路差异较大，业界比较常用的是codis模式。 codis模式透过proxy根据一致性Hash策略，到达对应的redis实例，而redis-cluster模式则有client直接到达redis实例。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-dcef236e6b61d08bc05bdcc82e0291d0.webp"></p><p>目前redis的版本已经有多线程模式了，将读写动作换做其他线程来执行了。</p><p>到达redis实例之后，单线程处理多链接，可以理解为近似netty的单线程模式，因为redis完全基于内存操作，成本极小，这种模式就够了。相关内容已经说过了，跟netty实现模式有一定的差异，可以参照redis-ae-epoll实现方式（server.c 主函数中initServer调用了aeCreateEventLoop、anetTcpServer、anetNonBlock来完成初始化）</p><h3 id="主从同步"><a href="#主从同步" class="headerlink" title="# 主从同步"></a># 主从同步</h3><p>redis在master操作完成后，会基于命令传播（AOF）将对应的命令写入从库。新挂从库时会基于RDB快照复制的方式写入从实例。 主从之间是通过长链接进行数据传输的，细节基本和前面描述的一致。</p><h3 id="1-4-3-2-mysql调用"><a href="#1-4-3-2-mysql调用" class="headerlink" title="1.4.3.2 mysql调用"></a>1.4.3.2 mysql调用</h3><p>同样的通过长链接先到接入层，mysql常用的有HAProxy（前面提到过），然后透过proxy跟mysql实例的长链接到达具体实例，执行对应的动作。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-f669dc195ed921fc7b2fdbaf6807efac.webp"></p><p>执行完成写入动作之后，通过binlog同步的方式完成主从同步，同步的方式是三种：同步、半同步、异步，业界的落地常用方式通常是半同步模式，根据超时时间来确定最终的同步方式，或强制指定，延迟就摘掉。根据不同的场景（数据一致性要求）选择不同的模式。但是这三种模式的通信都是依赖于长链接完成的。</p><p>如果你的mysql集群是多活部署的，通常还会有通过网络专线完成的跨地域数据同步，完成多主的数据同步。</p><h3 id="1-4-3-2-其他中间件"><a href="#1-4-3-2-其他中间件" class="headerlink" title="1.4.3.2 其他中间件"></a>1.4.3.2 其他中间件</h3><p>有一个共性，对于网络方面中间件为了追求效率通常是基于长链接、自定义应用层协议落地的。</p><h3 id="1-5-网络优化tips"><a href="#1-5-网络优化tips" class="headerlink" title="1.5 网络优化tips"></a>1.5 网络优化tips</h3><p>至此所有的处理都完成了，剩下的就是一层层的响应，完成返回了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1692359474-b4921a868468af31a018862640ede5b0.webp"></p><p>经过这么长的剖析，大家应该对网络链路有了一个相对清晰的感知，接下来看下对于网络的处理，我们日常有哪些优化操作。</p><p>1: 网络是一件开销较大的事儿，首先要做的是避免发生网络IO。 2: 如果一定会有IO链路产生，那就尽可能的剪短IO链路，比如说异步操作。 3: 如果网络操作无法避免，要节省网络中的动作，比如使用长链接、批处理，但长链接一定要因地制宜。 4: 使用高效的工具，别自己瞎整，netty、广泛使用的RPC框架，成熟的接入层等等。 5: 如果非要进行网络编程，合理利用epoll。 6: 从顶向下进行优化，优化到极致还不解决问题，再去动底层。 7: 别猜，代码都是人写的。</p><h3 id="2-写在最后"><a href="#2-写在最后" class="headerlink" title="2. 写在最后"></a>2. 写在最后</h3><p>网络是一件有趣且复杂的事情，只是一个普通的业务研发，没那么专业，文章中可能会有一些描述不准确或者错误的事情，如果说错了，恳请斧正。</p><p>研究网络的过程中，发现了较多的设计启发，比如DNS的架构模式、网络的多层处理、负载均衡的设计、reactor的模式、容灾设计、设计的出发点等等，对于技术本身的研究会带来较多的日常设计的启示，也希望大家读文章的时候能有对于网络之外的设计启发。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统+网络</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Serverless + Faas架构 创新试错快速起服务</title>
    <link href="/2023/08/10/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/Serverless-Faas%E6%9E%B6%E6%9E%84-%E5%88%9B%E6%96%B0%E8%AF%95%E9%94%99%E5%BF%AB%E9%80%9F%E8%B5%B7%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/08/10/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/Serverless-Faas%E6%9E%B6%E6%9E%84-%E5%88%9B%E6%96%B0%E8%AF%95%E9%94%99%E5%BF%AB%E9%80%9F%E8%B5%B7%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="就创新试错聊聊Serverless-Faas架构，赠送Groovy高性能规则引擎实践"><a href="#就创新试错聊聊Serverless-Faas架构，赠送Groovy高性能规则引擎实践" class="headerlink" title="就创新试错聊聊Serverless + Faas架构，赠送Groovy高性能规则引擎实践"></a>就创新试错聊聊Serverless + Faas架构，赠送Groovy高性能规则引擎实践</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>始前先看下整个文章的梗概：我会对于多变业务，比如“小步快跑”、“创新试错”下的业务开发模式和架构方案做出分析设计，最终推导出Faas + ServerLess架构，并就Java技术栈下，对于这种架构进行落地，实现基于自定义Groovy引擎的Faas+ServerLess架构下的“低代码”服务。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-ea0e1be06785f297a7e3163f1b034061.png"></p><h4 id="1-1-大体背景"><a href="#1-1-大体背景" class="headerlink" title="1.1 大体背景"></a>1.1 大体背景</h4><p>我由于是做营销活动相关的，日常经常会碰到一个场景：各种频出的创新的idea需要尝试，创新这件事儿意义很大。但是每个idea都去实践落地，成本又太高了，如果完全靠直觉和经验，很容易扼杀一些优秀的idea。</p><p>所以就开始尝试降低创新的成本，比如说之前一个活动30人日，我们能不能降低到3人日，看上去这是一个很夸张的成本节省数量，但是理论上是可行的。</p><h4 id="1-2-成本分析-–-需要提效"><a href="#1-2-成本分析-–-需要提效" class="headerlink" title="1.2 成本分析 – 需要提效"></a>1.2 成本分析 – 需要提效</h4><p>首先我们对于成本进行初步分析，一场活动的成本，大致分为：人力成本 + 活动预算 + 流量成本。</p><p>对于idea的创新实践，我们初期并不需要过大的活动预算和大规模的资源流量，通常在前几天就能把效果论证出来，定向推送特征用户就好了，有传播倾向的idea，可以用延迟发奖来解决，效果好了就增加预算，效果差，钱也花不出去。</p><p>所以剩下的，最核心的成本在于人力成本，人力成本可比大家想象的要重要的多，尤其是在这么个降本增效的大环境下，几十人日、几百人日的投入创新尝试是不现实的，所以我们要解决的关键性问题就是活动生产的效率问题。</p><p>不仅是活动方面，其实每个具有创新属性、小步试错属性的场景，都有着类似的问题。</p><h4 id="1-2-其他推荐"><a href="#1-2-其他推荐" class="headerlink" title="1.2 其他推荐"></a>1.2 其他推荐</h4><p>前面有几篇文章已经提到过大致的方法论和初步的实践思路了，有兴趣也可以前置的读一下，不过不读也不耽误本篇的阅读，部分内容是有一些重复的。</p><p><a href="http://www.zouzhiquan.com/%e6%8b%92%e7%bb%9d%e6%8d%a2%e7%9a%ae%e7%a7%91%e6%8a%80-%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8%e6%8f%90%e6%95%88%e4%b9%8b%e9%81%93/">营销活动提效之道</a></p><p><a href="http://www.zouzhiquan.com/%e4%b8%9a%e5%8a%a1%e5%bc%80%e5%8f%91%e9%93%b6%e5%bc%b9-%e4%bd%8e%e4%bb%a3%e7%a0%81%e5%b9%b3%e5%8f%b0%e5%bb%ba%e8%ae%be%ef%bc%88%e4%bd%8e%e7%a0%81%e7%b2%be%e5%8d%8e%e7%af%87/">业务开发“银弹” – 低代码平台建设</a></p><p>接下来进入正题，如何解决这种创新类、小步试错的“轻业务”。</p><h2 id="2-可以有的思路，一通分析"><a href="#2-可以有的思路，一通分析" class="headerlink" title="2. 可以有的思路，一通分析"></a>2. 可以有的思路，一通分析</h2><p>要想节省成本，有两个思路：减少工作量、提升落地效率。</p><p>事情得做，还得做作，需求不能砍，所以剩下的方法只有复用；提升落地效率，这个prd效率、前后端研发效率、测试效率每一个方面其实都可以去节省。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-71066be05cb192181ca2caf47ea78eb4.png"></p><p>我们就idea的落地流程，进行细节上的分析，看看如何来提升效率。</p><h3 id="2-1-落地分析"><a href="#2-1-落地分析" class="headerlink" title="2.1 落地分析"></a>2.1 落地分析</h3><p>首先就整个流程进行分析，减少繁琐的流程，少一点大公司病，多一些创业状态，高生产效率的节奏下，快速idea落地体验，沟通对齐，是整体的目标。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-d15af6d2458a16a7ef421a33f19968e8.png"></p><p>做事前，先看最佳实践，一种好的、理想的方式是“我只关心本次创新的部分，也只需要执行本次创新的部分”</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-910e818f953c799f3c087172a8797728.png"></p><p>具体举措：<br>1: 要有机制能够保障只需要开发创新点，并且高效的开发创新点。<br>2: 影响能够隔离，只影响当前的创新尝试（测试范围），不影响其他任意功能或业务。<br>3: 线上无运维成本，即写即跑，不用申请存储、不用配nginx、不用起机群、不用部署上线，就小成本快速出个看板，关注具体效果就好。<br>4: 开发体验上，热更热部，0等待成本，大脑无线程间切换，快速心流模式。<br>5: 很轻松的就能复用，少量的复用适配成本。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-6fa24d5e96192e385abb45d4a0b26f2b.png"></p><h3 id="2-1-落地分析，我能想到的方案"><a href="#2-1-落地分析，我能想到的方案" class="headerlink" title="2.1 落地分析，我能想到的方案"></a>2.1 落地分析，我能想到的方案</h3><h3 id="2-1-1-开发过程"><a href="#2-1-1-开发过程" class="headerlink" title="2.1.1 开发过程"></a>2.1.1 开发过程</h3><p>根据上面的最小实现原则，我们不妨对于开发一个功能所涉及的工作进行分析，就拿营销活动来看，我们能想象这么几种方案:</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-75ba0979896ad565c8c93268ba466f1a.png"></p><ul><li>基于已有的逻辑做if-else变更<br>我们使用现有的活动做变更，支持给活动增加活动id之类的概念，用于区分不同的逻辑，在原有的逻辑上做新增，然后适配兼容。</li></ul><p>这种模式就本次开发和之后的维护成本来说都是最高的，可能改起来最不费劲，加一点代码就解决了，但兼容逻辑、废弃逻辑会越来越多。我们业务上的屎山通常就是这样出现的。</p><p>而且对于单次活动的开发，影响面也没有控制住，可能会对既有逻辑产生一定的影响。</p><p>这个方案基本上可以否了。</p><ul><li>完全纯新写<br>新起一组逻辑，完全用来支持当前的创新活动，与现有逻辑完全隔离，最小原则实现，和原有的逻辑完全做了隔离，这是业务发展初期、系统重构常用的思路，在成本不高的时候，是可行的。</li></ul><p>但是如果逻辑相对复杂，创新idea的成本是没有减少的，所以这个方案也暂时先否了。</p><ul><li>基于复制逻辑<br>copyOnWrite，把当前的代码做一份复制，在复制出来的代码上做修改，与现有逻辑变相隔离，不用适配老逻辑，直接做新增修改即可。</li></ul><p>这样是不是就做到了，即跟既有逻辑隔离，又减少了重复开发。但是现实是我们的活动开发并没有那么轻松就可以复制，整个的复制成本也会很高，除此之外，老逻辑修改至逻辑的成本还是太高，需要对老逻辑非常熟悉才行。</p><p>要是有一种方式，能够一键复制就好了，比如就一个脚本，直接copy？这个思路没准能行。</p><ul><li>基于沉淀复用 + 纯新写组装逻辑<br>我们去沉淀大量的工具，在创新idea到来时，利用工具集去构建新的活动，由于沉淀的这部分是稳定的，变的通常是组合逻辑，是可行的。</li></ul><p>但是组装逻辑也相对庞大，能不能再省省。</p><p>小朋友才做选择，大朋友选择都要，我们想要的已经清晰了：快捷复制 + 纯新部分新写 + 沉淀功能集</p><h3 id="2-1-2-调试过程"><a href="#2-1-2-调试过程" class="headerlink" title="2.1.2 调试过程"></a>2.1.2 调试过程</h3><p>还记得写php和python的爽感嘛，语法精炼，热更热部。那能不能对于这种创新idea我们也采用这个技术栈，当然是可行的。想要提效，热更热部是必须的。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-3375d44f21e922afb6fc989f0522dbc7.png"></p><p>但是通常这个方式会收到各方面的制约，比如说技术栈不统一的问题，由于生态的原因，不得不否认Java是最主流的业务工程开发语言。并且对于活动场景来看性能要求是比较高的，php、python的性能说实话，还是差了一些的。</p><p>我们需要一种模式提供热更热部，并且执行效率至少跟Java差不多，能兼容现有的功能集合语言上无缝兼容（如果调一个功能就来次rpc，成本太高了），顺道还能有Java的巨大生态便利。</p><p>肯定有人杠，Java也能热更热部，我是觉着真的够难用，而且跟这种天然热的脚本类语言完全不是一个概念。</p><h3 id="2-1-3-运维成本"><a href="#2-1-3-运维成本" class="headerlink" title="2.1.3 运维成本"></a>2.1.3 运维成本</h3><p>开发、调试完成、测试完成之后，下一步就是线上运维了，传统的开发模式，研发对于线上的机器资源、存储资源、中间件资源等感知太多了，但就一个上线过程就要耗费掉一天的时间，并且为了安全还要使用各种手段，一台台机器去灰，还要感知nginx、DB等中间件服务，需要时还得有各种前置工作。</p><p>那能不能无需感知这些对于线上应用即写即跑，背后的资源毫不关心，让研发看不到“机器”，管控该做做，灰度就用流量灰。</p><h3 id="2-2-Faas-ServerLess"><a href="#2-2-Faas-ServerLess" class="headerlink" title="2.2 Faas + ServerLess"></a>2.2 Faas + ServerLess</h3><p>把上面的方式总结下来看：</p><ul><li>开发过程<ul><li>快速复制</li><li>稳定的功能集合</li></ul></li><li>调试过程<ul><li>即写即跑，热更热部</li></ul></li><li>运维过程<ul><li>不感知服务器</li></ul></li></ul><p>总结下来这不就是Faas和 ServerLess架构嘛（面向的沉淀好的稳定功能集合，进行脚本化编程）。我们只需要给我们的系统，增加能执行创新idea的容器就好了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-4035a89aee38df1b4c2ac0df3c0ce5c9.png"></p><p>用脚步写几个基础活动模版，然后实例化一个模版（复制一个出来），把创新的玩法在里面加进去，编写创新玩法时，使用我们沉淀好的功能集合，发布时就点一下，然后自动构建接口，自动识别存储。需要灰度就拿流量整个白名单推全，然后在整个脚本的版本系统，是不是问题就都解了。</p><p>整体的方案就是这么简单，但是我们需要解决落地过程中的 **<code>Java兼容性问题</code>、<code>脚本对于功能库的识别</code>、<code>高效复用问题</code>、<code>脚本执行性能问题</code>、<code>服务稳定性问题</code>**，下面就具体来看，是怎么落地的。</p><p>业界并没有一种完美的解决方案能把上面的几个问题妥善解决掉，在整个落地过程中做了较多的自主优化。</p><h2 id="3-基于Groovy引擎的优化落地"><a href="#3-基于Groovy引擎的优化落地" class="headerlink" title="3. 基于Groovy引擎的优化落地"></a>3. 基于Groovy引擎的优化落地</h2><p>直接看下我们要落地的应用：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-d321c1ded68cc446e2a395240d931ae5.png"></p><h2 id="3-1-Java-兼容性问题"><a href="#3-1-Java-兼容性问题" class="headerlink" title="3.1 Java 兼容性问题"></a>3.1 Java 兼容性问题</h2><p>这里就拿业界最常用的Java技术栈来看落地，其他场景可能技术选型不同，但是思路是一致的。</p><p>Groovy算是Java生态中最常用的语言了，纯粹的groovy语法十分精炼。并且与Java环境高度兼容，甚至可以直接在groovy脚本中写Java代码。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-323bbd67555a247a3dd3e54f732a8428.png"></p><p>在国内Groovy 最常用的场景是写单测脚本、写离线数据脚本等等，很大的原因就是跟Java兼容性极高，并且编写效率极高，对于Java开发同学没有成本。</p><p>但是Groovy脚本性能是比较差的，测试来看比Java性能得低一个数量级，无论是用哪种执行方式，这个是脚本执行的通病，但是如果把性能问题解决了，Groovy脚本是不是就很香了。</p><h2 id="3-2-脚本执行性能问题"><a href="#3-2-脚本执行性能问题" class="headerlink" title="3.2 脚本执行性能问题"></a>3.2 脚本执行性能问题</h2><p>Java环境中使用groovy脚本有这么几种模式：GroovyShell执行、GroovyClassLoader、GroovyScriptEngine 三种方式去执行脚本。这三种模式都是类似的，性能都比较差。</p><h3 id="3-2-1-执行原理"><a href="#3-2-1-执行原理" class="headerlink" title="3.2.1 执行原理"></a>3.2.1 执行原理</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-fdb1c74baebbeabf713d075c19d2812c.png"></p><ul><li>GroovyShell<br>GroovyShell 适用于执行片段脚本，具体执行过程，可以理解为把代码片段放到一个静态方法里，然后invokeStatic，然后完成处理。</li></ul><p>每次都要进行新groovy 脚本的拼接，然后编译成对应的class文件，然后再newInstance构建一个对象，然后向下转为GroovyObject，然后调用invokeStatic。</p><p>整个拼接、编译、反射调用都是非常耗时的，然后次次编译产生大量的类，短时的方法区占用比较多。</p><ul><li>GroovyClassloader<br>GroovyClassloader 可以选择groovy文件进行编译，然后夹在对应的class文件，使用的方式也是newInstance对象，用GroovyObject中的invokeMethod方法，调用的是MetaClass中的invokeMethod方法，最底层就是lang.reflect，性能也比较差。</li></ul><p>相对于Groovy少了拼接、编译的过程，我们可以根据需要缓存对应的实例，每次的主要成本就是反射调用成本。</p><ul><li>GroovyScriptEngine<br>这东西就是在groovyClass、GroovyShell上封装了一下，可以指定url去进行当前目录的脚本访问，并且提供了缓存机制，能自主发现文件更新（检查md5），提供了使用上的便利性。</li></ul><p>但是这些便利性还不如不提供，反而引入了OOM风险，方法区不会进行卸载，然后每次变更会生成一个全新的class。并且性能方面虽然提供了缓存，但是反射调用的问题依旧无解，性能还是比较差</p><h3 id="3-2-2-基础信息供给"><a href="#3-2-2-基础信息供给" class="headerlink" title="3.2.2 基础信息供给"></a>3.2.2 基础信息供给</h3><p>回忆点基础，设计过程需要大量的类加载、反射等相关知识。</p><p>一个class对象的唯一标示是：类加载器 + 类全限定名称。</p><p>一个class文件被装载后在方法区生成class对象（启动时），这个对象在整个运行过程中是无法被替换的，像重新加载要么换名字，要么换类加载器，要么改JVM（这个侵入性太大）。</p><p>Java的类加载委派模型，最上层是bootstrap、然后是Extension、在是application，然后加载时会层层向上委派，主要是解决同一个类不同加载器问题。</p><p>由于上面的实现，父类加载器加载的类，是没办法访问子类加载器加载的类的，这个隔离是在class文件装载时进行校验的。</p><p>反射定义 是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法;对于任意一个对象,都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p><p>有了前置的这部分信息，我们开始进行分析设计。</p><h3 id="3-2-3-自定义引擎"><a href="#3-2-3-自定义引擎" class="headerlink" title="3.2.3 自定义引擎"></a>3.2.3 自定义引擎</h3><p>针对性能差的问题，我是做了对应的自定义实现，反正就是个编译 + 装载的过程。并且除性能以外，我需要对于整个过程都完全可控。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-49658d8474080f373cc6866a3593b2e7.png"></p><p>首先使用CompilerConfiguration进行脚本编译控制，编译成对应的class文件。（这里可以让编译过程可控）</p><p>然后自定义classloader进行装载（只需要一个单纯的class文件，只需要一个装载功能，并且需要整个过程完全可控）</p><p>然后ASM 进行对应目标class的代理类生成（ReflectASM），生成新的class：*****MethodAccess，然后再用代理类完成Groovy 脚本内方法反射调用（由于直接定位到方法调用，本质就是直接调用）。</p><p>过程按照一定的策略缓存对应的代理对象，来避免次次编译、创建代理。</p><p>这样使用grovvy的时候，就跟使用本地方法一致了。</p><p>ps： 为什么ReflectASM比Java原生的反射快，而ASMReflect比直接调用性能差在哪，为什么能得到JIT的优化，下面尝试分析。</p><ul><li>直接调用<br>前置动作：java 代码 -&gt; 字节码 -&gt; class load</li></ul><p>执行时：根据加载好的类信息找到对应的方法引用，去执行就好</p><ul><li>Java 原生反射<br>前置动作：java 代码 -&gt; 字节码 -&gt; class load</li></ul><p>提前缓存：获取class信息 -&gt; 获取对应Method</p><p>执行过程：检查系统状态和参数可以执行这个方法 -&gt; 和正常JVM执行方法一样执行这个方法</p><ul><li>ReflectASM 反射<br>前置动作：java 代码 -&gt; 字节码 -&gt; class load</li></ul><p>提前缓存：获取class信息 -&gt; 生成XXXXXXXMethodAccess类 -&gt; 完成新类load</p><p>执行过程：使用向上转型后的代理对象（MethodAccess容器加载可识别）-&gt; 调用invoke方法 -&gt; 然后会走到具体的实现类（继承自MethodAccess）-&gt; 然后代理内部将脚本对象强转为对应的脚本对象 -&gt; 根据名称（for-each）或者方法序号（switch-case） 对于脚本对象的方法进行直接调用。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-089321151cb11b84e2213f4677c3e52d.png"></p><p>ReflectASM进行调用比直接调用就多了两层栈、一层for-each或者switch-case，性能近似相同。</p><p>ReflectASM相对于原生JDK的反射，基本相当于直接调用和反射调用的差异，少了参数和状态检查的过程，并且能得到JIT的优化。</p><p>ReflectASM能被JIT优化到，完全是因为这种模式本质上就是直接调用。</p><p>看上去父类加载器访问了子类加载器加载的类，其实没有，装载过程都是没有任何问题的，这里就是利用了向上转型，编写时使用父类进行子类访问，然后再层层向上使用。</p><h3 id="3-2-3-编译优化-–-内部函数链路优化"><a href="#3-2-3-编译优化-–-内部函数链路优化" class="headerlink" title="3.2.3 编译优化 – 内部函数链路优化"></a>3.2.3 编译优化 – 内部函数链路优化</h3><p>重写完引擎之后，发现性能还是差一些，然后一边压测一遍看了下对应火焰图，发现调用栈里多了一些我不认识的东西。并不是常规的函数调用栈。</p><p>这里的问题是因为Groovy的动态性，grovvy编译后的class对象都默认实现了groovy.lang.GroovyObject（可以尝试反编译上面的class文件看看哈），里面有一个MetaClass持有了整个类的元信息，方法路由就是通过MetaClass来进行方法寻找的，可以用这个机制完成在运行时完成属性和方法的添加。（底层调用其实就是反射，只不过让反射的使用变简单了），具体可以去看下官方文档哈。</p><p>这个动态性使性能大幅度下降，这时候我们就需要把这个特性给关掉：@CompileStatic 就行。</p><p>ps-1: 外层依然有必要进行动态代理，没有其他的入口，防止JIT中断。</p><p>ps-2: 很多时候JIT 去优化就是因为反射，具体可以看下对应的JIT 日志，-XX:+PrintCompilation -XX:+CITime</p><h3 id="3-2-4-服务预热优化"><a href="#3-2-4-服务预热优化" class="headerlink" title="3.2.4 服务预热优化"></a>3.2.4 服务预热优化</h3><p>我们日常的服务在启动时都会有预热动作，让服务的刚开始的请求都能以正常的性能来提供。但是容器化之后，新脚本的预热是缺失的。</p><p>预热缺失在除了会导致部分请求的平响增加，在流量极大的情况下是非常危险的，预热产生的开销和链接夯死有极大的概率导致服务奔溃，这里可以参照<a href="http://www.zouzhiquan.com/%e6%9e%b6%e6%9e%84%e8%a7%86%e8%a7%92%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96/">《架构视角的性能优化》</a></p><p>一个脚本中需要预热的是：client（初始化）、函数（实例化）、自身代码，核心重开销的是client、函数，自身代码的JIT热度其实还好。</p><p>这里可以给脚本的下发过程做一点处理，提供预热入口，编写脚本时就能保证脚本是热的。这样可以根据脚本的内部逻辑进行针对性的预热，但是这样相对麻烦，我们需要感知发布逻辑，并且每次需要新增代码，不够优雅。</p><p>最佳的方式是，服务启动时保证脚本中用到的函数、client这些都是热的，剩下的只有脚本逻辑了，这部分本质上的性能损耗非常少了，基本可以忽略不计。如果想要极致的优化方式，可以使用AOT编译，强制静态编译，这部分内容未曾实践落地，就不说了。</p><h2 id="3-3-如何识别功能函数库"><a href="#3-3-如何识别功能函数库" class="headerlink" title="3.3 如何识别功能函数库"></a>3.3 如何识别功能函数库</h2><p>我们基于Faas落地组装逻辑，如果在开发过程中、运行过程中识别函数库呢。</p><p>首先功能函数库，可以有两种落地形式，标准的服务（有状态函数）或工具服务（无状态函数），就使用场景来看有状态函数是我们最常用的，比如说库存、机会、计数、榜单这些，工具函数比如概率、规则引擎、决策服务等等。</p><h3 id="3-3-1-编译时-–-SDK引入"><a href="#3-3-1-编译时-–-SDK引入" class="headerlink" title="3.3.1 编译时 – SDK引入"></a>3.3.1 编译时 – SDK引入</h3><h4 id="3-3-1-1-服务引入"><a href="#3-3-1-1-服务引入" class="headerlink" title="3.3.1.1 服务引入"></a>3.3.1.1 服务引入</h4><p>对于开发过程，由于是脚本 + 面向接口编程，可以直接利用类似于SPI的实现机制，引入一个SDK，只感知具体的接口，这个接口怎么实现、有哪些实现就由容器和运行环境来决定。</p><h4 id="3-3-1-2-自定义函数库"><a href="#3-3-1-2-自定义函数库" class="headerlink" title="3.3.1.2 自定义函数库"></a>3.3.1.2 自定义函数库</h4><p>除了上面的这种方式，可以直接跳过接口，直接自己导入沉淀好的工具库，比如一个Jar包，里面包含了自身的业务功能函数等等。</p><h4 id="3-3-1-3-RPC接入"><a href="#3-3-1-3-RPC接入" class="headerlink" title="3.3.1.3 RPC接入"></a>3.3.1.3 RPC接入</h4><p>可以向在Java开发一样，直接在脚本里使用其他的RPC服务，只需要包装个类似于ClientFactory就可以啦。</p><h3 id="3-3-2-运行时-–-类加载模型扩展"><a href="#3-3-2-运行时-–-类加载模型扩展" class="headerlink" title="3.3.2 运行时 – 类加载模型扩展"></a>3.3.2 运行时 – 类加载模型扩展</h3><p>上面提到的都是各种开发时的引用方式，但是运行时怎么保证你的脚本们正常加载到对应的函数、容器又是怎么执行你的脚本呢。</p><p>我们spring中的包是在application这一层所加载的，相当于容器的信息是application加载的。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-692b9a971724051ca727173205dca7a1.png"></p><h4 id="3-3-2-1-脚本识别"><a href="#3-3-2-1-脚本识别" class="headerlink" title="3.3.2.1 脚本识别"></a>3.3.2.1 脚本识别</h4><p>而脚本是子类加载器所加载的，我们想要访问，只能通过反射。（容器不感知脚本也非常的合理），所以就直接反射调用了。</p><p>不过这里绕了一层，直接通过ASM生成字节码文件，做了层代理，生成代理类之后，使用被代理类的加载器（脚本类加载器）作为父类加载器构建一个子类加载器，然后代理类通过子类加载器进行装载，最终会委派至父类加载器装载，也就是脚本类加载器装载。</p><p>具体可以看看，com.esotericsoftware.reflectasm.AccessClassLoader#get，逻辑不复杂。</p><p><code>ps: 调用过程可以认定是反射调用，但性能是直接调用</code></p><h4 id="3-3-2-2-脚本访问容器"><a href="#3-3-2-2-脚本访问容器" class="headerlink" title="3.3.2.2 脚本访问容器"></a>3.3.2.2 脚本访问容器</h4><p>而脚本中想要访问存放于容器中的接口畅通无阻。</p><h4 id="3-3-2-3-脚本访问函数库"><a href="#3-3-2-3-脚本访问函数库" class="headerlink" title="3.3.2.3 脚本访问函数库"></a>3.3.2.3 脚本访问函数库</h4><p>然后再把自定义函数库加进去，只需要指定函数库Jar类加载器的父类加载器是application就好，然后再指定脚本的父类加载器是函数库Jar类加载器即可。</p><p>这样就做到了，脚本中能够正常访问容器中的能力，又能访问函数库中的资源，同时容器能够正常访问对应的脚本资源。</p><h3 id="3-3-3-整体来看"><a href="#3-3-3-整体来看" class="headerlink" title="3.3.3 整体来看"></a>3.3.3 整体来看</h3><p>整体盘下来，类加载视图长这样：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-3d610ec3f72958abdaeaa595dc68f8f8.png"></p><p>整体的调用链路长这样：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-699fd31929205e8f3adf45964a76facf.png"></p><h2 id="3-4-服务稳定性问题"><a href="#3-4-服务稳定性问题" class="headerlink" title="3.4 服务稳定性问题"></a>3.4 服务稳定性问题</h2><p>解决完性能、兼容性、函数库识别之后，下一个问题是稳定性问题，要求其实很清晰，隔离性 + 故障屏蔽</p><h3 id="3-4-1-隔离问题"><a href="#3-4-1-隔离问题" class="headerlink" title="3.4.1 隔离问题"></a>3.4.1 隔离问题</h3><p>脚本之间不能互相影响、不同业务的脚本之间不应该出现资源抢占的情况。</p><p>首先脚本之间在上面说的那种模式落地之后，隔离逻辑非常好做，只要把整个脚本try掉就好了，无论任何错误不能导致影响容器运行。</p><p>然后业务之间的脚本是互相隔离的，在一个资源上只能加载一个业务的脚本，或者只能加载其中一个脚本，必要时一个集群仅运行一个脚本也是十分有必要的，选择不同的套餐就好了。</p><p>并且应该对于单个脚本进行逻辑隔离的治理，比如说这个脚本能使用多少存储、能用多少机器、最大多少流量，只需要在存储选择层面做合适的集群转发、流量入口处做限流、分发至不同的集群即可。</p><h3 id="3-4-2-故障屏蔽"><a href="#3-4-2-故障屏蔽" class="headerlink" title="3.4.2 故障屏蔽"></a>3.4.2 故障屏蔽</h3><p>当一个脚本存在技术上的问题时，是不应该被发布成功的，在新脚本错误期应该保持当前可用脚本对外提供服务。并且在错误期间应该持续性报警，并且脚本发布流程夯住的。实现模式就是经典的上线单发布流程。</p><p>对于业务性问题，我们是无法立即感知的，我们需要提供灰度过程，实现白名单用户、特征用户访问新的脚本，实现脚本的影响范围控制，如果小流量存在问题时，应该要有故障恢复能力。</p><h3 id="3-4-3-故障恢复"><a href="#3-4-3-故障恢复" class="headerlink" title="3.4.3 故障恢复"></a>3.4.3 故障恢复</h3><p>提供脚本的快速回滚机制、脚本下线机制，在出现问题时能够快速的恢复。</p><h2 id="3-5-复用的效率分析"><a href="#3-5-复用的效率分析" class="headerlink" title="3.5 复用的效率分析"></a>3.5 复用的效率分析</h2><p>可以参照我之前的文章<a href="http://www.zouzhiquan.com/%e6%8b%92%e7%bb%9d%e6%8d%a2%e7%9a%ae%e7%a7%91%e6%8a%80-%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8%e6%8f%90%e6%95%88%e4%b9%8b%e9%81%93/">营销活动提效之道</a>，这部分内容为节选篇章，原理都是一致的。</p><h3 id="3-5-1-颗粒度问题"><a href="#3-5-1-颗粒度问题" class="headerlink" title="3.5.1 颗粒度问题"></a>3.5.1 颗粒度问题</h3><p>通常来说复用机会和颗粒度大致呈负相关的关系，颗粒度越大，能够复用的机会就越小，颗粒度越小，能够复用的机会往往越大。</p><p>拿一个活动来说，从大颗粒到小颗粒，可以大致分为活动、玩法、有状态函数、无状态函数、库函数。</p><p>颗粒度越大成本节省越多，但是复用机会较小，颗粒度越小能够节省的成本越小，但是复用机会较大。就实践而言，单就成本节省带来的提效是有一个最优点的，这个点往往是有状态函数和玩法。那么我们复用的粒度基本就是围绕这个展开的。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-5156de5385b50865218162f93ddbc07d.png"></p><p>一场活动原封不动的直接复用几乎是不可能的，至少得换个皮吧，玩法复用机会明显大了很多，比如说抽奖、任务、签到等玩法复用，组成玩法的有状态函数复用机会就更大了，比如说机会、代币账务、库存、计数等等，再就是无状态函数，最后拆解到库函数，所有编程行为都是在这之上发生的，几乎完全复用。</p><h3 id="3-5-2-创新限制问题"><a href="#3-5-2-创新限制问题" class="headerlink" title="3.5.2 创新限制问题"></a>3.5.2 创新限制问题</h3><p>衡量出成本节省之后，我们不能单单按照这个进行执行，我们应该加入整个复用方案对于活动创新上的限制的影响。颗粒度越小对于创新时的限制是越小的，所以尽可能围绕最优的复用粒度偏向小粒度。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-1b54f09237240bfd1c6a2fc11b7fa8a2.png"></p><p>就实践而言，颗粒度到达有状态功能函数之后，就基本没啥限制了，所以最佳的复用粒度往往就是这个。</p><h3 id="3-5-2-善用组合拳"><a href="#3-5-2-善用组合拳" class="headerlink" title="3.5.2 善用组合拳"></a>3.5.2 善用组合拳</h3><p>前面一直在提创新的重要性，我们要做的是对于创新的提效。但是一场活动完完全全是创新玩法几乎是不可能，甚至完全全新的玩法对于用户并没有那么友好，通常是一个创新玩法带几个习惯玩法，这样才能做到让活动既陌生又熟悉，用户的体验才是最佳的。业界也基本都是这么实践的。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-c85c0036f69f2b8c79fc5184926fadae.png"></p><p>同时固有玩法的沉淀一样重要，这就要求我们的系统几个方向都得做，快速的玩法复用、快速的玩法变形、快速的创新玩法建设。</p><h2 id="3-6-看下整体的逻辑视图"><a href="#3-6-看下整体的逻辑视图" class="headerlink" title="3.6 看下整体的逻辑视图"></a>3.6 看下整体的逻辑视图</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-2752b2bf22b6efc2db232ef84aeb9e73.png"></p><h2 id="4-一点启示"><a href="#4-一点启示" class="headerlink" title="4. 一点启示"></a>4. 一点启示</h2><h3 id="4-1-两万个配置问题"><a href="#4-1-两万个配置问题" class="headerlink" title="4.1 两万个配置问题"></a>4.1 两万个配置问题</h3><p>经常我们的会为了逻辑上的灵活性，增加很多的配置，曾经见过一些相对极端的代码，100行代码里10个配置项，如果发展到这样就没有必要了。</p><p>零散配置维护带来的成本远比灵活性带来的收益要大，ROI完全打不正。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-522e1c83ef428c3228668e8e82512232.png"></p><p>这时候不如直接用整块代码的“规则引擎”解决问题，一块代码完成整体的决策，每次改动时还可以兼顾到整体的决策逻辑。</p><h3 id="4-2-关于变化的收敛"><a href="#4-2-关于变化的收敛" class="headerlink" title="4.2 关于变化的收敛"></a>4.2 关于变化的收敛</h3><p>我们在进行代码编写时，如果想让代码稳定可维护（架构的可扩展性、灵活度方面），最重要的就是通过各类变化的收敛，让影响范围可控，让整个的架构变得清晰，让整个代码结构变得清晰。</p><p>而变化可以大致分为这么几类：功能繁多&amp;耦合过重导致牵一发动全身、易变的串联关系、易变的组合关系、易变的单元逻辑、新增的单元逻辑。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-69d475fb9c2e2a988a144f0fafe7d0f0.png"></p><p>导致我们修改代码的都是业务功能上的变化，可以从业务功能上进行探索，最佳的实践是：<strong>“化整为零，分而治之”，对于易变单元 “切分易变逻辑，使用<code>中间件</code>收敛和控制变化”</strong>，具体来看</p><ul><li>对于<code>功能繁多&amp;耦合过重导致牵一发动全身</code>，我们可以在最上层做处理，拆分独立的服务（比如按照领域拆分），将各域的变化收敛到域内，不影响整体系统的变更。</li><li>对于<code>易变的串联关系</code>，可以借鉴观察者模式，实现发布订阅等能力，完成整体的逻辑串联（落地形式可以是 基于总线的同步触发机制、又或者基于消息的异步触发机制），而不是硬编码来完成逻辑的串联。</li><li>对于<code>易变的组合关系</code>，可以采用本文所说的这种模式，快速拼接现有的功能组成对外服务，而不是次次硬编码。</li><li>对于<code>新增单元逻辑</code>，我们可以使用策略模式，完成单元逻辑的收敛，把新增的成本给解决掉。</li><li>对于<code>易变的单元逻辑</code>，通常是由于业务逻辑多变引发的，最佳的就是拆分业务决策逻辑、代码决策逻辑，然后把代码抽象为执行模版，复杂的业务计算交给规则引擎。比如金额计算、过滤规则等等，还比如策略模式中的计算策略。</li></ul><p>之前描述的，<a href="http://www.zouzhiquan.com/%e6%90%9e%e5%ae%9a%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8-%e6%b4%bb%e5%8a%a8%e6%b5%81%e7%a8%8b%e7%bc%96%e6%8e%92%ef%bc%88%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%80%9d%e8%b7%af%ef%bc%89/">事件总线-流程编排</a>、<a href="http://www.zouzhiquan.com/%e6%90%9e%e5%ae%9a%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8-%e7%94%a8%e6%88%b7%e4%ba%a4%e4%ba%92%e6%80%bb%e7%ba%bf/">交互总线</a>、<a href="http://www.zouzhiquan.com/%e6%90%9e%e5%ae%9a%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8-%e8%b0%88%e4%b8%80%e8%b0%88%e8%a7%84%e5%88%99%e5%bc%95%e6%93%8e%e5%9c%a8%e6%b4%bb%e5%8a%a8%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e8%90%bd%e5%9c%b0/">规则引擎</a>、<a href="http://www.zouzhiquan.com/%e6%90%9e%e5%ae%9a%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8-%e5%a6%82%e4%bd%95%e4%bb%8e%e5%ae%b9%e7%9a%84%e5%ba%94%e5%af%b9%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8%e5%a5%96%e5%8a%b1%e5%8f%91%e6%94%be/">通用奖励服务</a>、<a href="http://www.zouzhiquan.com/%e6%90%9e%e5%ae%9a%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8-%e8%90%a5%e9%94%80%e6%b4%bb%e5%8a%a8%e4%b8%ad%e7%9a%84%e4%bb%a3%e5%b8%81%e6%9c%8d%e5%8a%a1/">代币账务</a>等，都是按照这个思路实践的，有兴趣可以看下。</p><h3 id="4-3-创新的吞吐量-–-题外话"><a href="#4-3-创新的吞吐量-–-题外话" class="headerlink" title="4.3 创新的吞吐量 – 题外话"></a>4.3 创新的吞吐量 – 题外话</h3><p>说句题外话，从流程上来看，从idea提出到完整性够键、再到prd产出、研发开发、测试、线上运行，这几个阶段是否可并性，常规来说是不可行的，prd未产出细节可能会出现大量的变动，导致研发返工，研发阶段测试提前介入，会导致测试工作重复等。但是在成本极小的情况，这种模式是有落地可能性的，尤其是创新场景，直接研发写个demo上去也不是不行。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-d5199fe29692d30a4eac744493fa0a7f.png"></p><p>一定程度的并发，虽然整体工作量稍微增加，但是因为排期变短，整体的吞吐量是上升了的。</p><h3 id="4-4-性能的优化"><a href="#4-4-性能的优化" class="headerlink" title="4.4 性能的优化"></a>4.4 性能的优化</h3><p>整个落地过程碰到了许多问题，允许我感慨下，代码都是人写的，所有的软件层面的引发的性能问题，都是可解的，只不过选择性能时我们需要牺牲一些东西，比如Groovy的动态性、比如空间换时间等等。</p><p>考量性能最关键的指标就是，有效吞吐量、响应时间，基于这两个做综合判断，往往能达到性能优化的最佳状态。</p><p>不要一堆问题混起来考量，分成单元问题逐个击破，就简单很多了。</p><p>有兴趣可以读一下<a href="http://www.zouzhiquan.com/%e6%9e%b6%e6%9e%84%e8%a7%86%e8%a7%92%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96/">架构视角的性能优化</a></p><h3 id="4-5-易用性和灵活性"><a href="#4-5-易用性和灵活性" class="headerlink" title="4.5 易用性和灵活性"></a>4.5 易用性和灵活性</h3><p>每次做中间件或者工具设计时都会发现，易用性和灵活性天然是冲突的，易用和简单基本可以划等号，但是简单基本意味着变化可能性小，灵活性好不了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691654141-f7273a482064f0750e05c08c1a6927e5.png"></p><p>需要注意的是，易用性提升前期，比如新增一个功能能够让整体更好用，同灵活性并没有什么冲突。</p><h3 id="4-6-架构的广度和深度"><a href="#4-6-架构的广度和深度" class="headerlink" title="4.6 架构的广度和深度"></a>4.6 架构的广度和深度</h3><p>日常扩大技术广度，使用时提升技术深度，是最佳的实践啦，有足够的技术视野才能做出优秀的架构，有足够的技术深度还能保证架构的有效落地。</p><h2 id="5-写在最后"><a href="#5-写在最后" class="headerlink" title="5. 写在最后"></a>5. 写在最后</h2><p>本文描述了创新试错下的多变开发模式，我们可以通过何种方式，提升面对变化时的效率，并对于理想的方式进行了技术实践上的落地，并且切实解决该场景下的问题。</p><p>其中技术实现，是以主流开发语言Java 作为基准的，如果你们是其他技术栈，可能实现细节不同，但是整体的思路肯定是相近的。</p><p>对于这个思路都是类似的实践模式，相信做过Faas或者Serverless的朋友都有相同的感触吧，能根据场景，把思路落地才是关键。</p><p>最后从整体的思考、设计、落地过程中总结了一点经验，也分享给了大家，如果有更好的思路，可以一起探讨。</p><p>新的思路、新的技术总能带来一些较多的收益，带也会带来一些麻烦，完整考虑收益，因地制宜才好。  </p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
      <tag>serverless</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spel使用实践</title>
    <link href="/2023/08/08/Spring/spel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/08/08/Spring/spel%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Spring表达式语言（简称SpEL）是一个支持查询并在运行时操纵一个对象图的功能强大的表达式语言。SpEL语言的语法类似于统一EL，但提供了更多的功能，最主要的是显式方法调用和基本字符串模板函数。</p><p>同很多可用的Java 表达式语言相比，例如OGNL，MVEL和JBoss EL，SpEL的诞生是为了给Spring社区提供一个可以给Spring目录中所有产品提供单一良好支持的表达式语言。其语言特性由Spring目录中的项目需求驱动，包括基于eclipse的SpringSource套件中的代码补全工具需求。也就是说，SpEL是一个基于技术中立的API允许需要时与其他表达式语言集成。</p><p>SpEL作为Spring目录中表达式求值的基础，它并不是直接依赖于Spring而是可以被独立使用。为了能够自包含，本章中的许多示例把SpEL作为一个独立的表达式语言来使用。这就需要创建一些如解析器的引导基础组件类。大多数Spring用户只需要为求值编写表达式字符串而不需要关心这些基础组件</p><h2 id="SpEL表达式-Hello-World"><a href="#SpEL表达式-Hello-World" class="headerlink" title="SpEL表达式 Hello World"></a>SpEL表达式 Hello World</h2><p>Spring表达式语言(SpEL)从3.X开始支持，它是一种能够支持运行时查询和操作对象的强大的表达式，其表达式语法类似于统一表达式语言。  </p><p>SpEL支持如下表达式：  </p><ul><li>基本表达式：字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算、正则表达式、括号优先级表达式；  </li><li>类相关表达式：类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用；  </li><li>集合相关表达式：内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择；不支持多维内联数组初始化；不支持内联字典定义；  </li><li>其他表达式：模板表达式。</li></ul><p>从一个Hello World!的示例开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建SpEL表达式的解析器</span><br>        ExpressionParser parser=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br>        <span class="hljs-comment">//解析表达式&#x27;Hello &#x27;+&#x27; World!&#x27;</span><br>        Expression exp=parser.parseExpression(<span class="hljs-string">&quot;&#x27;Hello &#x27;+&#x27; World!&#x27;&quot;</span>);<br>        <span class="hljs-comment">//取出解析结果</span><br>        String result=exp.getValue().toString();<br>        <span class="hljs-comment">//输出结果</span><br>        System.out.println(result);<br>    &#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><br><span class="hljs-comment">// Hello World!</span><br></code></pre></td></tr></table></figure><p>从示例中可以看出java成功的将一个字符解析出了结果，如果我们把要解析的内容设置成1+1则会解析出2来，这里的1+1就是一个SpEL表达式，该表达式在java中只是一个String，通过解析可以得到字符串本身的意见，有点类型编译程序的感觉。</p><h2 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a>SpEL表达式</h2><h3 id="1、文字表达式"><a href="#1、文字表达式" class="headerlink" title="1、文字表达式"></a>1、文字表达式</h3><p>支持的文字表达的类型是字符串，日期，数值（整型，实型，和十六进制），布尔和空。字符串是由单引号分隔。使用反斜杠字符转移把一个单引号字符本身放在字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ExpressionParser ep= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;&#x27;HelloWorld&#x27;&quot;</span>).getValue());<br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;0xffffff&quot;</span>).getValue());<br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;1.234345e+3&quot;</span>).getValue());<br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;new java.util.Date()&quot;</span>).getValue());<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>HelloWorld<br>16777215<br>1234.345<br>Fri Jul 01 14:50:59 CST 2016</p><h3 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">//创建SpEL表达式的解析器</span><br>        ExpressionParser parser=<span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br>        User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">9527</span>,<span class="hljs-string">&quot;周星驰&quot;</span>);<br>        <span class="hljs-comment">//解析表达式需要的上下文，解析时有一个默认的上下文</span><br>        <span class="hljs-type">EvaluationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>        <span class="hljs-comment">//在上下文中设置变量，变量名为user，内容为user对象</span><br>        ctx.setVariable(<span class="hljs-string">&quot;user&quot;</span>, user);<br>        <span class="hljs-comment">//从用户对象中获得id并+1900，获得解析后的值在ctx上下文中</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> (Integer) parser.parseExpression(<span class="hljs-string">&quot;#user.getId() + 1900&quot;</span>).getValue(ctx);<br>        System.out.println(id);<br><br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-comment">// 11427</span><br></code></pre></td></tr></table></figure><p>User类在前面已定义，这里增加了一个有参构造方法。上面的示例是调用方法，其实可以这样：引用对象属性，只需使用一个句点来表示一个嵌套的属性值，如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">int id = (Integer) parser.parseExpression(&quot;#user.id + 1900&quot;).getValue(ctx);<br></code></pre></td></tr></table></figure><p>要注意的是此时#user后不再是一个方法而是.id，直接访问属性，在java中这样做是不行的，便SpEL中允许</p><h3 id="3、数组"><a href="#3、数组" class="headerlink" title="3、数组"></a>3、数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] students=<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;tom&quot;</span>,<span class="hljs-string">&quot;jack&quot;</span>,<span class="hljs-string">&quot;rose&quot;</span>,<span class="hljs-string">&quot;mark&quot;</span>,<span class="hljs-string">&quot;lucy&quot;</span>&#125;;<br>ctx.setVariable(<span class="hljs-string">&quot;students&quot;</span>, students);<br><span class="hljs-type">String</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#students[3]&quot;</span>).getValue(ctx,<br>        String.class);<br>System.out.println(student);<br><br><span class="hljs-comment">// 结果：mark</span><br></code></pre></td></tr></table></figure><h3 id="4、列表"><a href="#4、列表" class="headerlink" title="4、列表"></a>4、列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-type">List</span> <span class="hljs-variable">numbers</span> <span class="hljs-operator">=</span> (List) parser.parseExpression(<span class="hljs-string">&quot;&#123;1,2,3,4,5&#125;&quot;</span>).getValue();<br>    System.out.println(numbers.get(<span class="hljs-number">2</span>)+<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-type">List</span> <span class="hljs-variable">listOfLists</span> <span class="hljs-operator">=</span> (List) parser.parseExpression(<span class="hljs-string">&quot;&#123;&#123;&#x27;a&#x27;,&#x27;b&#x27;&#125;,&#123;&#x27;x&#x27;,&#x27;y&#x27;&#125;&#125;&quot;</span>).getValue();<br>    System.out.println(((List)listOfLists.get(<span class="hljs-number">1</span>)).get(<span class="hljs-number">1</span>));<br><br><span class="hljs-comment">// 结果：3 y</span><br></code></pre></td></tr></table></figure><h3 id="5、索引器、与字典"><a href="#5、索引器、与字典" class="headerlink" title="5、索引器、与字典"></a>5、索引器、与字典</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">User user1=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">9001</span>,<span class="hljs-string">&quot;邹任飞&quot;</span>);<br>User user2=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">9002</span>,<span class="hljs-string">&quot;练汶峰&quot;</span>);<br>List&lt;User&gt; users=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;User&gt;();<br>users.add(user1);<br>users.add(user2);<br>ctx.setVariable(<span class="hljs-string">&quot;users&quot;</span>, users);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;#users[1].name&quot;</span>).getValue(ctx,String.class);<br>System.out.println(name);<br><br><span class="hljs-comment">// 结果：练汶峰</span><br></code></pre></td></tr></table></figure><p>在java中访问集合中的对象通过get(索引）而在SpEL中我们可以直接像数组那样访问对象。如果是一个字典可以这样:#users[“tom”].id</p><h3 id="6、方法"><a href="#6、方法" class="headerlink" title="6、方法"></a>6、方法</h3><p>方法调用使用典型的Java编程语法。 你可能 还在文字调用方法。 也支持可变参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;&#x27;abcdef&#x27;.substring(2, 3)&quot;</span>).getValue(String.class);<br>System.out.println(c);<br><br><span class="hljs-comment">// 结果：c</span><br></code></pre></td></tr></table></figure><h3 id="7、操作符"><a href="#7、操作符" class="headerlink" title="7、操作符"></a>7、操作符</h3><p>关系操作符：使用标准的操作符号支持关系操作符：等于，不等于，小于，小于等于，大于，大于等于。<br>逻辑操作符：支持的逻辑操作符包括and，or和not(!)，不支持&amp;&amp;和||。<br>算术操作符：加法运算符可以用于数字，字符串和日期。减法可用于数字和日期。乘法和除法仅可以用于。其他支持的数学运算包括取模（％）和指数幂（^）。使用标准的运算符优先级。</p><p>关系运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue1</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;2 == 2&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">falseValue1</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;2 &lt; -5.0&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue2</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;&#x27;black&#x27; &lt; &#x27;block&#x27;&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//false，字符xyz是否为int类型</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">falseValue2</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;&#x27;xyz&#x27; instanceof T(int)&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//true，正则是否匹配</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue3</span> <span class="hljs-operator">=</span>parser.parseExpression(<span class="hljs-string">&quot;&#x27;5.00&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//false</span><br><span class="hljs-type">boolean</span> falseValue3=parser.parseExpression(<span class="hljs-string">&quot;&#x27;5.0067&#x27; matches &#x27;^-?\\d+(\\.\\d&#123;2&#125;)?$&#x27;&quot;</span>).getValue(Boolean.class);<br></code></pre></td></tr></table></figure><p>逻辑运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -- AND 与运算 --</span><br><span class="hljs-comment">//false </span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">falseValue4</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;true and false&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//true，isMember方法用于测试是否为某个对象的成员</span><br><span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;isMember(&#x27;Nikola Tesla&#x27;) and isMember(&#x27;Mihajlo Pupin&#x27;)&quot;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue4</span> <span class="hljs-operator">=</span> parser.parseExpression(expression).getValue(Boolean.class);<br><span class="hljs-comment">// -- OR 或运算--</span><br><span class="hljs-comment">//true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue5</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;true or false&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//true</span><br><span class="hljs-type">String</span> <span class="hljs-variable">expression1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;isMember(&#x27;Nikola Tesla&#x27;) or isMember(&#x27;Albert Einstein&#x27;)&quot;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">trueValue6</span> <span class="hljs-operator">=</span> parser.parseExpression(expression).getValue( Boolean.class);<br><span class="hljs-comment">//false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">falseValue5</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;!true&quot;</span>).getValue(Boolean.class);<br><span class="hljs-comment">//false</span><br><span class="hljs-type">String</span> <span class="hljs-variable">expression2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;isMember(&#x27;Nikola Tesla&#x27;) and !isMember(&#x27;Mihajlo Pupin&#x27;)&quot;</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">falseValue6</span> <span class="hljs-operator">=</span> parser.parseExpression(expression).getValue(Boolean.class);<br></code></pre></td></tr></table></figure><p>算术运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Addition</span><br><span class="hljs-type">int</span> <span class="hljs-variable">two</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;1 + 1&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// 2</span><br><span class="hljs-type">String</span> <span class="hljs-variable">testString</span> <span class="hljs-operator">=</span><br>parser.parseExpression(<span class="hljs-string">&quot;&#x27;test&#x27; + &#x27; &#x27; + &#x27;string&#x27;&quot;</span>).getValue(String.class); <span class="hljs-comment">// &#x27;test string&#x27;</span><br><span class="hljs-comment">// Subtraction</span><br><span class="hljs-type">int</span> <span class="hljs-variable">four</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;1 - -3&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// 4</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;1000.00 - 1e4&quot;</span>).getValue(Double.class); <span class="hljs-comment">// -9000</span><br><span class="hljs-comment">// Multiplication</span><br><span class="hljs-type">int</span> <span class="hljs-variable">six</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;-2 * -3&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// 6</span><br><span class="hljs-type">double</span> <span class="hljs-variable">twentyFour</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;2.0 * 3e0 * 4&quot;</span>).getValue(Double.class); <span class="hljs-comment">// 24.0</span><br><span class="hljs-comment">// Division</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minusTwo</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;6 / -3&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// -2</span><br><span class="hljs-type">double</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;8.0 / 4e0 / 2&quot;</span>).getValue(Double.class); <span class="hljs-comment">// 1.0</span><br><span class="hljs-comment">// Modulus</span><br><span class="hljs-type">int</span> <span class="hljs-variable">three</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;7 % 4&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// 3</span><br><span class="hljs-type">int</span> <span class="hljs-variable">one</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;8 / 5 % 2&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// Operator precedence</span><br><span class="hljs-type">int</span> <span class="hljs-variable">minusTwentyOne</span> <span class="hljs-operator">=</span> parser.parseExpression(<span class="hljs-string">&quot;1+2-3*8&quot;</span>).getValue(Integer.class); <span class="hljs-comment">// -21</span><br></code></pre></td></tr></table></figure><h3 id="8、表达式支持定义bean、-基于注解的配置"><a href="#8、表达式支持定义bean、-基于注解的配置" class="headerlink" title="8、表达式支持定义bean、****基于注解的配置"></a>8、<strong>表达式支持定义bean、****基于注解的配置</strong></h3><p>用户类User.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhangguo.Spring053.spel03;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component(&quot;user1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;#&#123;9527+100&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 姓名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;#&#123;&#x27;Hello&#x27;.toUpperCase()&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>订单类：Order.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhangguo.Spring053.spel03;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 订单类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Repository(&quot;Order03&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 订单名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;#&#123;&#x27;Apple订单&#x27;&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String orderName;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 用户姓名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;#&#123;user1.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用户对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Value(&quot;#&#123;user1&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> User customer;<br><br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrderName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> orderName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOrderName</span><span class="hljs-params">(String orderName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderName = orderName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getCustomer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> customer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCustomer</span><span class="hljs-params">(User customer)</span> &#123;<br>        <span class="hljs-built_in">this</span>.customer = customer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;订单名：&quot;</span>+<span class="hljs-built_in">this</span>.getOrderName()+<span class="hljs-string">&quot;,姓名：&quot;</span>+<span class="hljs-built_in">this</span>.getUserName()+<span class="hljs-string">&quot;,编号：&quot;</span>+<span class="hljs-built_in">this</span>.getCustomer().getId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码Test.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhangguo.Spring053.spel03;<br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">import</span> com.zhangguo.Spring053.spel03.User;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ApplicationContext ctx=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spel03.xml&quot;</span>);<br>        User user1=ctx.getBean(<span class="hljs-string">&quot;user1&quot;</span>,User.class);<br>        System.out.println(user1.getId()+<span class="hljs-string">&quot;,&quot;</span>+user1.getName());<br>        <br>        Order Order03=ctx.getBean(<span class="hljs-string">&quot;Order03&quot;</span>,Order.class);<br>        System.out.println(Order03);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><br><span class="hljs-comment">// 9627,HELLO  </span><br><span class="hljs-comment">// 订单名：Apple订单,姓名：HELLO,编号：9627</span><br></code></pre></td></tr></table></figure><h3 id="9、操作符"><a href="#9、操作符" class="headerlink" title="9、操作符"></a>9、操作符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">ep</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><span class="hljs-comment">// 关系操作符</span><br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;5&gt;2&quot;</span>).getValue());<br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;2 between &#123;1,9&#125;&quot;</span>).getValue());<br><span class="hljs-comment">// 逻辑运算符</span><br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;(5&gt;2) and (2==1)&quot;</span>).getValue());<br><span class="hljs-comment">// 算术操作符</span><br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;100-2^2&quot;</span>).getValue());<br></code></pre></td></tr></table></figure><p>结果：</p><p>true<br>true<br>false<br>96</p><h3 id="10、变量与赋值"><a href="#10、变量与赋值" class="headerlink" title="10、变量与赋值"></a>10、变量与赋值</h3><p>变量：变量可以在表达式中使用语法#’变量名’引用  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ExpressionParser ep= <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();  <br><span class="hljs-comment">//创建上下文变量  </span><br><span class="hljs-type">EvaluationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();  <br>ctx.setVariable(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Hello&quot;</span>);  <br>System.out.println(ep.parseExpression(<span class="hljs-string">&quot;#name&quot;</span>).getValue(ctx));<br><br><span class="hljs-comment">// 输出：Hello  </span><br></code></pre></td></tr></table></figure><h3 id="11、模板"><a href="#11、模板" class="headerlink" title="11、模板"></a>11、模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">template</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, #&#123;#name&#125;! Today&#x27;s date is #&#123;#date&#125;.&quot;</span>;<br><br><span class="hljs-type">EvaluationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEvaluationContext</span>();<br>context.setVariable(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Alice&quot;</span>);<br>context.setVariable(<span class="hljs-string">&quot;date&quot;</span>, LocalDate.now().toString());<br><span class="hljs-type">ExpressionParser</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpelExpressionParser</span>();<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> parser.parseExpression(template, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TemplateParserContext</span>()).getValue(context, String.class);<br>System.out.println(result);<br><br><span class="hljs-comment">// 执行结果</span><br><span class="hljs-comment">// Hello, Alice! Today&#x27;s date is 2023-08-08.</span><br></code></pre></td></tr></table></figure><p>注意，如果context不存在此变量，则不赋值，并且 #</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ognl语言介绍和使用实践</title>
    <link href="/2023/08/07/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/ognl%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/08/07/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/ognl%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="OGNL-的历史"><a href="#OGNL-的历史" class="headerlink" title="OGNL 的历史"></a>OGNL 的历史</h2><p>OGNL 最初是为了能够使用对象的属性名来建立 UI 组件 (component) 和 控制器 (controllers) 之间的联系，简单来说就是：视图 与 控制器 之间数据的联系。后来为了应付更加复杂的数据关系，Drew Davidson 发明了一个被他称为 KVCL(Key-Value Coding Language) 的语言。 Luke 参与进来后，用 ANTLR 来实现了该语言，并给它取了这个新名字，他后来又使用 JavaCC 重新实现了该语言。目前 OGNL 由 Drew 来负责维护。目前很多项目中都用到了 OGNL，其中不乏为大家所熟知的，例如几个流行的 web 应用框架：WebWork，Tapestry 等。</p><h2 id="什么是-OGNL？"><a href="#什么是-OGNL？" class="headerlink" title="什么是 OGNL？"></a>什么是 OGNL？</h2><p>OGNL 是 Object-Graph Navigation Language 的缩写，从语言角度来说：它是一个功能强大的表达式语言，用来获取和设置 java 对象的属性 , 它旨在提供一个更高抽象度语法来对 java 对象图进行导航，OGNL 在许多的地方都有应用，例如：</p><ol><li>作为 GUI 元素（textfield,combobox, 等）到模型对象的绑定语言。</li><li>数据库表到 Swing 的 TableModel 的数据源语言。</li><li>web 组件和后台 Model 对象的绑定语言 (WebOGNL,Tapestry,WebWork,WebObjects) 。</li><li>作为 Jakarata Commons BeanUtils 或者 JSTL 的表达式语言的一个更具表达力的替代语言。</li></ol><p>另外，java 中很多可以做的事情，也可以使用 OGNL 来完成，例如：列表映射和选择。 对于开发者来说，使用 OGNL，可以用简洁的语法来完成对 java 对象的导航。通常来说： 通过一个”路径”来完成对象信息的导航，这个”路径”可以是到 java bean 的某个属性，或者集合中的某个索引的对象，等等，而不是直接使用 get 或者 set 方法来完成。</p><h2 id="为什么需要表达式语言-EL"><a href="#为什么需要表达式语言-EL" class="headerlink" title="为什么需要表达式语言 (EL)"></a>为什么需要表达式语言 (EL)</h2><p>表达式语言（EL）本质上被设计为：帮助你使用简单的表达式来完成一些”常用”的工作。通常情况下，ELs 可以在一些框架中找到，它被是用来简化我们的工作。例如：大家熟知的 Hibernate，使用 HQL(Hibernate Query Language) 来完成数据库的操作，HQL 成了开发人员与复查的 SQL 表达式之间的一个桥梁。 在 web 框架下，表达式语言起到了相似的目的。它的存在消除了重复代码的书写。例如：当没有 EL 的时候，为了从 session 中得到购物车并且将 ID 在网页上呈现出来，当直接在 jsp 中使用 java 代码来完成的时候，一般是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;%<br>    ShoppingCart cart = (ShoppingCart) session.get(&quot;cart&quot;);<br>    int id = cart.getId();<br>    %&gt;<br>    &lt;%= id%&gt;<br></code></pre></td></tr></table></figure><p>你也可以将这些 code 压缩成一句，如下，但是现在代码就很不直观，且不可读。另外，虽然变成了一句，但是与上面的原始的例子一样，也包含了同样的表达式。例如：类型转换：转换成 ShoppingCart 。这里只不过是将原来的三个表达式变成了一句，其复杂度是没有得到简化的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;%= ((ShoppingCart) session.get(&quot;cart&quot;)).getId() %&gt;<br></code></pre></td></tr></table></figure><p>当在 web 框架中使用表达式语言的时候，则可以有效的处理这种代码的复杂性。而不需要你，调用 servelet API，类型转换，然后再调用 getter 方法，多数的 Els 都可将这个过程简化为类似于：#session.cart.id 这中更可读的表达式。 表达式：#session.cart.id 与 java 代码不一样的是：没有 java 代码的 get 方法调用和类型转换。因为这些操作是非常”常用”的，这时候使用 EL 就顺理成章了，使用 EL 可以”消除”这些代码。</p><h2 id="OGNL-的基本语法"><a href="#OGNL-的基本语法" class="headerlink" title="OGNL 的基本语法"></a>OGNL 的基本语法</h2><p>OGNL 表达式一般都很简单。虽然 OGNL 语言本身已经变得更加丰富了也更强大了，但是一般来说那些比较复杂的语言特性并未影响到 OGNL 的简洁：简单的部分还是依然那么简单。比如要获取一个对象的 name 属性，OGNL 表达式就是 name, 要获取一个对象的 headline 属性的 text 属性，OGNL 表达式就是 headline.text 。 OGNL 表达式的基本单位是”导航链”，往往简称为”链”。最简单的链包含如下部分：</p><p>表达式组成部分示例属性名称如上述示例中的 name 和 headline.text方法调用hashCode() 返回当前对象的哈希码。数组元素listeners[0] 返回当前对象的监听器列表中的第一个元素。</p><p>所有的 OGNL 表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。你的链可以写得很长，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">name.toCharArray()[0].numericValue.toString()<br></code></pre></td></tr></table></figure><p>上面的表达式的求值步骤：</p><ul><li>提取根 (root) 对象的 name 属性。</li><li>调用上一步返回的结果字符串的 toCharArray() 方法。</li><li>提取返回的结果数组的第一个字符。</li><li>获取字符的 numericValue 属性，该字符是一个 Character 对象，Character 类有一个 getNumericValue() 方法。</li><li>调用结果 Integer 对象的 toString() 方法。</li></ul><p>上面的例子只是用来得到一个对象的值，OGNL 也可以用来去设置对象的值。当把上面的表达式传入 Ognl.setValue() 方法将导致 InappropriateExpressionException，因为链的最后的部分（ <code>toString()</code> ）既不是一个属性的名字也不是数组的某个元素。 了解了上面的语法基本上可以完成绝大部分工作了。</p><h2 id="如何使用-OGNL"><a href="#如何使用-OGNL" class="headerlink" title="如何使用 OGNL"></a>如何使用 OGNL</h2><p>OGNL 不仅能够去获取或者设置对象的属性，而也可以用来：完成实例方法的调用，静态方法的调用，表达式求值，Lambda 表达式等，下面我们看看如何使用 OGNL 来完成这些任务。</p><h3 id="ognl-Ognl-类"><a href="#ognl-Ognl-类" class="headerlink" title="ognl.Ognl 类"></a><code>ognl.Ognl</code> 类</h3><p>最简单的使用是直接使用 ognl.Ognl 类来评估一个 OGNL 表达式。 Ognl 类提供一些静态方法用来解析和解释 OGNL 表达式，最简单的示例是不使用上下文从一个对象中获取某个表达式的值，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">import ognl.Ognl; <br>import ognl.OgnlException;<br><br>try &#123;<br>result = Ognl.getValue(expression, root);<br>&#125;<br>catch (OgnlException ex)<br>&#123;   <br>// Report error or recover   <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码将基于 root 对象评估 expression，返回结果，如果表达式有错，比如没有找到指定的属性，将抛出 OgnlException 。 更复杂一点的应用是使用预解析的表达式。这种方式允许在表达式求值之前就能捕获表达式的解析错误，应用开发人员可以缓存表达式解析出来的结果（AST），从而能在重复使用的时候提高性能。 Ognl 的 parseExpression 方法就是用来执行预解析操作的。 Ognl 2.7 版本后由于添加了” Expression Compilation ”性能得到了质的提高，在后面章节会有介绍。 Ognl 类的获取和设置方法也可以接受一个 context map 参数，他允许你放一些自己的变量，并能在 Ognl 表达式中使用。缺省的上下文里只包含 #root 和 #context 两个键。下面的示例展示如何从 root 对象中解析出 documentName 属性，然后将当前用户名称添加到返回的结果后面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">private Map context = new HashMap();<br>public void setUserName(String value)<br>&#123;<br>      context.put(&quot;userName&quot;, value);<br>&#125;<br>try &#123;<br>     // get value using our own custom context map<br>     result = Ognl.getValue(&quot;userName&quot;&quot;, context, root);<br>&#125; catch (OgnlException ex) &#123;<br>      // Report error or recover<br>&#125;<br></code></pre></td></tr></table></figure><p>上面提到的 #root 变量指向的就是当前的 root 变量（表达式求值的初始对象（initial object））, 而 #context 就是指向的 Map 对象，下面的例子可以更直观的说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plain">User root = new User();<br>  root.setId(19612);<br>  root.setName(&quot;sakura&quot;);<br>  Map context = new HashMap();<br>  context.put(&quot;who&quot;, &quot;Who am i?&quot;);<br>  try &#123;<br>    String who1 = (String)Ognl.getValue(&quot;#who&quot;, context, root);<br>    String who2 = (String)Ognl.getValue(&quot;#context.who&quot;, context, root);<br>      Object whoExp = Ognl.parseExpression(&quot;#who&quot;);<br>    String who3 = (String)Ognl.getValue(whoExp, context, root);<br>    //who1 who2 who3 返回同样的值， whoExp 重复使用可以提高效率<br>    String name1 = (String)Ognl.getValue(&quot;name&quot;, root);<br>    String name2 = (String)Ognl.getValue(&quot;#root.name&quot;, root);<br>    //name1 name2 返回同样的值<br>  &#125; catch (OgnlException e) &#123;<br>    //error handling<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="OGNL-表达式"><a href="#OGNL-表达式" class="headerlink" title="OGNL 表达式"></a>OGNL 表达式</h3><ol><li>常量： 字符串：” ello” 字符：’h’ 数字：除了像 java 的内置类型 int,long,float 和 double,Ognl 还有如例：10.01B，相当于 java.math.BigDecimal，使用 ‘b’ 或者 ‘B’ 后缀。 100000H，相当于 java.math.BigInteger，使用 ‘h’ 或 ‘H’ 后缀。</li><li>属性的引用 例如：user.name</li><li>变量的引用 例如：#name</li><li>静态变量的访问 使用 @class@field</li><li>静态方法的调用 使用 @class@method(args), 如果没有指定 class 那么默认就使用 java.lang.Math.</li><li>构造函数的调用 例如：new java.util.ArrayList();</li></ol><p>其它的 Ognl 的表达式可以参考 Ognl 的语言手册。</p><h3 id="OGNL-的基本用法"><a href="#OGNL-的基本用法" class="headerlink" title="OGNL 的基本用法"></a>OGNL 的基本用法</h3><p>OGNL 的 API，前面我们已经介绍过了，OGNL 的一个主要功能就是对象图的导航，我们看一下 OGNL 的最基本的用去取值和设置的 API。</p><h5 id="getValue"><a href="#getValue" class="headerlink" title="getValue"></a>getValue</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static java.lang.Object getValue(java.lang.String expression,<br>                                            java.util.Map context,<br>                                            java.lang.Object root,<br>                                            java.lang.Class resultType)<br>                                     throws OgnlException<br>     Evaluates the given OGNL expression to extract a value<br>      from the given root object in a given context<br>     Parameters:<br>     expression - the OGNL expression to be parsed<br>     context - the naming context for the evaluation<br>     root - the root object for the OGNL expression<br>     resultType - the converted type of the resultant object,<br>                 using the context&#x27;s type converter<br>     Returns:<br>     the result of evaluating the expression<br></code></pre></td></tr></table></figure><h5 id="setValue"><a href="#setValue" class="headerlink" title="setValue"></a>setValue</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">public static void setValue(java.lang.String expression,<br>                                 java.util.Map context,<br>                                 java.lang.Object root,<br>                                 java.lang.Object value)<br>                          throws OgnlException<br>     Evaluates the given OGNL expression to insert a value into the<br>     object graph rooted at the given root object given the context.<br>     Parameters:<br>     expression - the OGNL expression to be parsed<br>     root - the root object for the OGNL expression<br>     context - the naming context for the evaluation<br>     value - the value to insert into the object graph<br></code></pre></td></tr></table></figure><p>OGNL 的 API 设计得是很简单的，context 提供上下文，为变量和表达式的求值过程来提供命名空间，存储变量 等，通过 root 来指定对象图遍历的初始变量，使用 expression 来告诉 Ognl 如何完成运算。看看下面两个简单的代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">User user1 = new User();<br>user1.setId(1);<br>user1.setName(&quot;firer&quot;);<br>User user2 = new User();<br>user2.setId(2);<br>user2.setName(&quot;firer2&quot;);<br>List users = new ArrayList();<br>users.add(user1);<br>users.add(user2);<br>Department dep = new Department();<br>dep.setUsers(users);<br>dep.setName(&quot;dep&quot;);<br>dep.setId(11);<br>Object o = Ognl.getValue(&quot;users[1].name&quot;, dep);<br></code></pre></td></tr></table></figure><p>这里我们可以看到前面介绍的使用表达式语言的有点，使用 “users[1].name”，就能完成对 name 的取值，而不用去进行类型转换等工作。下面是一个简单的设值的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">User user = new User();<br>user.setId(1);<br>user.setName(&quot;ffirer&quot;);<br>Ognl.setValue(&quot;department.name&quot;, user, &quot;dep1&quot;);<br></code></pre></td></tr></table></figure><p>就想前面介绍的，Ognl 也可以完成一些其它的工作，一个例子就是在我们的日常工作中，我们经常需要从列表中去”搜索”符合我们要求的对象，使用 java 的时候我们需要对列表进行遍历、类型转换、取值然后比较来得到我们想要的值，而使用 Ognl 将使这个过程变得简单，优雅。代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">User user1 = new User();<br>user1.setId(1);<br>user1.setName(&quot;firer&quot;);<br>// 如上例创建一些 User<br>List users = new ArrayList();<br>users.add(user1);<br>// 将创建的 User 添加到 List 中<br>Department dep = new Department();<br>dep.setUsers(users);<br>List names = (List)Ognl.getValue(&quot;users.&#123;name&#125;&quot;, dep);<br>List ids = (List)Ognl.getValue(&quot;users.&#123;? #this.id &gt; 1&#125;&quot;, dep);<br></code></pre></td></tr></table></figure><p>这里表达式 “users.{name}” 将取得列表中所有 Users 的 name 属性，并以另外一个列表返回。 “users.{? #this.id &gt; 1}” 将返回所有 id 大于 1 的 User，也以一个列表返回，包含了所有的 User 对象。这里使用的是 Ognl 的”列表投影”操作，叫这个名字是因为比较像数据库中返回某些列的操作。 Ognl 还有很多其它功能，在 Ognl 的 SVN 的 testcase 中找到如何使用它们。</p><h2 id="OGNL-的性能"><a href="#OGNL-的性能" class="headerlink" title="OGNL 的性能"></a>OGNL 的性能</h2><p>OGNL，或者说表达式语言的性能主要又两方面来决定，一个就是对表达式的解析 (Parser)，另一个是表达式的执行，OGNL 采用 javaCC 来完成 parser 的实现，在 OGNL 2.7 中又对 OGNL 的执行部分进行了加强，使用 javasisit 来 JIT(Just-In-Time) 的生成 byte code 来完成表达式的执行。 Ognl 给这个功能的名字是：OGNL Expression Compilation 。 基本的使用方法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">SimpleObject root = new SimpleObject();<br>OgnlContext context =  (OgnlContext) Ognl.createDefaultContext(null);<br><br>Node node =  (Node) Ognl.compileExpression(context, root, &quot;user.name&quot;);<br>String userName = （String）node.getAccessor().get(context, root);<br></code></pre></td></tr></table></figure><p>那么使用 Expression Compilation 能给 Ognl 的性能带来什么了？ 一个性能方面的简单测试：对比了 4 中情况：分别是：直接 Java 调用 (1), OGNL 缓存使用 expression compilation (2), OGNL 缓存使用 OGNL expression parsed（3） 以及不使用任何缓存的结果（4）。</p><h5 id="图-1-性能对比"><a href="#图-1-性能对比" class="headerlink" title="图 1. 性能对比"></a>图 1. 性能对比</h5><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691488319-75255fb7c64f74c6cae09bdb2fc5d212.jpg" alt="性能对比"></p><p>可以看到 expression compilation 非常接近使用 java 调用的时间，所以可以看到当表达式要被多次使用，使用 expression compilation 并且已经做好了缓存的情况下，OGNL 非常接近 java 直接调用的时间。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本文介绍了 OGNL 的概念、表达式语法以及如何使用 OGNL， 并提供了一些简单的示例代码，OGNL 在实际应用中还可以对其进行扩展，在本文中并为涉及， 感兴趣的读者可以进一步进行相关的学习和研究</p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>问题定位</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题定位</tag>
      
      <tag>ognl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis和mysql的双写问题</title>
    <link href="/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis%E5%92%8Cmysql%E7%9A%84%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98/"/>
    <url>/2023/08/06/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis%E5%92%8Cmysql%E7%9A%84%E5%8F%8C%E5%86%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是双写问题"><a href="#什么是双写问题" class="headerlink" title="什么是双写问题"></a>什么是双写问题</h2><p>Redis和MySQL的双写问题是指在同一个业务流程中，需要同时向Redis和MySQL两个数据库系统写入数据。由于这两种数据库系统的特性不同，可能会引发一些问题，尤其是在数据一致性和数据可靠性方面。</p><p>这主要有两个问题：</p><ol><li>数据一致性问题：由于网络、程序等问题，可能会出现先写Redis成功，再写MySQL失败的情况，或者反过来，导致数据在两个系统中不一致。</li><li>双写一致性问题：即使两个写操作都成功，但由于Redis和MySQL的读写速度差异，可能会出现”脏读”的问题，即新的读操作读取到的是旧的数据。</li></ol><h2 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h2><p>解决这两个问题的常见策略包括：</p><ol><li><strong>使用分布式事务来保证数据一致性。</strong>分布式事务可以保证在多个系统中的所有操作都成功或者都失败。但是，由于Redis并不原生支持分布式事务，实现起来可能比较复杂，且可能会影响系统性能。</li><li><strong>采用最终一致性模型</strong>，这种模型可以接受短暂的数据不一致，但需要保证最终数据的一致性。例如，可以使用消息队列来实现：先更新一种数据库，然后将更新操作放入消息队列，由另一种数据库消费该队列来完成更新。</li><li><strong>优先保证MySQL的数据写入，成功后再写入Redis</strong>。当读取数据时，优先从Redis中读取，如果Redis中没有，再从MySQL中读取，并将读取到的数据写入Redis，这种方式被称为缓存穿透。这种方式可以在一定程度上保证数据的一致性，但可能会增加系统的复杂性。</li></ol><h2 id="先写MySQL在写Redis的优缺点"><a href="#先写MySQL在写Redis的优缺点" class="headerlink" title="先写MySQL在写Redis的优缺点"></a>先写MySQL在写Redis的优缺点</h2><p><strong>优点：</strong></p><ol><li><strong>数据一致性</strong>：优先保证MySQL的数据写入，成功后再写入Redis，这样即使在写Redis的过程中出现了错误，数据依然可以从MySQL中取得，这保证了数据的一致性。</li><li><strong>高可用性</strong>：读取数据时，优先从Redis中读取，如果Redis中没有，再从MySQL中读取，并将读取到的数据写入Redis。这样做既可以提高数据读取的速度（因为Redis是基于内存的，读写速度快），又可以防止MySQL的查询压力过大。</li><li><strong>易于实施</strong>：这种策略在技术实现上相对简单，不需要考虑分布式事务或者引入额外的组件如消息队列等。</li></ol><p><strong>弊端：</strong></p><ol><li><strong>数据延迟</strong>：由于数据需要先写入MySQL，再写入Redis，所以如果有并发的读请求，可能会读到旧的数据，也就是出现“脏读”的情况。</li><li><strong>增加系统复杂性</strong>：这种方式需要业务代码去做缓存的读写，增加了代码的复杂性。</li><li><strong>Redis数据丢失问题</strong>：如果Redis发生故障，数据丢失，会导致大量的请求冲击MySQL，进一步可能会引发MySQL的性能问题。这种情况下，需要有适当的Redis持久化策略，或者备份策略来应对。</li></ol><p><strong>适用场景</strong></p><ol><li><strong>高读取频率的数据</strong>：对于读取频率很高的数据，这种策略非常有用。数据主要存储在MySQL中，但由于读取主要从Redis中进行，可以显著提高读取速度。</li><li><strong>需要快速更新的数据</strong>：对于需要快速更新的数据，首先更新MySQL，然后更新Redis，这样可以保证最终的数据一致性。（或者可以先让Redis数据失效，在更新数据库，Redis等下一次查询的时候进行更新）</li><li><strong>Redis数据失效或重启</strong>：当Redis中的数据失效或者Redis需要重启时，可以从MySQL中读取数据并重新填充Redis，这样即使Redis中的数据丢失，也不会影响到应用程序的正常运行。</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>有几种常见的分布式事务解决方案，包括两阶段提交（2PC）、三阶段提交（3PC）、TCC（Try-Confirm-Cancel）等。这里我会详细介绍2PC和TCC两种方案。</p><ol><li><p><strong>两阶段提交（2PC）</strong>：</p><ul><li><strong>准备阶段</strong>：事务协调者向所有的事务参与者发送事务内容，询问是否可以执行事务，然后等待所有参与者的回复。</li><li><strong>提交阶段</strong>：如果所有的事务参与者都同意事务请求，事务协调者向所有的参与者发送“提交”请求，并进入“完成”状态。各参与者在执行事务提交操作后，释放在事务执行中占用的资源。</li></ul><p>这种方式的主要问题在于同步阻塞和单点问题。如果协调者宕机，参与者会一直阻塞等待，直到协调者恢复。如果参与者宕机，协调者也需要一直等待其恢复。此外，事务的提交依赖于所有参与者的反馈，只要有一个参与者反馈失败，那么整个事务就会失败，这显然在大规模分布式系统中是低效的。</p></li><li><p><strong>TCC（Try-Confirm-Cancel）</strong>：</p><ul><li><strong>Try阶段</strong>：检查预计执行的业务是否可以成功，执行所有业务检查，预留必须的业务资源。</li><li><strong>Confirm阶段</strong>：真正的执行业务操作，并且不会失败（除非有程序上的错误），因为前一阶段已经做了资源的预留。</li><li><strong>Cancel阶段</strong>：在业务执行错误，或者长时间无响应需要回滚的时候，执行的业务取消，取消预留的业务资源。</li></ul><p>TCC模式相比于2PC，更适合长事务处理，能更好地降低阻塞情况。但TCC需要为每个业务逻辑编写对应的确认和取消操作，增加了开发的复杂性。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流量录制回放介绍</title>
    <link href="/2023/08/04/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/08/04/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E5%9B%9E%E6%94%BE%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是流量录制回放"><a href="#1-什么是流量录制回放" class="headerlink" title="1.什么是流量录制回放"></a><strong>1.什么是流量录制回放</strong></h1><p>流量录制回放是一种自动化<strong>测试手段：</strong>将生产环境流量录制下来在测试环境回放</p><p><strong>流量：</strong>  接口入出参，以及内部中间件调用的入出参</p><h2 id="1-1-传统测试手段面临的问题"><a href="#1-1-传统测试手段面临的问题" class="headerlink" title="1.1 传统测试手段面临的问题"></a><strong>1.1</strong> <strong>传统测试手段面临的问题</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949666.png" alt="img"></p><h2 id="1-2-流量录制回放工作过程"><a href="#1-2-流量录制回放工作过程" class="headerlink" title="1.2 流量录制回放工作过程"></a><strong>1.2 流量录制回放工作过程</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-1062789.png" alt="img"></p><p><strong>特点：</strong></p><ul><li><strong>线上真实数据</strong></li><li><strong>数据量大，覆盖足够多场景</strong></li><li><strong>自动化录制回放，人工成本低</strong></li><li><strong>适合批量、巡检</strong></li><li><strong>一次录制多次使用</strong></li></ul><h2 id="1-3-什么场景适合使用流量回放"><a href="#1-3-什么场景适合使用流量回放" class="headerlink" title="1.3 什么场景适合使用流量回放"></a><strong>1.3 什么场景适合使用流量回放</strong></h2><ul><li><strong>客户端协议不变，服务端重构：</strong> 例如海外的双AZ\Trinity项目</li><li><strong>确认不确定</strong>：代码变更后， 预期是对其它接口无影响， 但是又不能完全肯定，而手工测试这些接口成本又太高</li><li><strong>测试场景覆盖不全：</strong>无法构造线上case</li><li><strong>快速回归测试：</strong>可以是上线前的回归测试， 也可以是测试过程中BUG修复后的回归测试</li><li><strong>自动生成KAT自动化测试用例</strong></li></ul><h2 id="1-4-业内成功案例"><a href="#1-4-业内成功案例" class="headerlink" title="1.4 业内成功案例"></a><strong>1.4 业内成功案例</strong></h2><table><thead><tr><th>引擎名（所属公司）</th><th>核心技术</th><th>优点</th><th>缺点</th><th>开源</th></tr></thead><tbody><tr><td>DOOM(阿里)</td><td>SpringAOP+字节码插桩</td><td>业务代码零改造可以录制&#x2F;mock任意方法</td><td>问题定位困难降级困难， 往往需要重启从风险角度看，难以让所有实例都接入，阿里也是选取少量服务器接入</td><td>否</td></tr><tr><td>回声墙（蚂蚁）</td><td>微服务框架+SpringAOP</td><td>风险可控，可迅速降级对系统影响小， ms级别在切面中实现, 可以录制bean实例的任意方法</td><td>无法录制非bean的方法接入系统需要升级改造</td><td>否</td></tr><tr><td>Sandbox Repeater(阿里)</td><td>字节码插桩</td><td>同DOOM</td><td>同DOON</td><td>是</td></tr><tr><td>Bytecopy(字节)</td><td>类tcp copy</td><td>灰度引流测试用于与真实环境交互</td><td>不支持线下测试不支持下游和中间件的录制</td><td>否</td></tr><tr><td>好未来&#x2F;汽车之家&#x2F;以及其他</td><td>sandbox</td><td></td><td></td><td></td></tr></tbody></table><p><strong>业内优秀案例优点：</strong></p><ul><li>业务零改造</li><li>侵入少量机器</li></ul><p><strong>我们的建设原则：</strong></p><ul><li>兼容业内优点</li><li>同时支持C++ 和 JAVA</li><li>避免DIFF效率低</li></ul><p>​</p><h1 id="2-流量录制回放架构"><a href="#2-流量录制回放架构" class="headerlink" title="2.流量录制回放架构"></a><strong>2.流量录制回放架构</strong></h1><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949638.png" alt="img"></p><h1 id="3-主要功能介绍"><a href="#3-主要功能介绍" class="headerlink" title="3.主要功能介绍"></a><strong>3.主要功能介绍</strong></h1><p><strong>流量录制回放是一件复杂的事情， 需要用户具备以下能力</strong></p><ol><li>对被录制服务足够了解，包括服务的读写动作、中间件依赖情况、入出参含义、高&#x2F;平峰QPS等</li><li>熟悉KTraffic平台的使用，包括平台各种参数、配置的含义。</li><li>具备一定的问题排查能力， 了解kbox等常用问题定位手段的应用。</li><li>简单了解录制、回放工作原理。</li></ol><p>因为一次配置多次使用的特点，所以为学习使用方式做出的付出还是值得的。</p><h2 id="3-1-流量录制"><a href="#3-1-流量录制" class="headerlink" title="3.1 流量录制"></a><strong>3.1 流量录制</strong></h2><p><strong>3.1.1 我们能录制什么</strong></p><p>我们支持录制<strong>被测服务</strong>（即待回放服务）的<strong>主流量</strong>及其<strong>N-1层子流量</strong></p><ul><li><p><strong>被测服务</strong>目前支持的包括：</p></li><li><ul><li>使用spring mvc提供的http服务</li><li>使用ksboot提供的http服务</li><li>使用java 提供的grpc服务</li><li>使用c++提供的grpc服务</li></ul></li><li><p><strong>主流量：</strong>即被测服务的入参和出参。</p></li><li><p><strong>N-1层子流量：</strong> 被测服务在其进程内发起的远程调用。 例如被测服务A在其进程内发起了向GRPC服务B的调用， 在A的进程中可以得的B的入参与出参， 此时B的入参出参被称为服务A的<strong>N-1层子流量</strong>，而在服务B的进程内产生的一切子调用都不会被录制（因为服务B没有打开录制配置，甚至根本就没有集成录制组件）。目前<strong>JAVA服务</strong>支持录制的子流量类型包括:</p></li></ul><ol><li>G&#x2F;KRPC</li><li>mysql</li><li>redis</li><li>memcached</li><li>kconf</li><li>loadingcached</li><li>kafka producer</li><li>rocketmq</li><li>keycenter</li><li>idseq</li><li>kswitch</li></ol><p>   即被测服务A发起以上7种中间件的子调用时， 其流量都可以被录制。</p><h3 id="3-1-2-流量录制原理"><a href="#3-1-2-流量录制原理" class="headerlink" title="3.1.2 流量录制原理"></a><strong>3.1.2 流量录制原理</strong></h3><p><strong>录制流程</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949598.png" alt="img"></p><ul><li>中间件client 包括：g&#x2F;krpc 、mysql、kconf等7种常用中间件的client</li><li>HTTP的录制是通过集成具备录制功能的filter进行。</li></ul><p><strong>录制关键架构</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950041.png" alt="img"></p><h3 id="3-1-3-使用方如何集成流量录制组件"><a href="#3-1-3-使用方如何集成流量录制组件" class="headerlink" title="3.1.3 使用方如何集成流量录制组件"></a><strong>3.1.3</strong> <strong>使用方如何集成流量录制组件</strong></h3><ul><li>g&#x2F;krpc、mysql、kconf等KTraffic支持的**(非HTTP**)中间件的client通过root pom集成， 用户无需改造。</li><li>基于ksboot&#x2F;springmvc的HTTP服务配置方式见：<a href="https://docs.corp.kuaishou.com/k/home/VX8v5do5Oc4I/fcACIVeHe-P6p-dqnGj6TfoI3#section=h.8na0jw3c2oab">HTTP服务添加录制依赖</a></li></ul><p>其它说明：</p><ul><li>目前不支持HTTP类型的<strong>子流量</strong>的录制</li></ul><h3 id="3-1-4-流程与功能"><a href="#3-1-4-流程与功能" class="headerlink" title="3.1.4 流程与功能"></a><strong>3.1.4 流程与功能</strong></h3><p><strong>创建录制任务的流程</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949601.png" alt="img"></p><p><strong>录制功能介绍</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949640.png" alt="img"></p><h2 id="3-2-流量回放"><a href="#3-2-流量回放" class="headerlink" title="3.2 流量回放"></a><strong>3.2 流量回放</strong></h2><h3 id="3-2-1-MOCK能力"><a href="#3-2-1-MOCK能力" class="headerlink" title="3.2.1 MOCK能力"></a><strong>3.2.1 MOCK能力</strong></h3><p><strong>为什么要有MOCK能力？</strong></p><p>在流量回放建设之初，因为没有mock能力，我们仅支持回放与生产环境使用同源数据库的服务。所以只能回放读服务，否则会对线上产生脏数据。因此流量回放能力一般被使用在集成测试阶段， 对线上的服务做最后的回归。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949644.png" alt="img"></p><p>而更多的测试行为发生在staging环境， 为了使线上录制下来的数据能在staging环境回放，我们开发了MOCK能力。</p><p><strong>MOCK能力扩大了流量回放的使用场景</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949653.png" alt="img"></p><p><strong>MOCK配置能力</strong></p><p>很多情况下， 因为线上线下的环境差异、参数随机性等因素， 即使有了基本的mock能力，线上的数据也不能在线下自如使用。例如以下场景</p><ul><li><p>分库分表场景。线上一般为会分库分表， 线下一般为单表，回放过程中会因为表名不同而无法匹配到MOCK数据。</p></li><li><ul><li>redis、memcached也存在类似问题</li></ul></li><li><p>随机数（噪音）问题。例如时间戳是在调用发起时生成，每次都不同， MOCK时需要忽略。</p></li><li><p>mock组件范围限定。 只mock选定的几个中间件，其余中间件访问真是服务。</p></li><li><p>mock数据范围限定。 对于同类组件的mock， 只mock一定范围的数据， 例如mysql, 只mock固定的几张表</p></li><li><p>降噪范围限定。 只对固定的表降噪</p></li><li><p>动作MOCK限定。 例如至mock update 和insert的操作， select 选择性放行。</p></li><li><p>等等</p></li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949683.png" alt="img"></p><p>MOCK组件配置示例：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949771.png" alt="img"></p><p>MYSQL MOCK规则配置示例：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950101.png" alt="img"></p><h3 id="3-2-2-回放流程"><a href="#3-2-2-回放流程" class="headerlink" title="3.2.2 回放流程"></a><strong>3.2.2 回放流程</strong></h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949698.png" alt="img"></p><h3 id="3-2-3-回放功能"><a href="#3-2-3-回放功能" class="headerlink" title="3.2.3 回放功能"></a><strong>3.2.3 回放功能</strong></h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950153.png" alt="img"></p><h3 id="3-2-4-回放执行流程"><a href="#3-2-4-回放执行流程" class="headerlink" title="3.2.4  回放执行流程"></a><strong>3.2.4  回放执行流程</strong></h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193949765.png" alt="img"></p><h2 id="3-3-流量Diff"><a href="#3-3-流量Diff" class="headerlink" title="3.3 流量Diff"></a><strong>3.3 流量Diff</strong></h2><p>流量回放之后，对比返回值是我们发现被测代码是否存在BUG的主要手段， 因此在DIFF返回上，我们开发了大量的功能， 期望能满足各个业务方不同的Diff需求。 常用的主要是以下三种diff能力</p><ol><li><strong>Diff 报告</strong> —— 反映一次回放任务（包含多条流量）整体的Diff情况</li><li><strong>子流量Diff</strong> —— Diff一条流量的在回放过程中的中间状态</li><li><strong>单条流量文本Diff</strong> —— 用于调试diff策略或者排查单条流量的回放情况</li></ol><h3 id="3-3-1-Diff报告"><a href="#3-3-1-Diff报告" class="headerlink" title="3.3.1 Diff报告"></a><strong>3.3.1 Diff报告</strong></h3><p>一次回放任务通常会包含多条流量， 甚至会有数万条流量，如果一条一条去看diff结果显然不现实，因此我们参考了twitter的 Diffy，设计了Diff报告。 并且增加了<a href="https://docs.corp.kuaishou.com/k/home/VX8v5do5Oc4I/fcACIVeHe-P6p-dqnGj6TfoI3#section=h.ifjdc3ohk2z2"><strong>自定义diff策略</strong></a>、<a href="https://docs.corp.kuaishou.com/d/home/fcABxoYiFaY0Ld8YY34OBs3Sx"><strong>diff规则</strong></a>、<strong>对象下钻</strong>的能力。</p><p><strong>什么是</strong><a href="https://docs.corp.kuaishou.com/k/home/VX8v5do5Oc4I/fcACIVeHe-P6p-dqnGj6TfoI3#section=h.ifjdc3ohk2z2"><strong>diff策略</strong></a>？</p><p>一条流量通常会有上百个字段， 其中不乏包含一些噪音字段，例如timestamp、随机数等， 以及一些本次测试不需要diff的字段， 因此，我需要创建个一个diff策略来描述本次流量回放我们要对比哪些字段。</p><p><strong>什么是</strong><a href="https://docs.corp.kuaishou.com/d/home/fcABxoYiFaY0Ld8YY34OBs3Sx"><strong>diff规则</strong></a>？</p><p>对比一个字段的两个值， 我们通常除了等于这种简单的对比规则之外， 还需要大于小于、范围对比，如果是数组类型，可能还涉及到排序对比。因此我们设计了diff规则，用来支持此类情况，目前我们已经支持了19种diff规则。</p><p><strong>为什么要对象下钻？</strong></p><p>例如我们对比的内容是一个元素为对象的数组， 如果想排查问题， 我们要先下钻的数组里面去，然后再下钻到每个对象中， 再看具体是哪个基本类型的字段值不同。</p><p><em>下图展示了一个diff报告的形态， 左侧为报告整体， 右侧为每个字段的对比明细</em></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950586.png" alt="img"></p><h3 id="3-3-2-子流量diff"><a href="#3-3-2-子流量diff" class="headerlink" title="3.3.2 子流量diff"></a><strong>3.3.2 子流量diff</strong></h3><p>发现一条流量存在diff的时候， 接下来动作应该是排查这条diff为什么会存在， 常规的方法是去看日志、远程debug 或 使用kbox排查。 但如果我们能在KTraffic平台上看到这条流量的每个中间远程访问的入参与线上录制到的入参的差异，就会一定程度上帮助我们快速为问题。</p><p><em>如下图，展示一条流量的所有grpc的中间访问过程，类似的还可以查看mysql、redis等。</em></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950088.png" alt="img"></p><h3 id="3-3-3-单条流量文本diff"><a href="#3-3-3-单条流量文本diff" class="headerlink" title="3.3.3 单条流量文本diff"></a><strong>3.3.3 单条流量文本diff</strong></h3><p>只是单纯对比两条流量的response， 如下图。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230803193950240.png" alt="img"></p><h3 id="3-3-4-流量管理"><a href="#3-3-4-流量管理" class="headerlink" title="3.3.4 流量管理"></a><strong>3.3.4 流量管理</strong></h3><p>流量录制回放是一个存储高消耗的使用场景，面临较高的存储成本， 因此对于不活跃的录制回放任务，我们只存储<strong>三个月</strong>，三个月后我们会定期删除。</p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>流量录制方案梳理</title>
    <link href="/2023/08/03/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E6%96%B9%E6%A1%88%E6%A2%B3%E7%90%86/"/>
    <url>/2023/08/03/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E6%96%B9%E6%A1%88%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1-kdev流量录制回放平台建设历程"><a href="#1-kdev流量录制回放平台建设历程" class="headerlink" title="1.kdev流量录制回放平台建设历程"></a><strong>1.kdev流量录制回放平台建设历程</strong></h1><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230804105137493.png" alt="img"></p><h1 id="2-各方案架构概要"><a href="#2-各方案架构概要" class="headerlink" title="2.各方案架构概要"></a><strong>2.各方案架构概要</strong></h1><p>包括我司在内，业内主流的流量录制实现方式主要是以下三种</p><ol><li>中间件SDK硬编码（我司）</li><li>sandbox repeater (阿里)</li><li>类tcp copy方案（字节）</li></ol><h2 id="2-1-中间件sdk硬编码方案"><a href="#2-1-中间件sdk硬编码方案" class="headerlink" title="2.1 中间件sdk硬编码方案"></a><strong>2.1 中间件sdk硬编码方案</strong></h2><p>录制动作硬编码在client sdk中， 与业务服务共享同一进程。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230804105137476.png" alt="img"></p><h2 id="2-2-采用sandbox-repeater-方案"><a href="#2-2-采用sandbox-repeater-方案" class="headerlink" title="2.2 采用sandbox repeater 方案"></a><strong>2.2 采用sandbox repeater 方案</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230804105137495.png" alt="img"></p><h2 id="2-3-类tcp-copy方案"><a href="#2-3-类tcp-copy方案" class="headerlink" title="2.3 类tcp copy方案"></a><strong>2.3 类tcp copy方案</strong></h2><p>字节bytecopy</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230804105137477.png" alt="img"></p><h1 id="3-录制方案之间优劣势对比"><a href="#3-录制方案之间优劣势对比" class="headerlink" title="3.录制方案之间优劣势对比"></a><strong>3.录制方案之间优劣势对比</strong></h1><table><thead><tr><th><strong>能力方面</strong></th><th><strong>中间件SDK  硬编码（我司当前使用）</strong></th><th><strong>sandbox repeater</strong><strong>(阿里doom)</strong></th><th><strong>自研类tcp copy的网络层捕获方案****（字节bytecopy）</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>基本原理</strong></td><td>基于统一的中间件sdk</td><td>基于字节码增强</td><td>旁路复制网络包</td><td></td></tr><tr><td><strong>性能影响–开启录制</strong></td><td><strong>优：</strong>取决于被录制服务流量多少以及采样率</td><td><strong>优</strong>：取决于被录制服务流量多少以及采样率</td><td><strong>差：</strong> 会出现额外性能开销，原因在于：tcp copy在网络第四层进行录制，难以识别流量属于哪个接口以及哪种协议，这样会导致该进程下的所有tcp流量都会被录制需要有小流量环境</td><td>关于传出层流量的解析：如果想要实现针对协议、接口进行录制，我们需要将流量解析到应用层，解析复杂度随着协议种类增加而增加，例如http2.0的多路复用， 就难以区分req和resp针对api进行录制同样存在解析难度进而采样也不容易实现</td></tr><tr><td><strong>性能影响–不开启录制</strong></td><td><strong>优：****有极小影响</strong>（仅一个配置判断）</td><td><strong>优：</strong>无影响</td><td><strong>优：</strong>无影响</td><td></td></tr><tr><td><strong>稳定性影响（非性能类）</strong></td><td><strong>良：****有影响，</strong> 具体如下：sdk的正常流程会执行录制代码开发过程中，流量录制逻辑与sdk本身逻辑互相耦合</td><td><strong>良：****有影响</strong>，具体如下：在开启录制的情况下，录制代码编译成字节码后会增强到sdk代码中，会在同一线程中被执行。因sdk与录制代码完全解耦，开发过程中可能存在不同步的情况。例如sdk增加了某个功能，录制代码却没有增加，导致插桩不符合预期。需要有标准小流量环境</td><td><strong>优：</strong>无影响</td><td>sandbox与sdk硬编码对于被录服务的稳定性影响各有优劣，<strong>总体看来两者差异不大，而旁路录制则优势明显</strong></td></tr><tr><td><strong>代码可控性</strong></td><td>**优:**sdk维护人与录制代码维护人为相同团队，更熟悉代码逻辑</td><td><strong>良：</strong>sdk维护人与录制代码维护人为不同团队，开发风险相对稍高例如关于kconf 、kswitch的录制需要了解其使用场景。</td><td><strong>优：</strong>在性能符合预期的情况下，不存在代码代码可控性问题</td><td></td></tr><tr><td><strong>录制数据完整性</strong></td><td><strong>良：</strong>只能支持固定协议</td><td><strong>优：</strong>能支持所有协议且能只会任意方法</td><td><strong>差：</strong>对于没有网络请求的动作，不支持录制，例如kconf</td><td></td></tr><tr><td><strong>录制语言支持</strong></td><td><strong>优</strong>支持我司主流语言java和c++</td><td><strong>差：</strong>只支持java</td><td><strong>优</strong>支持所有语言</td><td></td></tr><tr><td><strong>业务方接入成本</strong></td><td><strong>优：</strong>基于root pom升级，仅重新编译部署即可</td><td><strong>优：但需要解决以下前提</strong>当前公司的基础设施没有在生产环境批量部署sandbox agent的能力生产环境是否允许使用sandbox agent需要确认，之前是不允许（如果2允许，1可以推动建设）</td><td><strong>优：需要解决以下前提</strong>公司基础设施支持在生产环境指定机器范围批量部署tcpcopy-agent,</td><td>tcpcopy和sandbox需要的基础设施建设成本比较高， 可能会需要单独设计一套小流量环境， 并在公司范围内推广使用规范。</td></tr><tr><td><strong>功能迭代速度</strong>（例如支持一种新的协议）</td><td><strong>差：</strong>牵涉团队过多，且各团队OKR不一致，沟通推动成本极高</td><td><strong>优：</strong></td><td><strong>优：</strong></td><td>tcpcopy与sandbox在基础设置完善的情况下，</td></tr></tbody></table><p>（滴滴的sharingan是基于语言标准库拦截，且不支持java和c++，因此不在考虑范围之内)</p><h1 id="4-升级成本"><a href="#4-升级成本" class="headerlink" title="4.升级成本"></a><strong>4.升级成本</strong></h1><ol><li><strong>全部录制逻辑需要重写，</strong>包括所有中间件的录制协议</li><li><strong>基础需要设施升级</strong>，无论采用sandbox repeater 还是 tcp copy都需升级基础设施， 在当前的环境下，推动升级难度较大</li><li><strong>业务方存在迁移成本</strong>，难以做到无缝迁移，例如至少业务方需要在使用流量录制回放的机器上增加环境变量，或修改流水线。</li></ol>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM sandbox原理和应用</title>
    <link href="/2023/08/02/java/java%E5%9F%BA%E7%A1%80/JVM-sandbox%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <url>/2023/08/02/java/java%E5%9F%BA%E7%A1%80/JVM-sandbox%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在开始之前，我们先来模拟一下以下的场景：</p><p>小李：“小明，你的接口没有返回数据，麻烦帮忙看一下？”</p><p>小明：“我这边的数据也是从别人的服务器中拿到的，但是我不确定是因为逻辑处理有问题导致没有结果，还是因为我依赖的服务有问题而没有返回结果，我需要确认一下。”</p><p>小明：“哎呀，线上没有日志，我需要加个日志上个线。”</p><p>30 分钟之后……</p><p>小明：“不好意思，日志加错地方了……稍等……”</p><p>接来下隆重登场的就是本文的主角 JVM SandBox 了。基于 JVM SandBox，我们可以很容易地做到在不重新部署应用的情况下，给指定的某些类的某些方法加上日志功能。当然，动态加日志仅仅是 JVM SandBox 可以应用的一个小小的场景，JVM SandBox 的威力远不在于此。那么，JVM SandBox 是什么？JVM SandBox 从哪里来？JVM SandBox 怎么用？本文在第二章会回答这几个问题，如果你跟我一样对 JVM SandBox 的底层实现原理感兴趣，特别是 JVM 相关部分，那么第三章有相关的内容；如果你只想了解 JVM SandBox 自身具有哪些特性，以及 JVM SandBox 是如何设计实现的，那么可以跳过第三章，直接阅读第四章；最后，在第五章会简单地介绍其他两个可以应用 JVM SandBox 的场景。</p><h2 id="二、JVM-SandBox-简介"><a href="#二、JVM-SandBox-简介" class="headerlink" title="二、JVM SandBox 简介"></a>二、JVM SandBox 简介</h2><h3 id="2-1-AOP"><a href="#2-1-AOP" class="headerlink" title="2.1 AOP"></a>2.1 AOP</h3><p>在介绍 JVM SandBox 之前，我们先来回顾一下 AOP 技术。</p><p>AOP（面向切面编程，Aspect Oriented Programming）技术已被业界广泛应用，其思想是面向业务处理过程的某个步骤或阶段进行编程，这个步骤或阶段被称为切面，其目的是降低业务逻辑的各部分之间的耦合，常见的 AOP 实现基本原理有两种：代理和行为注入。</p><p><strong>1）代理模式</strong></p><p>在代理模式下，我们会创建一个代理对象来代理原对象的行为，代理对象拥有原对象行为执行的控制权，在这种模式下，我们基于代理对象在原对象行为执行的前后插入代码来实现 AOP。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-bb0029db289737ca786cf11c2677811c.png"></p><p>图 2-1 代理模式</p><p><strong>2）行为注入模式</strong></p><p>在行为注入模式下，我们不会创建一个新的对象，而是修改原对象，在原对象行为的执行前后注入代码来实现 AOP。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-325e7b5209ed2ea9105d9ff20e9e1b0b.png"></p><p>图 2-2 行为注入模式</p><h3 id="2-2-JVM-SandBox"><a href="#2-2-JVM-SandBox" class="headerlink" title="2.2 JVM SandBox"></a>2.2 JVM SandBox</h3><p>JVM SandBox 是阿里开源的一款 JVM 平台非侵入式运行期 AOP 解决方案，本质上是一种 AOP 落地形式。那么可能有同学会问：已有成熟的 Spring AOP 解决方案，阿里巴巴为什么还要“重复造轮子”？这个问题要回到 JVM SandBox 诞生的背景中来回答。在 2016 年中，天猫双十一催动了阿里巴巴内部大量业务系统的改动，恰逢徐冬晨（阿里巴巴测试开发专家）所在的团队调整，测试资源保障严重不足，迫使他们必须考虑更精准、更便捷的老业务测试回归验证方案。开发团队面临的是新接手的老系统，老的业务代码架构难以满足可测性的要求，很多现有测试框架也无法应用到老的业务系统架构中，于是需要新的测试思路和测试框架。</p><p>为什么不采用 Spring AOP 方案呢？Spring AOP 方案的痛点在于不是所有业务代码都托管在 Spring 容器中，而且更底层的中间件代码、三方包代码无法纳入到回归测试范围，更糟糕的是测试框架会引入自身所依赖的类库，经常与业务代码的类库产生冲突，因此，JVM SandBox 应运而生。</p><p>JVM SandBox 本身是基于插件化的设计思想，允许用于以“模块”的方式基于 JVM SandBox 提供的 AOP 能力开发新的功能。基于 JVM SandBox，我们不需要关心如何在 JVM 层实现 AOP 的技术细节，只需要通过 JVM SandBox 提供的编程结构告诉“沙箱”，我们希望对哪些类哪些方法进行 AOP，在切面点做什么即可，JVM SandBox 模块功能编写起来非常简单。下面是一个示例模块代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs plain">@MetaInfServices(Module.class)  <br>@Information(id = &quot;my-sandbox-module&quot;)//模块名  <br>public class MySandBoxModule implements Module &#123;  <br>    private Logger LOG = Logger.getLogger(MySandBoxModule.class.getName());  <br>    @Resource  <br>    private ModuleEventWatcher moduleEventWatcher;  <br>  <br>    @Command(&quot;addLog&quot;)//模块命令名  <br>    public void addLog() &#123;  <br>        new EventWatchBuilder(moduleEventWatcher)  <br>                .onClass(&quot;com.float.lu.DealGroupService&quot;)//想要对DealGroupService这个类进行切面  <br>                .onBehavior(&quot;loadDealGroup&quot;)//想要对上面类的loadDealGroup方法进行切面  <br>                .onWatch(new AdviceListener() &#123;  <br>                    @Override  <br>                    protected void before(Advice advice) throws Throwable &#123;  <br>                        LOG.info(&quot;方法名: &quot; + advice.getBehavior().getName());//在方法执行前打印方法的名字  <br>                    &#125;  <br>                &#125;);  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>如上面代码所示，通过简单常规的编码即可实现对某个类的某个方法进行切面，不需要对底层技术有了解即可上手。上面的模块被 JVM SandBox 加载和初始化之后便可以被使用了。比如，只需要告诉 JVM SandBox 我们要执行 my-sandbox-module 这个模块的 addLog 这个方法，我们编写的功能的调用就会被注入到目标地方。</p><p>JVM SandBox 使用起来非常很简单，但是 JVM SandBox 背后所涉及到的底层技术原理、实现细节却不简单，比如 Java Agent、Attach、JVMTI、Instrument、Class 字节码修改、ClassLoader、代码锁、事件驱动设计等等。如果要深究可能要究几本书，但这不是本文的目的。本文仅仅概括性地介绍 JVM SandBox 实现涉及到的一些核心技术点，力求通过本文可以回答如 JVMTI 是什么？Instrument 是什么？Java Agent 是什么？它们之间有什么关系？他们和 JVM SandBox 又是什么关系等问题。</p><h2 id="三、JVM-核心技术"><a href="#三、JVM-核心技术" class="headerlink" title="三、JVM 核心技术"></a>三、JVM 核心技术</h2><h3 id="3-1-Java-Agent"><a href="#3-1-Java-Agent" class="headerlink" title="3.1 Java Agent"></a>3.1 Java Agent</h3><p>JVM SandBox 容器的启动依赖 Java Agent，Java Agent（Java 代理）是 JDK 1.5 之后引入的技术。开发一个 Java Agent 有两种方式，一种是实现一个 premain 方法，但是这种方式实现的 Java Agent 只能在 JVM 启动的时候被加载；另一种是实现一个 agentmain 方法，这种方式实现的 Java Agent 可以在 JVM 启动之后被加载。当然，两种实现方法各有利弊、各有适用场景，这里不再过多介绍，JVM SandBox Agent 对于这两种方式都有实现，用户可以自行选择使用，因为在 JVM 层这两种方式底层的实现原理大同小异，因此本文只选择 agentmain 方式进行介绍，下文的脉络也仅跟 agentmain 方式相关。下面先通过两行代码，来看看基于 agentmain 方式实现的 Java Agent 是如何被加载的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">VirtualMachine vmObj = VirtualMachine.attach(targetJvmPid);//targetJvmPid为目标JVM的进程ID  <br>vmObj.loadAgent(agentJarPath, cfg);  // agentJarPath为agent jar包的路径，cfg为传递给agent的参数  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>在 Java Agent 被加载之后，JVM 会调用 Java Agent JAR 包中的 MANIFEST.MF 文件中的 Agent-Class 参数指定的类中的 agentmain 方法。下面两节会对这两行代码的背后 JVM 实现技术进行探究。</p><h3 id="3-2-Attach"><a href="#3-2-Attach" class="headerlink" title="3.2 Attach"></a>3.2 Attach</h3><p><strong>1）Attach 工作机制</strong></p><p>上面一节中第一行代码的背后，有一个重要的 JVM 支撑机制——Attach，为什么说重要？比如大家最熟悉的 jstack 就是要依赖这个机制来工作，那么，Attach 机制是什么呢？我们先来看看 Attach 机制都做了什么事儿。首先，Attach 机制对外提供了一种进程间的通信能力，能让一个进程传递命令给 JVM；其次，Attach 机制内置一些重要功能，可供外部进程调用。比如刚刚提到的 jstack，再比如上一节中提到的第二行代码：vmObj.loadAgent(agentJarPath, cfg); 这行代码实际上就是告诉 JVM 我们希望执行 load 命令，下面的代码片段可以更直观地看到 load 命令对应的行为是：JvmtiExport::load_agent_library，这行代码的行为是对 agentJarPath 指定的 Java Agent 进行加载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源:attachListener.cpp  <br>static AttachOperationFunctionInfo funcs[] = &#123;  <br>  &#123; &quot;agentProperties&quot;,  get_agent_properties &#125;,  <br>  &#123; &quot;datadump&quot;,         data_dump &#125;,  <br>  &#123; &quot;dumpheap&quot;,         dump_heap &#125;,  <br>  &#123; &quot;load&quot;,             JvmtiExport::load_agent_library &#125;,  <br>  &#123; &quot;properties&quot;,       get_system_properties &#125;,  <br>  &#123; &quot;threaddump&quot;,       thread_dump &#125;,  <br>  &#123; &quot;inspectheap&quot;,      heap_inspection &#125;,  <br>  &#123; &quot;setflag&quot;,          set_flag &#125;,  <br>  &#123; &quot;printflag&quot;,        print_flag &#125;,  <br>  &#123; &quot;jcmd&quot;,             jcmd &#125;,  <br>  &#123; NULL,               NULL &#125;  <br>&#125;;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>那么，JVM Attach 机制是如何工作的呢？Attach 机制的核心组件是 Attach Listener，顾名思义，Attach Listener 是 JVM 内部的一个线程，这个线程的主要工作是监听和接收客户端进程通过 Attach 提供的通信机制发起的命令，如下图所示：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-f850866f1fc03ad3b3eafdf97ec54b57.png"></p><p>图 3-1 Attach Listener 工作机制</p><p>Attach Listener 线程的主要工作是串流程，流程步骤包括：接收客户端命令、解析命令、查找命令执行器、执行命令等等，下面附上相关代码片段：</p><p>片段一：AttachListener::init（启动 AttachListener 线程）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源:attachListener.cpp  <br>&#123; MutexLocker mu(Threads_lock);  <br>    // 启动线程  <br>    JavaThread* listener_thread = new JavaThread(&amp;attach_listener_thread_entry);  <br>    // Check that thread and osthread were created  <br>    if (listener_thread == NULL || listener_thread-&gt;osthread() == NULL) &#123;  <br>      vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,  <br>                                    &quot;unable to create new native thread&quot;);  <br>    &#125;  <br>    java_lang_Thread::set_thread(thread_oop(), listener_thread);  <br>    java_lang_Thread::set_daemon(thread_oop());  <br>  <br>    listener_thread-&gt;set_threadObj(thread_oop());  <br>    Threads::add(listener_thread);  <br>    Thread::start(listener_thread);  <br>  &#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>片段二：attach_listener_thread_entry（轮询队列）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源:attachListener.cpp  <br>static void attach_listener_thread_entry(JavaThread* thread, TRAPS) &#123;  <br>  os::set_priority(thread, NearMaxPriority);  <br>  <br>  thread-&gt;record_stack_base_and_size();  <br>  <br>  if (AttachListener::pd_init() != 0) &#123;  <br>    return;  <br>  &#125;  <br>  AttachListener::set_initialized();  <br>  for (;;) &#123;  <br>    AttachOperation* op = AttachListener::dequeue();// 展开  <br>    if (op == NULL) &#123;  <br>      return;   // dequeue failed or shutdown  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>片段三：dequeue（读取客户端 socket 内容）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源:attachListener_bsd.cpp  <br>BsdAttachOperation* BsdAttachListener::dequeue() &#123;  <br>  for (;;) &#123;  <br>    int s;  <br>    // wait for client to connect  <br>    struct sockaddr addr;  <br>    socklen_t len = sizeof(addr);  <br>    RESTARTABLE(::accept(listener(), &amp;addr, &amp;len), s);  <br>    if (s == -1) &#123;  <br>      return NULL;      // log a warning?  <br>    &#125;  <br>    // 省略……  <br>    // peer credential look okay so we read the request  <br>    BsdAttachOperation* op = read_request(s);  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p><strong>2）加载 Agent</strong></p><p>回到上层，我们再看看 vmObj.loadAgent(agentJarPath, cfg)；这行 Java 代码代码是如何工作的？其实，这行代码背后主要做了一件事情：告诉 Attach 加载 instrument 库，instrument 库又是什么？instrument 库是基于 JVMTI 编程接口编写的一个 JVMTI Agent，其表现形式是一个动态链接库，下面上两个代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：HotSpotVirtualMachine.java  <br>//片段1  <br>loadAgentLibrary(&quot;instrument&quot;, args);  <br>//片段2   <br>InputStream in = execute(&quot;load&quot;,  <br>                                 agentLibrary,  <br>                                 isAbsolute ? &quot;true&quot; : &quot;false&quot;,  <br>                                 options);  <br><br></code></pre></td></tr></table></figure><p>复制代码</p><p>Attach 接收到命令之后执行 load_agent_library 方法，主要做两件事情：1）加载 instrument 动态库；2）找到 instrument 动态库中实现的 Agent_OnAttach 方法并调用。Attach 的工作到这里就结束了，至于 Agent_OnAttach 这个方法做了什么事情，我们会在 JVMTI 部分进行介绍。下面先解释 Attach 相关的另外一个问题，Attach Listener 并不是在 JVM 启动的时候被启动的，而是基于一种懒启动策略实现。</p><p><strong>3）Attach Listener 懒启动</strong></p><p>为方便理解下面引入代码片段，这是从 JVM 启动路径上截取的两片代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源:thread.cpp  <br>// 片段1  <br>  os::signal_init();  <br>  if (!DisableAttachMechanism) &#123;  <br>    AttachListener::vm_start();  <br>    if (StartAttachListener || AttachListener::init_at_startup()) &#123;  <br>      AttachListener::init();  <br>    &#125;  <br>  &#125;  <br>// 片段2  <br>bool AttachListener::init_at_startup() &#123;  <br>  if (ReduceSignalUsage) &#123;  <br>    return true;  <br>  &#125; else &#123;  <br>    return false;  <br>  &#125;  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>复制代码</p><p>DisableAttachMechanism 这个参数默认是关闭的，也就是说 JVM 默认情况下启用 Attach 机制，但是 StartAttachListener 和 ReduceSignalUsage 这两个参数默认都是关闭的，因此 Attach Listener 线程默认并不会被初始化。那么 Attach Listener 线程是在什么时候被初始化的呢？这就有必要了解一下 Signal Dispatcher 组件了，Signal Dispatcher 本质上也是 JVM 提供的一种进程间通信机制，只是这种机制是基于信号量来实现的。</p><p>我们先从 Signal Dispatcher 的服务端角度，来看看 Signal Dispatcher 是如何工作的，不知道大家有没有注意到上面的 os::signal_init()；这么一行代码，其作用是初始化和启动 Signal Dispatcher 线程，Signal Dispatcher 线程启动之后就会进入等待信号状态（os::signal_wait）。如下代码片段所示，SIGBREAK 信号是 SIGQUIT 信号的别名，Signal Dispatcher 接收到这个信号之后会调用 AttachListener 的 is_init_trigger 的方法初始化和启动 AttachListener 线程，同时会在 tmp 目录下面创建&#x2F;tmp&#x2F;.attach_pid${pid}这样的一个文件，代表进程号为 pid 的 JVM 已经初始化了 AttachListener 组件了。</p><p>片段一：os::signal_init();（启动 Signal Dispatcher 线程）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：os.cpp  <br>&#123; MutexLocker mu(Threads_lock);  <br>      JavaThread* signal_thread = new JavaThread(&amp;signal_thread_entry);//展开  <br>      if (signal_thread == NULL || signal_thread-&gt;osthread() == NULL) &#123;  <br>        vm_exit_during_initialization(&quot;java.lang.OutOfMemoryError&quot;,  <br>                                      &quot;unable to create new native thread&quot;);  <br>      &#125;  <br>      java_lang_Thread::set_thread(thread_oop(), signal_thread);  <br>      java_lang_Thread::set_priority(thread_oop(), NearMaxPriority);  <br>      java_lang_Thread::set_daemon(thread_oop());  <br>  <br>      signal_thread-&gt;set_threadObj(thread_oop());  <br>      Threads::add(signal_thread);  <br>      Thread::start(signal_thread);  <br>    &#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>片段二：signal_thread_entry（监听信号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：os.cpp  <br>static void signal_thread_entry(JavaThread* thread, TRAPS) &#123;  <br>  os::set_priority(thread, NearMaxPriority);  <br>  while (true) &#123;  <br>    int sig;  <br>    &#123;  <br>      sig = os::signal_wait();  <br>    &#125;  <br>    switch (sig) &#123;  <br>      case SIGBREAK: &#123;  <br>        // Check if the signal is a trigger to start the Attach Listener - in that  <br>        // case don&#x27;t print stack traces.  <br>        if (!DisableAttachMechanism &amp;&amp; AttachListener::is_init_trigger()) &#123;//展开  <br>          continue;  <br>        &#125;  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>片段三：is_init_trigger（启动 AttachListener）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：attachListener_bsd.cpp  <br>bool AttachListener::is_init_trigger() &#123;  <br>  char path[PATH_MAX + 1];  <br>  int ret;  <br>  struct stat st;  <br>  snprintf(path, PATH_MAX + 1, &quot;%s/.attach_pid%d&quot;,os::get_temp_directory(), os::current_process_id());  <br>  RESTARTABLE(::stat(path, &amp;st), ret);  <br>  if (ret == 0) &#123;  <br>    if (st.st_uid == geteuid()) &#123;  <br>      init();//初始化Attach Listener  <br>      return true;  <br>    &#125;  <br>  &#125;  <br>  return false;  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>复制代码</p><p>我们再从客户端角度，来看看客户端是如何通过 Signal Dispatcher 来启动 AttachListener 线程的，这要又要回到 VirtualMachine.attach(pid)这行代码，这行代码的背后会执行具体 VirtualMachine 的初始化工作，我们拿 Linux 平台下的 LinuxVirtualMachine 实现来看，下面是 LinuxVirtualMachine 初始化的核心代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：LinuxVirtualMachine.java  <br>//检查目标JVM对否存在标识文件  <br>path = findSocketFile(pid);  <br>if (path == null) &#123;  <br>  File f = createAttachFile(pid);  <br>  try &#123;  <br>    mpid = getLinuxThreadsManager(pid);  <br>    sendQuitToChildrenOf(mpid);  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>上面提到目标 JVM 一旦启动 attach 组件之后，会在&#x2F;tmp 目录下创建名为.java_pid${pid}的文件。因此，客户端在每次初始化 LinuxVirtualMachine 对象的时候，会先查看目标 JVM 的这个文件是否存在，如果不存在则需要通过 SIGQUIT 信号来将 attach 组件拉起来。具体操作是进入 try 区域后，找到指定 pid 进程的父进程（Linux 平台下线程是通过进程实现的），给父进程的所有子进程都发送一个 SIGQUIT 信号，而 Signal Dispatcher 组件恰好在监听这个信号。</p><h3 id="3-3-JVMTI"><a href="#3-3-JVMTI" class="headerlink" title="3.3 JVMTI"></a>3.3 JVMTI</h3><p>JVMTI(Java Virtual Machine Tool Interface)是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 是从 Java SE 5 开始引入，整合和取代了以前使用的 Java Virtual Machine Profiler Interface (JVMPI) 和 the Java Virtual Machine Debug Interface (JVMDI)，而在 Java SE 6 中，JVMPI 和 JVMDI 已经消失了。JVMTI 提供了一套“代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。JVMTI 的功能非常丰富，包括虚拟机中线程、内存&#x2F;堆&#x2F;栈，类&#x2F;方法&#x2F;变量，事件&#x2F;定时器处理等等。使用 JVMTI 一个基本的方式就是设置回调函数，在某些事件发生的时候触发并作出相应的动作，这些事件包括虚拟机初始化、开始运行、结束，类的加载，方法出入，线程始末等等。如果想对这些事件进行处理，需要首先为该事件写一个函数，然后在 jvmtiEventCallbacks 这个结构中指定相应的函数指针。</p><p>上面提到的 Instrument 就是一个基于 JVMTI 接口的，以代理方式连接和访问 JVM 的一个 Agent，Instrument 库被加载之后 JVM 会调用其 Agent_OnAttach 方法，如下代码片段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源：InvocationAdapter.c  <br>//片段1：创建Instrument对象  <br>success = createInstrumentationImpl(jni_env, agent);  <br>//片段2：监听ClassFileLoadHook事件并设置回调函数为eventHandlerClassFileLoadHook  <br>callbacks.ClassFileLoadHook = &amp;eventHandlerClassFileLoadHook;  <br>jvmtierror = (*jvmtienv)-&gt;SetEventCallbacks(jvmtienv, &amp;callbacks, sizeof(callbacks));  <br>//片段3：调用java类的agentmain方法  <br>success = startJavaAgent(agent, jni_env, agentClass, options, agent-&gt;mAgentmainCaller); <br></code></pre></td></tr></table></figure><p>复制代码</p><p>Agent_OnAttach 方法被调用的时候主要做了几件事情：1）创建 Instrument 对象，这个对象就是 Java Agent 中通过 agentmain 方法拿到的 Instrument 对象；2）通过 JVMTI 监听 JVM 的 ClassFileLoadHook 事件并设置回调函数 eventHandlerClassFileLoadHook；3）调用 Java Agent 的 agentmain 方法，并将第 1）步创建的 Instrument 对象传入。通过上面的内容可以知道，在 JVM 进行类加载的都会回调 eventHandlerClassFileLoadHook 方法，我们可以猜到 eventHandlerClassFileLoadHook 方法做的事情就是调用 Java Agent 内部传入的 Instrument 的 ClassFileTransformer 的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源Instrumentation.java  <br>void addTransformer(ClassFileTransformer transformer);  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>通过 JVMTI 的事件回调机制，Instrument 可以捕捉到每个类的加载事件，从而调用用户实现的 ClassFileTransformer 来对类进行转换，那么已经被加载的类怎么办呢？为解决这个问题，Instrument 提供了 retransformClasses 接口用于对已经加载的类进行转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">//来源Instrumentation.java  <br>void retransformClasses(Class&lt;?&gt;... classes) throws UnmodifiableClassException;<br></code></pre></td></tr></table></figure><p>复制代码</p><p>Instrument 底层的实现实际上也是调用 JVMTI 提供的 RetransformClasses 接口，RetransformClasses 实现对已经加载的类进行重新定义（redefine），而重新定义类也会触发 ClassFileLoadHook 事件，Instrument 同样会监听到这个事件并对被加载的类进行处理。到这里，JVM SandBox 底层依赖 JVM 的核心机制已经介绍完了，下面通过一张时序图将一个 JavaAgent 的加载过程涉及到的相关组件及行为串起来：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-4e5bba9090208c6bba5672ec30f5902e.png"></p><p>图 3-2 Java Agent 加载流程</p><h2 id="四、JVM-SandBox-设计与实现"><a href="#四、JVM-SandBox-设计与实现" class="headerlink" title="四、JVM SandBox 设计与实现"></a>四、JVM SandBox 设计与实现</h2><h3 id="4-1-可插拔"><a href="#4-1-可插拔" class="headerlink" title="4.1 可插拔"></a>4.1 可插拔</h3><p>本文理解的 JVM SandBox 可插拔至少有两层含义：一层是 JVM 沙箱本身是可以被插拔的，可被动态地挂载到指定 JVM 进程上和可以被动态地卸载；另一层是 JVM 沙箱内部的模块是可以被插拔的，在沙箱启动期间，被加载的模块可以被动态地启用和卸载。</p><p>一个典型的沙箱使用流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">$./sandbox.sh -p 33342 #将沙箱挂载到进程号为33342的JVM进程上  <br>$./sandbox.sh -p 33342 -d &#x27;my-sandbox-module/addLog&#x27; #运行指定模块, 模块功能生效  <br>$./sandbox.sh -p 33342 -S #卸载沙箱  <br></code></pre></td></tr></table></figure><p>复制代码</p><p>JVM 沙箱可以被动态地挂载到某个正在运行的目标 JVM 进程之上（前提是目标 JVM 没有禁止 attach 功能），沙箱工作完之后还可以被动态地从目标 JVM 进程卸载掉，沙箱被卸载之后，沙箱对对目标 JVM 进程产生的影响会随即消失（这是沙箱的一个重要特性），沙箱工作示意图如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-32faa51603df23a30d0503493878b31b.png"></p><p>图 4-1 沙箱工作示意图</p><p>客户端通过 Attach 将沙箱挂载到目标 JVM 进程上，沙箱的启动实际上是依赖 Java Agent，上文已经介绍过，启动之后沙箱会一直维护着 Instrument 对象引用，在沙箱中 Instrument 对象是一个非常重要的角色，它是沙箱访问和操作 JVM 的唯一通道，后续修改字节码和重定义类都要经过 Instrument。另外，沙箱启动之后同时会启动一个内部的 Jetty 服务器，这个服务器用于外部进程和沙箱进行通信，上面看到的.&#x2F;sandbox.sh -p 33342 -d ‘my-sandbox-module&#x2F;addLog’ 这行代码，实际上就是通过 HTTP 协议来告诉沙箱执行 my-sanbox-module 这个模块的 addLog 这个功能的。</p><h3 id="4-2-无侵入"><a href="#4-2-无侵入" class="headerlink" title="4.2 无侵入"></a>4.2 无侵入</h3><p>沙箱内部定义了一个 Spy 类，该类被称为“间谍类”，所有的沙箱模块功能都会通过这个间谍类驱动执行。下面给出一张示意图将业务代码、间谍类和模块代码串起来来帮助理解：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-b5bb7c654f3cc4a2e25a80e569019e81.png"></p><p>图 4-2 沙箱无侵入核心实现</p><p>上图是沙箱 AOP 核心实现的伪代码，实际实现会比上图更复杂一些，沙箱内部通过修改和重定义业务类来实现上述功能的。在接口设计方面，沙箱通过事件驱动的方式，让模块开发者可以监听到方法执行的某个事件并设置回调逻辑，这一切都可以通过实现 AdviceListener 接口来做到，通过 AdviceListener 接口定义的行为，我们可以了解沙箱支持的监听事件如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-45313ec06eaf196a7b60c3d26f8fa57c.png"></p><h3 id="4-3-隔离"><a href="#4-3-隔离" class="headerlink" title="4.3 隔离"></a>4.3 隔离</h3><p>JVM 沙箱有自己的工作代码类，而这些代码类在沙箱被挂在到目标 JVM 之后，其涉及到的相关功能实现类都要被加载到目标 JVM 中，沙箱代码和业务代码共享 JVM 进程，这里有两个问题：1）如何避免沙箱代码和业务代码之间产生冲突；2）如何避免不同沙箱模块之间的代码产生冲突。为解决这两个问题，JVM SandBox 定义了自己的类加载器，严格控制类的加载，沙箱的核心类加载器有两个：SandBoxClassLoader 和 ModuleJarClassLoader。SandBoxClassLoader 用于加载沙箱自身的工作类，ModuleJarClassLoader 用于加载三方自己开发的模块功能类，如上面的 MySandBoxModule 类。在沙箱中类加载器继承关系如下图所示：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-e535b7a578691852256b98115257cf84.png"></p><p>图 4-3 沙箱类加载器继承体系</p><p>通过类加载器，沙箱将沙箱代码和业务代码以及不同沙箱模块之间的代码隔离开来。</p><h3 id="4-4-多租户"><a href="#4-4-多租户" class="headerlink" title="4.4 多租户"></a>4.4 多租户</h3><p>JVM 沙箱提供的隔离机制也有两层含义，一层是沙箱容器和业务代码之间隔离以及沙箱内部模块之间隔离；另一层是不同用户的沙箱之间的隔离，这一层隔离用来支持多租户特性，也就是支持多个用户对同一个 JVM 同时使用沙箱功能且他们之间互不影响。沙箱的这种机制是通过支持创建多个 SandBoxClassLoader 的方式来实现的，每个 SandBoxClassLoader 关联唯一一个命名空间（namespace）用于标识不同的用户，示意图如下所示：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-cf7acf83600b2cfeaa24d61ddf3821d1.png"></p><p>图 4-4 多租户实现示意图</p><h2 id="五、JVM-Sandbox-应用场景分析"><a href="#五、JVM-Sandbox-应用场景分析" class="headerlink" title="五、JVM Sandbox 应用场景分析"></a>五、JVM Sandbox 应用场景分析</h2><p>JVM SandBox 让动态无侵入地对业务代码进行 AOP 这个事情实现起来非常容易，但是这个事情做起来非常容易只是前提条件，更重要的是我们基于 JVM SandBox 能做什么？可以做的很多，比如：故障模拟、动态黑名单，动态日志、动态开关、系统流控、热修复，方法请求录制和结果回放、动态去依赖、依赖超时时间动态修改、甚至是修改 JDK 基础类的功能等等，当然不限于此，这里大家可以打开脑洞，天马行空地思考一下，下面再给出两个 JVM SandBox 应用场景的实现思路。</p><h3 id="5-1-故障模拟"><a href="#5-1-故障模拟" class="headerlink" title="5.1 故障模拟"></a>5.1 故障模拟</h3><p>我们可以开发一个沙箱模块，通过和前台页面的交互，我们可以对任意业务类的任意方法注入故障来达到故障模拟的效果，用户交互示意图如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-7b72ac371c69d14ef20f4752769dcd44.png"></p><p>图 5-1 故障模拟交互示意图</p><p>用户通过简单的界面操作即可完成故障注入，应用代码不需要提前埋点。</p><h3 id="5-2-动态黑名单"><a href="#5-2-动态黑名单" class="headerlink" title="5.2 动态黑名单"></a>5.2 动态黑名单</h3><p>我们还可以开发一个沙箱模块实现 IP 黑名单功能，针对指定 IP 的客户端，服务直接返回空结果，用户交互示意图如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1691118593-c07b14ab3aa7c3c187251df2d477766a.png"></p><p>图 5-2 动态黑名单交互示意图</p><p>引用 JVM SandBox 官网的一句话：“JVM-SANDBOX 还能帮助你做很多很多，取决于你的脑洞有多大了。”</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JVM SandBox 是一种无侵入，可动态插拔，JVM 层的 AOP 解决方案，基于 JVM SandBox 我们可以很容易地开发出很多有意思的工具，这完全归功于 JVM SandBox 为我们屏蔽了底层技术细节和实现复杂性。JVM SandBox 很强大，这里需要感谢 JVM SandBox 的作者。除了无侵入，可动态插拔这两个优势之外，JVM SandBox 在 JVM 层支持 AOP 这件事情本身就是一个绝对优势，因为我们开发的 AOP 能力不再依赖应用层所使用的容器，比如不管你使用的是 Spring 容器还是 Plexus 容器，不管你的 Web 容器是 Tomcat 还是 Jetty、统统都没有关系。</p><p>回顾一下本文的内容：</p><ul><li><p>回顾 AOP 技术；</p></li><li><p>介绍 JVM SandBox 是什么、来自哪里、怎么用；</p></li><li><p>通过 Java Agent 的加载介绍涉及到的 JVM 相关核心技术如：Attach 机制、JVMTI、Instrument 等；</p></li><li><p>介绍 JVM SandBox 的核心特性的设计与实现如：可插拔、无侵入、隔离、多租户；</p></li><li><p>介绍 JVM SandBox 可被应用的场景以及两个小例子。</p></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>【1】<a href="http://developer.51cto.com/art/201803/568224.htm">http://developer.51cto.com/art/201803/568224.htm</a>  </p><p>【2】<a href="https://github.com/alibaba/jvm-sandbox">https://github.com/alibaba/jvm-sandbox</a>  </p><p>【3】<a href="https://www.jianshu.com/p/b72f66da679f">https://www.jianshu.com/p/b72f66da679f</a>  </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ConfigurationProperties和EnableConfigurationProperties的区别</title>
    <link href="/2023/07/31/Spring/ConfigurationProperties%E5%92%8CEnableConfigurationProperties%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/07/31/Spring/ConfigurationProperties%E5%92%8CEnableConfigurationProperties%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>总结一下：</p><ul><li><code>@ConfigurationProperties</code> 用于指定将要绑定到类上的属性的前缀。</li><li><code>@EnableConfigurationProperties</code> 用于告诉 Spring Boot 创建带有 <code>@ConfigurationProperties</code> 注解的类的 bean。</li><li>前者只是声明，如果想在spring容器中使用这些属性，则需要使用component注解或者EnableConfigurationProperties去把class属性注册到spring容器中</li></ul><hr><h2 id="EnableConfigurationProperties和ConfigurationProperties"><a href="#EnableConfigurationProperties和ConfigurationProperties" class="headerlink" title="EnableConfigurationProperties和ConfigurationProperties"></a>EnableConfigurationProperties和ConfigurationProperties</h2><p>假设你在 application.yml 文件中有如下的配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">myapp:</span><br>  <span class="hljs-attr">server:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8080</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">user</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">pass</span><br></code></pre></td></tr></table></figure><p>你想要将这个配置绑定到一个 Java 对象上，你可以使用 <code>@ConfigurationProperties</code> 注解来完成这个任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;myapp.server&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@ConfigurationProperties(prefix = &quot;myapp.server&quot;)</code> 告诉 Spring Boot 将所有以 <code>myapp.server</code> 开头的属性绑定到这个类的字段上。<code>@Component</code> 注解则告诉 Spring 将这个类视为一个 bean，并在 Spring 上下文中管理它。</p><p>现在，你可以在应用的任何地方注入 <code>ServerProperties</code> 并使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerProperties serverProperties;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyController</span><span class="hljs-params">(ServerProperties serverProperties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverProperties = serverProperties;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/server&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getServerDetails</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;URL: &quot;</span> + serverProperties.getUrl() +<br>                <span class="hljs-string">&quot;, Username: &quot;</span> + serverProperties.getUsername() +<br>                <span class="hljs-string">&quot;, Password: &quot;</span> + serverProperties.getPassword();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，使用 <code>@EnableConfigurationProperties</code>，有另一种方式可以达到同样的效果。不是给 <code>ServerProperties</code> 打上 <code>@Component</code> 标签，而是在一个 <code>@Configuration</code> 类中使用 <code>@EnableConfigurationProperties</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;myapp.server&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-comment">// 这个类不需要有任何代码。</span><br>    <span class="hljs-comment">// 它的目的就是启用 ServerProperties。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@EnableConfigurationProperties(ServerProperties.class)</code> 告诉 Spring Boot 创建一个 <code>ServerProperties</code> 的 bean 并将属性绑定到它上，即使 <code>ServerProperties</code> 并没有被标记为 <code>@Component</code>。</p><p>所以，总结一下：</p><ul><li><code>@ConfigurationProperties</code> 用于指定将要绑定到类上的属性的前缀。</li><li><code>@EnableConfigurationProperties</code> 用于告诉 Spring Boot 创建带有 <code>@ConfigurationProperties</code> 注解的类的 bean。</li></ul><h2 id="value和ConfigurationProperties"><a href="#value和ConfigurationProperties" class="headerlink" title="value和ConfigurationProperties"></a>value和ConfigurationProperties</h2><p><code>@ConfigurationProperties</code> 和 <code>@Value</code> 是 Spring Framework 中用来处理外部配置的两种主要方式，它们都可以从外部源（如 application.properties 或 application.yml 文件）读取配置。然而，它们之间还是存在一些关键区别：</p><ol><li>类型安全：<code>@ConfigurationProperties</code> 是类型安全的，也就是说，它会自动进行类型转换。例如，如果你有一个整数属性，而在配置文件中提供的值是字符串，Spring 会尝试将字符串值转换为整数。而 <code>@Value</code> 则不会进行这种类型转换，它会将所有配置值都当作字符串来处理。</li><li>校验支持：<code>@ConfigurationProperties</code> 可以和 Spring 的 JSR-303 校验（通过 <code>@Validated</code> 注解）结合使用，从而对配置属性进行校验。例如，你可以使用 <code>@NotNull</code>、<code>@Size</code> 等注解来校验配置属性的值。相比之下，<code>@Value</code> 并不支持这种校验机制。</li><li>复杂类型：<code>@ConfigurationProperties</code> 支持复杂类型的配置，如列表和映射，也可以绑定到嵌套的 POJO。而 <code>@Value</code> 则仅支持简单类型。</li><li>表达式支持：<code>@Value</code> 可以使用 Spring 表达式语言 (SpEL)，这让它在某些复杂的需要动态计算值的场景下更加有用。相比之下，<code>@ConfigurationProperties</code> 并不支持 SpEL。</li><li>批量配置：当你需要注入大量相关的属性时，<code>@ConfigurationProperties</code> 使得操作更加简洁，因为你可以在一个类中处理所有的相关属性。</li></ol><p>总的来说，<code>@Value</code> 在处理简单的值或需要使用 SpEL 的场景下比较适用，而 <code>@ConfigurationProperties</code> 在处理复杂的、层次化的或需要进行校验的配置时更有优势。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kuai 重要git工程记录</title>
    <link href="/2023/07/30/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/kuai-%E9%87%8D%E8%A6%81git%E5%B7%A5%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/07/30/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/kuai-%E9%87%8D%E8%A6%81git%E5%B7%A5%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ol><li>api-manage<ol><li>api-mange ： <a href="https://git.corp.kuaishou.com/serveree/api-manage.git">https://git.corp.kuaishou.com/serveree/api-manage.git</a><ol><li>主分支是release</li><li>api管理界面</li><li>http解析解析，swagger2.0+swagger3.0</li><li>krpc解析</li></ol></li><li>koas-reader：<a href="https://git.corp.kuaishou.com/serveree/kosa.git">https://git.corp.kuaishou.com/serveree/kosa.git</a><ol><li>release分支</li><li>swagger2.0解析</li></ol></li><li>koas-http-mock：<a href="https://git.corp.kuaishou.com/serveree/koas-http-mock.git">https://git.corp.kuaishou.com/serveree/koas-http-mock.git</a><ol><li>api管理的http mock服务</li></ol></li></ol></li><li>mock<ol><li>mock服务及代理平台代码 <a href="https://git.corp.kuaishou.com/serveree/ks-mock.git">https://git.corp.kuaishou.com/serveree/ks-mock.git</a></li><li>长连接客户端代理工程 <a href="https://git.corp.kuaishou.com/serveree/lc-mock.git">https://git.corp.kuaishou.com/serveree/lc-mock.git</a></li><li>MQ消息发送平台 <a href="https://git.corp.kuaishou.com/serveree/mq-mock.git">https://git.corp.kuaishou.com/serveree/mq-mock.git</a></li></ol></li><li>kdev<ol><li>KDev - 研发工作流 kdev-parent ：<a href="https://git.corp.kuaishou.com/serveree/kdev-parent.git">https://git.corp.kuaishou.com/serveree/kdev-parent.git</a></li><li>研发效能团队公共基础库 <a href="https://git.corp.kuaishou.com/serveree/serveree-common-parent.git">https://git.corp.kuaishou.com/serveree/serveree-common-parent.git</a></li></ol></li><li>upm &#x2F; ares &#x2F; 权限中台<ol><li>release分支</li><li><a href="https://git.corp.kuaishou.com/serveree/ks-serveree-ares.git">https://git.corp.kuaishou.com/serveree/ks-serveree-ares.git</a></li></ol></li><li>代码扫描<ol><li>代码检查扫描平台 <a href="https://git.corp.kuaishou.com/serveree/ks-serveree-themis.git">https://git.corp.kuaishou.com/serveree/ks-serveree-themis.git</a></li><li>sonar插件的功能扩展，例如：登录插件等，主要用于代码检查平台。<a href="https://git.corp.kuaishou.com/serveree/ks-serveree-sonar-plugins.git">https://git.corp.kuaishou.com/serveree/ks-serveree-sonar-plugins.git</a></li><li>插件脚本build-tools库 <a href="https://git.corp.kuaishou.com/ks/kuaishou-build-tools.git">https://git.corp.kuaishou.com/ks/kuaishou-build-tools.git</a></li></ol></li><li>流量录制<ol><li>流量录制sdk和平台 <a href="https://git.corp.kuaishou.com/infra/infra-patronum-traffic-management">https://git.corp.kuaishou.com/infra/infra-patronum-traffic-management</a></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>工作领域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql的explain关键字使用说明</title>
    <link href="/2023/07/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E7%9A%84explain%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <url>/2023/07/26/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/mysql%E7%9A%84explain%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MySQL 提供了一个 EXPLAIN 命令, 它可以对 <code>SELECT</code> 语句进行分析, 并输出 <code>SELECT</code> 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">WHERE</span>  id &lt; <span class="hljs-number">300</span>;<br></code></pre></td></tr></table></figure><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `user_info` (<br>  `id`   <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `age`  <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>)              <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `name_index` (`name`)<br>)<br>  ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;xys&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">15</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">20</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">21</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">23</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-number">50</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> user_info (name, age) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;i&#x27;</span>, <span class="hljs-number">15</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `order_info` (<br>  `id`           <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `user_id`      <span class="hljs-type">BIGINT</span>(<span class="hljs-number">20</span>)           <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `product_name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  `productor`    <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>)          <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)<br>)<br>  ENGINE <span class="hljs-operator">=</span> InnoDB<br>  <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;WHH&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;p2&#x27;</span>, <span class="hljs-string">&#x27;WL&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;DX&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;WHH&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;p5&#x27;</span>, <span class="hljs-string">&#x27;WL&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;p3&#x27;</span>, <span class="hljs-string">&#x27;MA&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;WHH&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">&#x27;p1&#x27;</span>, <span class="hljs-string">&#x27;WHH&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> order_info (user_id, product_name, productor) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">9</span>, <span class="hljs-string">&#x27;p8&#x27;</span>, <span class="hljs-string">&#x27;TE&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="EXPLAIN-输出格式"><a href="#EXPLAIN-输出格式" class="headerlink" title="EXPLAIN 输出格式"></a>EXPLAIN 输出格式</h2><p>EXPLAIN 命令的输出内容大致如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: const<br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>各列的含义如下:</p><ul><li><p>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</p></li><li><p>select_type: SELECT 查询的类型.</p></li><li><p>table: 查询的是哪个表</p></li><li><p>partitions: 匹配的分区</p></li><li><p>type: join 类型</p></li><li><p>possible_keys: 此次查询中可能选用的索引</p></li><li><p>key: 此次查询中确切使用到的索引.</p></li><li><p>ref: ref列显示哪些列或常量与键列中指定的索引进行比较，以便从表中选择行。</p></li><li><p>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</p></li><li><p>filtered: 表示此查询条件所过滤的数据的百分比</p></li><li><p>extra: 额外的信息</p></li></ul><p>接下来我们来重点看一下比较重要的几个字段.</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p><code>select_type</code> 表示了查询的类型, 它的常用取值有:</p><ul><li><p>SIMPLE, 表示此查询不包含 UNION 查询或子查询</p></li><li><p>PRIMARY, 表示此查询是最外层的查询</p></li><li><p>UNION, 表示此查询是 UNION 的第二或随后的查询</p></li><li><p>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询</p></li><li><p>UNION RESULT, UNION 的结果</p></li><li><p>SUBQUERY, 子查询中的第一个 SELECT</p></li><li><p>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.</p></li></ul><p>最常见的查询类别应该是 <code>SIMPLE</code> 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 <code>SIMPLE</code> 类型, 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: const<br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_info  <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">UNION</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_info <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>));<br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> select_type  <span class="hljs-operator">|</span> <span class="hljs-keyword">table</span>      <span class="hljs-operator">|</span> partitions <span class="hljs-operator">|</span> type  <span class="hljs-operator">|</span> possible_keys <span class="hljs-operator">|</span> key     <span class="hljs-operator">|</span> key_len <span class="hljs-operator">|</span> <span class="hljs-keyword">ref</span>  <span class="hljs-operator">|</span> <span class="hljs-keyword">rows</span> <span class="hljs-operator">|</span> filtered <span class="hljs-operator">|</span> Extra           <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">1</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>      <span class="hljs-operator">|</span> user_info  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-operator">|</span> <span class="hljs-number">8</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span>  <span class="hljs-number">2</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">UNION</span>        <span class="hljs-operator">|</span> user_info  <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">range</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">PRIMARY</span> <span class="hljs-operator">|</span> <span class="hljs-number">8</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>    <span class="hljs-number">3</span> <span class="hljs-operator">|</span>   <span class="hljs-number">100.00</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>     <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">UNION</span> <span class="hljs-keyword">RESULT</span> <span class="hljs-operator">|</span> <span class="hljs-operator">&lt;</span>union1,<span class="hljs-number">2</span><span class="hljs-operator">&gt;</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>       <span class="hljs-operator">|</span> <span class="hljs-keyword">ALL</span>   <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>          <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span>     <span class="hljs-keyword">NULL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">Using</span> temporary <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+</span><br><span class="hljs-number">3</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>表示查询涉及的表或衍生表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p><code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等.</p><h4 id="type-常用类型"><a href="#type-常用类型" class="headerlink" title="type 常用类型"></a>type 常用类型</h4><p>type 常用的取值有:</p><ul><li><p><code>system</code>: 表中只有一条数据. 这个类型是特殊的 <code>const</code> 类型.</p></li><li><p><code>const</code>: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 <code>type</code> 就是 <code>const</code> 类型的.</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> user_info <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: const<br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li><code>eq_ref</code>: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 <code>=</code>, 查询效率较高. 例如:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_info, order_info <span class="hljs-keyword">WHERE</span> user_info.id <span class="hljs-operator">=</span> order_info.user_id\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">314</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">9</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> index<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">2.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: eq_ref<br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: test.order_info.user_id<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li><code>ref</code>: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 <code>最左前缀</code> 规则索引的查询.<br>例如下面这个例子中, 就使用到了 <code>ref</code> 类型的查询:</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> user_info, order_info <span class="hljs-keyword">WHERE</span> user_info.id <span class="hljs-operator">=</span> order_info.user_id <span class="hljs-keyword">AND</span> order_info.user_id <span class="hljs-operator">=</span> <span class="hljs-number">5</span>\G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: const<br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">2.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ref</span><br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">9</span><br>          <span class="hljs-keyword">ref</span>: const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">2</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><ul><li><code>range</code>: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 &#x3D;, &lt;&gt;, &gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;, IS NULL, &lt;&#x3D;&gt;, BETWEEN, IN() 操作中.<br>当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL, 并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个.</li></ul><p>例如下面的例子就是一个范围查询:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>         <span class="hljs-keyword">FROM</span> user_info<br>    <span class="hljs-operator">-</span><span class="hljs-operator">&gt;</span>         <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">8</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">range</span><br>possible_keys: <span class="hljs-keyword">PRIMARY</span><br>          key: <span class="hljs-keyword">PRIMARY</span><br>      key_len: <span class="hljs-number">8</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">7</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li><code>index</code>: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br><code>index</code> 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 <code>Using index</code>.</li></ul><p>例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span>  user_info \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: name_index<br>      key_len: <span class="hljs-number">152</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 <code>index</code>, 并且 Extra 的值是 <code>Using index</code>.</p><ul><li>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span>  user_info <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: user_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">10.00</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><h4 id="type-类型的性能比较"><a href="#type-类型的性能比较" class="headerlink" title="type 类型的性能比较"></a>type 类型的性能比较</h4><p>通常来说, 不同的 type 类型的性能关系如下:<br><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code><br><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p><code>possible_keys</code> 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 <code>possible_keys</code> 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 <code>key</code> 字段决定.</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>此字段是 MySQL 在当前查询时所真正使用到的索引.</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:</p><ul><li><p>字符串</p><ul><li><p>char(n): n 字节长度</p></li><li><p>varchar(n): 如果是 utf8 编码, 则是 3 <em>n + 2字节; 如果是 utf8mb4 编码, 则是 4</em> n + 2 字节.</p></li></ul></li><li><p>数值类型:</p><ul><li><p>TINYINT: 1字节</p></li><li><p>SMALLINT: 2字节</p></li><li><p>MEDIUMINT: 3字节</p></li><li><p>INT: 4字节</p></li><li><p>BIGINT: 8字节</p></li></ul></li><li><p>时间类型</p><ul><li><p>DATE: 3字节</p></li><li><p>TIMESTAMP: 4字节</p></li><li><p>DATETIME: 8字节</p></li></ul></li><li><p>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.</p></li></ul><p>我们来举两个简单的栗子:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> order_info <span class="hljs-keyword">WHERE</span> user_id &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> product_name = <span class="hljs-string">&#x27;p1&#x27;</span> <span class="hljs-keyword">AND</span> productor = <span class="hljs-string">&#x27;WHH&#x27;</span> \G<br>*************************** <span class="hljs-number">1.</span> <span class="hljs-keyword">row</span> ***************************<br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">type</span>: range<br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">9</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">5</span><br>     filtered: <span class="hljs-number">11.11</span><br>        Extra: <span class="hljs-keyword">Using</span> <span class="hljs-keyword">where</span>; <span class="hljs-keyword">Using</span> <span class="hljs-keyword">index</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> <span class="hljs-built_in">warning</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 <code>order_info</code> 有一个联合索引:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)<br></code></pre></td></tr></table></figure><p>不过此查询语句 <code>WHERE user_id &lt; 3 AND product_name = &#39;p1&#39; AND productor = &#39;WHH&#39;</code> 中, 因为先进行 user_id 的范围查询, 而根据 <code>最左前缀匹配</code> 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 <code>user_id</code>, 因此在 <code>EXPLAIN</code> 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 <code>BIGINT(20) NOT NULL DEFAULT &#39;0&#39;</code>, 则 key_length 应该是8.</p><p>上面因为 <code>最左前缀匹配</code> 原则, 我们的查询仅仅使用到了联合索引的 <code>user_id</code> 字段, 因此效率不算高.</p><p>接下来我们来看一下下一个例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> order_info <span class="hljs-keyword">WHERE</span> user_id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> product_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;p1&#x27;</span> \G;<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ref</span><br>possible_keys: user_product_detail_index<br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">161</span><br>          <span class="hljs-keyword">ref</span>: const,const<br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">2</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 <code>WHERE user_id = 1 AND product_name = &#39;p1&#39;</code> 中, 仅仅使用到了联合索引中的前两个字段, 因此 <code>keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</code></p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p><ul><li>Using filesort<br>当 Extra 中有 <code>Using filesort</code> 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 <code>Using filesort</code>, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.</li></ul><p>例如下面的例子:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> order_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> product_name \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">253</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">9</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index; <span class="hljs-keyword">Using</span> filesort<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>我们的索引是</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)<br></code></pre></td></tr></table></figure><p>但是上面的查询中根据 <code>product_name</code> 来排序, 因此不能使用索引进行优化, 进而会产生 <code>Using filesort</code>.<br>如果我们将排序依据改为 <code>ORDER BY user_id, product_name</code>, 那么就不会出现 <code>Using filesort</code> 了. 例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> order_info <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id, product_name \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: order_info<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: user_product_detail_index<br>      key_len: <span class="hljs-number">253</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">9</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><ul><li><p>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</p></li><li><p>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql语句各个关键字的执行顺序</title>
    <link href="/2023/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/sql%E8%AF%AD%E5%8F%A5%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2023/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/sql%E8%AF%AD%E5%8F%A5%E5%90%84%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>The order of execution of SQL statements is important to understand, especially when writing complex queries. Here’s the usual order:</p><ol><li><p><strong>FROM and JOINs</strong>: The FROM clause, and any JOINs are first executed. This determines and combines all the tables being used in the query.</p></li><li><p><strong>WHERE</strong>: Once we know what tables are being used and how they’re connected, the WHERE clause filters down the data that’s going to be used for the next steps.</p></li><li><p><strong>GROUP BY</strong>: The data we have so far is then grouped based on the columns specified in the GROUP BY clause.</p></li><li><p><strong>Aggregation functions (MIN, MAX, AVG, COUNT, etc.)</strong>: Any aggregation functions in the SELECT part of the query are then applied within each group of data.</p></li><li><p><strong>HAVING</strong>: If a HAVING clause is present, it acts like a WHERE but for groups instead of individual rows.</p></li><li><p><strong>SELECT</strong>: The specific columns mentioned in the SELECT statement are then calculated and returned.</p></li><li><p><strong>ORDER BY</strong>: If an ORDER BY clause is present, the returned result set is sorted accordingly.</p></li><li><p><strong>LIMIT</strong>: If a LIMIT clause is present, the final result set is limited to a certain number of rows.</p></li></ol><p>执行顺序</p><ol><li>from </li><li>on join 联表，把需要查询的表聚合起来</li><li>where 条件过滤</li><li>group by 对过滤的条件进行分组</li><li>having 对每一个分组分别进行条件过滤</li><li>select 现在数据，然后进行函数count、max、distinct等的计算</li><li>order by 对数据进行排序</li><li>limit 最后才进行截取，需要注意的是排序是在截取前面的，如果先截取在排序，那么就可能造成数据不符合预期</li></ol><hr><h1 id="图解-SQL-的执行顺序"><a href="#图解-SQL-的执行顺序" class="headerlink" title="图解 SQL 的执行顺序"></a>图解 SQL 的执行顺序</h1><p>这是一条标准的查询语句:</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-9265efc3a39512d0e449400c14046629.png" alt="图片"></p><p>这是我们实际上SQL执行顺序：</p><ul><li><p>我们先执行from,join来确定表之间的连接关系，得到初步的数据</p></li><li><p>where对数据进行普通的初步的筛选</p></li><li><p>group by 分组</p></li><li><p>各组分别执行having中的普通筛选或者聚合函数筛选。</p></li><li><p>然后把再根据我们要的数据进行select，可以是普通字段查询也可以是获取聚合函数的查询结果，如果是集合函数，select的查询结果会新增一条字段</p></li><li><p>将查询结果去重distinct</p></li><li><p>最后合并各组的查询结果，按照order by的条件进行排序</p></li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-3cb58302a71398b545cb76cda558aa7d.png" alt="图片"></p><h3 id="数据的关联过程"><a href="#数据的关联过程" class="headerlink" title="数据的关联过程"></a><strong>数据的关联过程</strong></h3><p>数据库中的两张表</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-6afa3f9e899059a5bc886a23e5c93aba.png" alt="图片"></p><h3 id="from-join-where"><a href="#from-join-where" class="headerlink" title="from&amp;join&amp;where"></a><strong>from&amp;join&amp;where</strong></h3><p>用于确定我们要查询的表的范围，涉及哪些表。</p><p>选择一张表，然后用join连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">from table1 join table2 on table1.id=table2.id<br></code></pre></td></tr></table></figure><p>选择多张表，用where做关联条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">from table1,table2 where table1.id=table2.id<br></code></pre></td></tr></table></figure><p>我们会得到满足关联条件的两张表的数据，不加关联条件会出现笛卡尔积。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-ea1fe46de1898ffaf04f8f4e283df0bc.png" alt="图片"></p><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a><strong>group by</strong></h3><p>按照我们的分组条件，将数据进行分组，但是不会筛选数据。</p><p>比如我们按照即id的奇偶分组</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-f8d559acb75a672ed9c515cb899db92e.png" alt="图片"></p><h3 id="having-where"><a href="#having-where" class="headerlink" title="having&amp;where"></a><strong>having&amp;where</strong></h3><p>having中可以是普通条件的筛选，也能是聚合函数。而where只能是普通函数，一般情况下，有having可以不写where，把where的筛选放在having里，SQL语句看上去更丝滑。</p><h5 id="使用where再group-by"><a href="#使用where再group-by" class="headerlink" title="使用where再group by"></a>使用where再group by</h5><p>先把不满足where条件的数据删除，再去分组</p><h5 id="使用group-by再having"><a href="#使用group-by再having" class="headerlink" title="使用group by再having"></a>使用group by再having</h5><p>先分组再删除不满足having条件的数据，这两种方法有区别吗，几乎没有！</p><p>举个例子：</p><p><code>100/2=50</code>，此时我们把100拆分<code>(10+10+10+10+10…)/2=5+5+5+…+5=50</code>,只要筛选条件没变，即便是分组了也得满足筛选条件，所以where后group by 和group by再having是不影响结果的！</p><p>不同的是，having语法支持聚合函数,其实having的意思就是针对每组的条件进行筛选。我们之前看到了普通的筛选条件是不影响的，但是having还支持聚合函数，这是where无法实现的。</p><p>当前数据分组情况</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-5735ededeabe78a6ddf7fa4c71f74f29.png" alt="图片">执行having的筛选条件，可以使用聚合函数。筛选掉工资小于各组平均工资的<code>having salary&lt;avg(salary)</code></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-afab2cb0155803d22166c92931e841b1.png" alt="图片"></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><p>分组结束之后，我们再执行select语句，因为聚合函数是依赖于分组的，聚合函数会单独新增一个查询出来的字段，这里用紫色表示，这里我们两个id重复了，我们就保留一个id，重复字段名需要指向来自哪张表，否则会出现唯一性问题。最后按照用户名去重。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">select employee.id,distinct name,salary, avg(salary)<br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-f60a57366dd9534d1e2fc168ef8ce074.png" alt="图片">将各组having之后的数据再合并数据。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-b72c4091eb4233ac17643ab3562b59bb.png" alt="图片"></p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a><strong>order by</strong></h3><p>最后我们执行order by 将数据按照一定顺序排序，比如这里按照id排序。如果此时有limit那么查询到相应的我们需要的记录数时，就不继续往下查了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-2383bcfac4542e4911db5e7a4cbca2c8.png" alt="图片"></p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h3><p>记住limit是最后查询的，为什么呢？假如我们要查询年级最小的三个数据，如果在排序之前就截取到3个数据。实际上查询出来的不是最小的三个数据而是前三个数据了，记住这一点。</p><p>我们如果limit 0,3窃取前三个数据再排序，实际上最少工资的是2000,3000,4000。你这里只能是4000,5000,8000了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1690210965-c8ef240c7efe42726b93c389d8bef992.png" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab redis多AZ容灾高可用方案调研</title>
    <link href="/2023/07/23/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/Gitlab-redis%E5%A4%9AAZ%E5%AE%B9%E7%81%BE%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/"/>
    <url>/2023/07/23/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/Gitlab-redis%E5%A4%9AAZ%E5%AE%B9%E7%81%BE%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h1><p>Gitlab多AZ容灾建设，目前自身服务已实现单AZ故障演练服务秒级自动切换恢复。但对应Gitlab依赖的服务平台，还有redis没有完全参与AZ容灾演练，AZ容灾效果仍处于未知状态。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h1><ol><li><strong>Gitlab****只支持redis哨兵模式，不支持redis cluster mode</strong></li><li><strong>公司redis集群哨兵模式不支持AZ逃生，且后续暂无计划支持</strong>。</li><li>现状问题是AZ故障时，可以确保Gitlab服务正常，但故障恢复后的短暂时间（预估2~3min）会有redis双写问题</li></ol><h3 id="问题现状分析"><a href="#问题现状分析" class="headerlink" title="问题现状分析"></a><strong>问题现状分析</strong></h3><p>经过调研和梳理，之前gitlab服务所在AZ和依赖redis所在AZ情况，整理如下场景：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025863.png" alt="img"></p><p><strong>综上，如果是按照AZ2.0架构，进行多AZ容灾建设，如果是单一AZ故障的话，Gitlab可以通过一些低成本的逃生手段达到AZ故障逃生，进而正常提供服务。</strong></p><p><strong>但如果通过AZ容灾演练，redis主节点发生变化，即****redis主节点和gitlab应用服务器在同一AZ时，就会出现问题</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026455.png" alt="img"></p><p>上述故障切换第3种情况，若<strong>故障恢复后</strong>，AZ4连接还是之前的AZ3 redis集群，AZ1连接的是新的AZ4 redis集群，在对故障AZ4的Gitlab服务进行修改之前的这段时间<strong>（</strong>故障时所在AZ的Gitlab服务器无法登录和操作<strong>）</strong>，此时可能会出现<strong>reids双写，数据不一致的情况</strong></p><h1 id="业界调研"><a href="#业界调研" class="headerlink" title="业界调研"></a><strong>业界调研</strong></h1><p>Gitlab redis社区方案是使用redis sentinel模式，未给出有相关多AZ可用区的建设参考方案。<strong>Gitalb不支持redis cluster模式<strong><strong>，</strong></strong>Redis Cluster mode is not supported  by GitLab.</strong></p><p>gitlab.com使用的<strong>推荐方案是使用第三方云服务提供商</strong>，自身可不用考虑AZ容灾的问题，交给云服务提供商解决。</p><p>各大厂redis容灾方案调研</p><table><thead><tr><th></th><th><strong>快手</strong></th><th><strong>Google cloud platform</strong></th><th><strong>阿里云</strong></th><th><strong>腾讯云</strong></th></tr></thead><tbody><tr><td><strong>架构部署</strong></td><td><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026603.png" alt="img"></td><td><a href="https://cloud.google.com/memorystore/docs/redis/redis-overview?hl=zh-cn">Memorystore for Redis</a> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026159.png" alt="img"> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025708.png" alt="img"></td><td>集群架构1.代理模式<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026710.png" alt="img"> 2.直连模式<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026542.png" alt="img"></td><td>集群架构 <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026352.png" alt="img"></td></tr><tr><td><strong>容灾方案</strong></td><td><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026294.png" alt="img"> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026551.png" alt="img">AZ2.0<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222027016.png" alt="img"> KCC平台AZ逃生前提条件：<strong>使用公司框架****没有写死ip地址情况（需要业务自行修改客户端配置切换AZ）</strong></td><td>跨地区复制读取副本允许分布式读取 <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026751.png" alt="img"></td><td>单可用区高可用方案同城容灾方案跨地域容灾方案 <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026169.png" alt="img"> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026850.png" alt="img"> <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026065.png" alt="img"></td><td>多可用区实例具有更高的可用性和容灾能力。主机、机架、可用区级容灾能力。<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026756.png" alt="img"> 两可用区部署：<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025593.png" alt="img"></td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a><strong>方案</strong></h1><p>针对目前redis容灾问题，整理几个方案思路，供参考讨论，具体可行性及成本待进一步调研验证</p><ol><li>AZ故障时，Gitlab reids容灾接受短时间的redis双写问题，尽量减少故障恢复处理时长（具体方案待补充）</li><li>改造Gitlab，支持redis cluster模式？</li></ol><ul><li>如果使用redis cluster模式，就要确保mutli-key都在同一个slot，否则会出现错误：ERR CROSSSLOT Keys in request don’t hash to the same slot，而Gitlab源码中redis使用了多multi-key的命令场景，如Gitlab::Redis::Cache.with { |redis| redis.mget(‘foo’, ‘bar’) }</li></ul><ol><li>搭建Proxy 代理，Gitlab直连proxy，不关注后端redis，proxy能够自动检测redis可用性，并自动摘除&#x2F;切换redis?</li><li>使用第三方云服务商，调研公司<a href="https://cmp.corp.kuaishou.com/#/database/redis?project_id=0&tags=&deleted=false&offset=0&limit=20&search=&batch=">云集CMP</a></li></ol><p>改造成本，维护成本，潜在风险等多方面考虑。</p><p><strong>2023.7.10更新</strong></p><p><strong>上次讨论遗留问题：</strong></p><ol><li>分析数据可不可以丢失，丢失成本？</li></ol><ul><li><ul><li>缓存类数据可容忍丢失，如仓库数据、session等，</li><li>sidekiq<strong>队列任务不可容忍丢失，如merge更新合并、webhook等丢失后可能影响代码错乱、丢失等风险</strong></li></ul></li></ul><ol><li>分析使用cluster模式的命令，有哪些不支持，影响有哪些？ 我们是否使用？ 是否可以部分切换cluster模式</li></ol><ul><li><ul><li>分两类，一类是multi-key命令，如mget，缓存类使用，通过hash tag方式改造，有可能使用cluster模式，如<a href="https://gitlab.com/groups/gitlab-com/gl-infra/-/epics/823">redis-ratelimiting</a></li><li>另一类阻塞类命令，sidekiq使用brpop，属于<strong>cluster模式受限制命令，无法使用cluster模式</strong></li></ul></li></ul><ol><li>分析故障恢复后，双redis数据不一致的影响？</li></ol><ul><li><ul><li>相比数据丢失，数据不一致可能影响更大、更麻烦。</li></ul></li></ul><ol><li>redis同学确认主和冷备切换同步逻辑，故障时是否停止同步任务，同步方向</li></ol><ul><li><ul><li>redis AZ故障前，热备1向冷备2同步，AZ故障时，同步会断开，需要业务切换redis连接到冷备2，此时原热备1相当于没有流量和数据。业务切换完成后，需要找redis同学重新开启同步，即冷备2（新的热备）向热备1（新的冷备）全量同步。</li><li>若故障恢复后，原热备1还有流量，此时会双集群读写，可能会数据不一致，公司redis无法处理解决这种情况</li></ul></li></ul><ol><li>服务注册、服务发现的思路，Gitlab应该连哪个健康的节点，问题节点自动摘除、切换</li></ol><ul><li><ul><li>rails健康检查（curl  <a href="http://localhost/-/readiness?all=1%EF%BC%89%EF%BC%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%A3%80%E6%B5%8Bredis%E6%98%AF%E5%90%A6%E5%81%A5%E5%BA%B7%EF%BC%8CPING-PONG">http://localhost/-/readiness?all=1），定时任务，检测redis是否健康，PING-PONG</a>  ，若不正常，则修改redis连接配置，并重启reconfigure</li><li>sidekiq健康检查，redis健康检查（目前不能）</li><li>最好集成Gitlab，包含redis连接信息，或者新增API实现 redis health check，或者脚本实现，附带Gitlab连接redis信息，二者需保持一致</li></ul></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># reids sentinel健康检查</span><br><span class="hljs-regexp">/opt/gi</span>tlab<span class="hljs-regexp">/embedded/</span>bin/redis-cli -h public-bjzey-rs-redis666.idchb1az3.hb1.kwaidc.com -p <span class="hljs-number">17312</span> ping<br>PONG<br></code></pre></td></tr></table></figure><h2 id="Gitlab-redis详细调研"><a href="#Gitlab-redis详细调研" class="headerlink" title="Gitlab redis详细调研"></a><strong>Gitlab redis详细调研</strong></h2><p>redis分为不同的种类，其中 Redis queues, shared state, and tracechunks是需要持久化存储的，目前都是同一个reids集群存储。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026369.png" alt="img"></p><table><thead><tr><th>redis集群</th><th>存储数据内容</th><th>补充</th></tr></thead><tbody><tr><td><a href="https://halo.corp.kuaishou.com/redis/page/app/list?appName=gitlabHARedisSentinelNew">gitlabHARedisSentinelNew</a></td><td>queue队列  1%session  30%shard_statetrace_chunks**rate_limiting(可容忍丢失)**之前拆分集群历史遗留数据（不过期）52%其他 15%</td><td><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025943.png" alt="img"></td></tr><tr><td><a href="https://halo.corp.kuaishou.com/redis/page/app/list?appName=gitlabRedisCache">gitlabRedisCache</a></td><td>缓存cache，可容忍数据丢失。新旧集群双写，无需数据同步迁移存在不过期的数据？49737个</td><td><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025904.png" alt="img"><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025791.png" alt="img"></td></tr></tbody></table><p>Gitlab社区相关issue讨论redis水平扩展性，Redis cluster vs redis::Distributed， 其中<strong>redis cluster模式，sidekiq是个例外，不能使用。sidekiq中使用的大量的redis brpop命令，属于cluster模式受限命令</strong></p><p><a href="https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/1986"><strong>https://gitlab.com/gitlab-com/gl-infra/scalability/-/issues/1986</strong></a></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026493.png" alt="img"></p><p><strong>redis cluster模式命令限制</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025999.png" alt="img"></p><h3 id="sidekiq异步队列"><a href="#sidekiq异步队列" class="headerlink" title="sidekiq异步队列"></a><strong>sidekiq异步队列</strong></h3><p>Sidekiq 是 Ruby on Rails 应用程序中使用的多线程后台作业处理系统。Gitlab中主要执行包括：推送后更新合并请求、 发送电子邮件、 更新用户授权、 处理 CI 构建和管道等。目前总共大概<strong>350+种队列任务</strong></p><h3 id="Gitlab社区新版本支持redis-cluster模式探索"><a href="#Gitlab社区新版本支持redis-cluster模式探索" class="headerlink" title="Gitlab社区新版本支持redis cluster模式探索"></a><strong>Gitlab社区新版本支持redis cluster模式探索</strong></h3><p>目前Gitlab redis cpu和内存使用限制，不支持横向扩展。</p><p>Gitlab后续新版本探索和支持redis cluster，v16.0版本支持rate limiting类型</p><p><strong>GitLab supports Redis Cluster only for the Redis</strong> <a href="https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/redis/rate_limiting.rb"><strong>rate-limiting</strong></a> <strong>type, introduced in</strong> <a href="https://gitlab.com/groups/gitlab-com/gl-infra/-/epics/823"><strong>epic 823</strong></a><strong>.</strong></p><p><a href="https://gitlab.com/gitlab-com/gl-infra/readiness/-/blob/a965c665a22d2e59ab6325ca9ab453255ab62730/redis-cluster/ratelimiting.md"><strong>https://gitlab.com/gitlab-com/gl-infra/readiness/-/blob/a965c665a22d2e59ab6325ca9ab453255ab62730/redis-cluster/ratelimiting.md</strong></a></p><p>rate limiting类型几个考虑：</p><ol><li>没有分片命令操作（has no cross-slot operations）</li><li>数据丢失可容忍度高</li><li>数据生命周期都是短暂的，不用迁移现有数据，直接切换使用新的集群，相对成本较低</li><li>从Omnibus拆分单独的redis管理配置</li><li>redis版本7， 包含一些专门针对 Redis Cluster 的修复和改进</li></ol><p>Gitlab社区目标是redis-cache类型迁移使用redis cluster模式，里程碑2023-7-28</p><p>2023-7-19 三次更新</p><p><strong>TODO</strong>：</p><ol><li><p>gitlab 切换redis配置自动化操作，降低人工操作错误率和时间成本</p></li><li><p><strong>redis单个集群跨机房，风险点调研确认，决策是否自建redis sentinel跨机房集群</strong></p></li><li><ol><li>redis主从复制<strong>严重依赖网络</strong>，虽然redis不断提升复制能力（<a href="https://developer.baidu.com/article/detail.html?id=294748">Redis 主从复制的原理及演进</a>），sync-&gt;psync-&gt;psync2，但redis部署在不同的IDC，发生<strong>长网络抖动时</strong>，<strong>可能会出现全量复制风暴，全量复制风暴对可用性是毁灭性的</strong></li><li><strong>网络延时影响</strong>：主从复制，proxy访问转发，sentinel探活，这些事情都是要求时效性要求较高的，比如说出现网络抖动，同机房可能就是抖一下，跨机房可能延迟超过探活直接切换了</li><li>全量同步fork <strong>耗时过长，阻塞主进程</strong>，执行fork 时，需要拷贝大量的内存页表，这是一个耗时较多的操作，尤其当内存使用量较大的时候。fork 的时候主进程阻塞 100 多毫秒，这对 Redis 而言，实在太长了。另外fork 之后，如果主库中有不少的写入，那么由于写时复制机制，会额外消耗不少的内存，还会增大响应时间。</li></ol></li></ol><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026487.png" alt="img"></p><p>小结：kcc不支持单redis集群跨IDC机房部署。也不建议自建redis sentinel跨机房集群</p><ol><li><strong>双集群热备-冷备模式，单集群故障了，目标是能够实现全自动感知与切换，确保无人值守时服务正常（consul服务发现？）</strong></li></ol><p>公司kcc redis冷备故障切换示意图：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222026246.png" alt="img">  <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230724222025789.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
      <tag>gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis key值如何定位到value</title>
    <link href="/2023/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis-key%E5%80%BC%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0value/"/>
    <url>/2023/07/22/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/redis-key%E5%80%BC%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0value/</url>
    
    <content type="html"><![CDATA[<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>我想往redis中设置一个缓存，其中key是由两部分组成</p><ul><li>业务标识，REDIS_CACHE_XXX，这是固定不变的</li><li>用户名，user_name，根据业务使用不同而不同</li></ul><p>现在key可能有两种情况</p><ul><li>REDIS_CACHE_XXX_user_name</li><li>user_name_REDIS_CACHE_XXX</li></ul><p>请问这两种key的查询性能有区别吗？</p><h3 id="错误思路："><a href="#错误思路：" class="headerlink" title="错误思路："></a>错误思路：</h3><p>认为key是匹配是字符串匹配，那么差异性大的(user_name)放前面，可以快速匹配返回</p><h3 id="实际"><a href="#实际" class="headerlink" title="实际"></a>实际</h3><p>redis底层定位实际上是hash定位的，无论key怎么声明，在没有hash碰撞的时候，查询性能都是O(1)</p><p>本质就是一个分布式hashMap</p><h3 id="引申问题"><a href="#引申问题" class="headerlink" title="引申问题"></a>引申问题</h3><p>数据库联合索引&#x2F;索引（仅对于B+树索引），为什么要尽量把索引建立在有区别度的索引上</p><p>提示：索引需要排序，按照的是字符串的自然顺序，不能进行hash</p><hr><h1 id="Redis的存储"><a href="#Redis的存储" class="headerlink" title="Redis的存储"></a>Redis的存储</h1><p><strong>redis的总的数据结构</strong></p><p>        redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中，redisDb.id 存储着 redis 数据库的号码（以整数表示）。redisDb.dict 存储着该库所有的键值对数据。redisDb.expires 保存着每一个键的过期时间。</p><p><strong>数据库号</strong></p><p>        当redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number  时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。</p><p><strong>字典结构</strong></p><p>        一个数据库的所有键值都存储在redisDb.dict中，要找到key的位置，就要了解一下dict 的结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dict</span> &#123;<br><span class="hljs-comment">// 特定于类型的处理函数</span><br>dictType *type;<br> <br><span class="hljs-comment">// 类型处理函数的私有数据</span><br><span class="hljs-type">void</span> *privdata;<br> <br><span class="hljs-comment">// 哈希表（2个）</span><br>dictht ht[<span class="hljs-number">2</span>];<br> <br><span class="hljs-comment">// 记录 rehash 进度的标志，值为-1 表示 rehash 未进行</span><br><span class="hljs-type">int</span> rehashidx;<br> <br><span class="hljs-comment">// 当前正在运作的安全迭代器数量</span><br><span class="hljs-type">int</span> iterators;<br>&#125; dict;<br></code></pre></td></tr></table></figure><p>        由上述结构可以看出，redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而1号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以redis 中查找一个key，其实就是对进行该dict 结构中的 ht[0] 进行查找操作。</p><p><strong>哈希碰撞</strong></p><p>        既然是哈希，就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据key的哈希值找到该列表后，如果列表的长度大于1，那么我们需要遍历该链表来找到我们所查找的key。当然，一般情况下链表长度都为是1，所以时间复杂度可看作O(1)。</p><h1 id="根据key查找value的流程"><a href="#根据key查找value的流程" class="headerlink" title="根据key查找value的流程"></a>根据key查找value的流程</h1><p>了解上述内容之后，本处分析redis如何通过key在内存中找到value。</p><p>1、当拿到一个key后， redis 先判断当前库的0号哈希表是否为空，即：if (dict-&gt;ht[0].size &#x3D;&#x3D; 0)。如果为true直接返回NULL。</p><p>2、判断该0号哈希表是否需要rehash，因为如果在进行rehash，那么两个表中者有可能存储该key。如果正在进行rehash，将调用一次_dictRehashStep方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。</p><p>3、计算哈希表，根据当前字典与key进行哈希值的计算。</p><p>4、根据哈希值与当前字典计算哈希表的索引值。</p><p>5、根据索引值在哈希表中取出链表，遍历该链表找到key的位置。一般情况，该链表长度为1。</p><p>6、当 ht[0] 查找完了之后，再进行了次rehash判断，如果未在rehashing，则直接结束，否则对ht[1]重复345步骤。</p><p>到此我们就找到了key在内存中的位置了</p><h1 id="其他网址"><a href="#其他网址" class="headerlink" title="其他网址"></a>其他网址</h1><p><a href="https://redisbook.readthedocs.io/en/latest/internal-datastruct/dict.html#id4" title="字典 — Redis 设计与实现">字典 — Redis 设计与实现</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 中的 distinct 和 group by 哪个效率更高？</title>
    <link href="/2023/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-%E4%B8%AD%E7%9A%84-distinct-%E5%92%8C-group-by-%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F/"/>
    <url>/2023/07/21/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQL-%E4%B8%AD%E7%9A%84-distinct-%E5%92%8C-group-by-%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>先说结论：  </p><blockquote><ul><li><p>在语义相同，有索引的情况下：<code>group by</code>和distinct都能使用索引，效率相同。</p></li><li><p>在语义相同，无索引的情况下：distinct效率高于<code>group by</code>。原因是distinct 和 <code>group by</code>都会进行分组操作，但<code>group by</code>可能会进行排序，触发filesort，导致sql执行效率低下。</p></li></ul></blockquote><p>基于这个结论，你可能会问：</p><ul><li><p>为什么在语义相同，有索引的情况下，<code>group by</code>和distinct效率相同？</p></li><li><p>在什么情况下，<code>group by</code>会进行排序操作？</p></li></ul><p>带着这两个问题找答案。接下来，我们先来看一下distinct和<code>group by</code>的基础使用。</p><hr><h2 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h2><h3 id="distinct用法"><a href="#distinct用法" class="headerlink" title="distinct用法"></a>distinct用法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT DISTINCT columns FROM table_name WHERE where_conditions;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; select distinct age from student;<br>+------+<br>| age  |<br>+------+<br>|   10 |<br>|   12 |<br>|   11 |<br>| NULL |<br>+------+<br>4 rows in set (0.01 sec)<br></code></pre></td></tr></table></figure><p><code>DISTINCT</code> 关键词用于返回唯一不同的值。放在查询语句中的第一个字段前使用，且作用于主句所有列。</p><p>如果列具有NULL值，并且对该列使用<code>DISTINCT</code>子句，MySQL将保留一个NULL值，并删除其它的NULL值，因为<code>DISTINCT</code>子句将所有NULL值视为相同的值。</p><h3 id="distinct多列去重"><a href="#distinct多列去重" class="headerlink" title="distinct多列去重"></a>distinct多列去重</h3><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247569519&idx=2&sn=4fd70315f2335377f28fc27228ad873f&chksm=eb515559dc26dc4f6caad4ef91b34863d3278660350ffd143dcc5def252d454a816eb370203b&scene=21#wechat_redirect">distinct多列的去重，则是根据指定的去重的列信息来进行，即只有所有指定的列信息都相同，才会被认为是重复的信息。</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT DISTINCT column1,column2 FROM table_name WHERE where_conditions;<br>mysql&gt; select distinct sex,age from student;<br>+--------+------+<br>| sex    | age  |<br>+--------+------+<br>| male   |   10 |<br>| female |   12 |<br>| male   |   11 |<br>| male   | NULL |<br>| female |   11 |<br>+--------+------+<br>5 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p>对于基础去重来说，<code>group by</code>的使用和distinct类似:</p></blockquote><h3 id="单列去重"><a href="#单列去重" class="headerlink" title="单列去重"></a>单列去重</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT columns FROM table_name WHERE where_conditions GROUP BY columns;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; select age from student group by age;<br>+------+<br>| age  |<br>+------+<br>|   10 |<br>|   12 |<br>|   11 |<br>| NULL |<br>+------+<br>4 rows in set (0.02 sec)<br></code></pre></td></tr></table></figure><h3 id="多列去重"><a href="#多列去重" class="headerlink" title="多列去重"></a>多列去重</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">SELECT columns FROM table_name WHERE where_conditions GROUP BY columns;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; select sex,age from student group by sex,age;<br>+--------+------+<br>| sex    | age  |<br>+--------+------+<br>| male   |   10 |<br>| female |   12 |<br>| male   |   11 |<br>| male   | NULL |<br>| female |   11 |<br>+--------+------+<br>5 rows in set (0.03 sec)<br></code></pre></td></tr></table></figure><h2 id="区别示例"><a href="#区别示例" class="headerlink" title="区别示例"></a>区别示例</h2><p>两者的语法区别在于，<code>group by</code>可以进行单列去重，<code>group by</code>的原理是先对结果进行分组排序，然后返回每组中的第一条数据。且是根据<code>group by</code>的后接字段进行去重的。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; select sex,age from student group by sex;<br>+--------+-----+<br>| sex    | age |<br>+--------+-----+<br>| male   |  10 |<br>| female |  12 |<br>+--------+-----+<br>2 rows in set (0.03 sec)<br></code></pre></td></tr></table></figure><h3 id="distinct和group-by原理"><a href="#distinct和group-by原理" class="headerlink" title="distinct和group by原理"></a>distinct和group by原理</h3><blockquote><p>在大多数例子中，<code>DISTINCT</code>可以被看作是特殊的<code>GROUP BY</code>，它们的实现都基于分组操作，且都可以通过松散索引扫描、紧凑索引扫描来实现。</p></blockquote><p><code>DISTINCT</code>和<code>GROUP BY</code>都是可以使用索引进行扫描搜索的。例如以下两条sql（只单单看表格最后extra的内容），我们对这两条sql进行分析，可以看到，在extra中，这两条sql都使用了紧凑索引扫描<code>Using index for group-by</code>。</p><p>所以，在一般情况下，对于相同语义的<code>DISTINCT</code>和<code>GROUP BY</code>语句，我们可以对其使用相同的索引优化手段来进行优化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; explain select int1_index from test_distinct_groupby group by int1_index;<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>| id | select_type | table                 | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>|  1 | SIMPLE      | test_distinct_groupby | NULL       | range | index_1       | index_1 | 5       | NULL |  955 |   100.00 | Using index for group-by |<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>1 row in set (0.05 sec)<br><br>mysql&gt; explain select distinct int1_index from test_distinct_groupby;<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>| id | select_type | table                 | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>|  1 | SIMPLE      | test_distinct_groupby | NULL       | range | index_1       | index_1 | 5       | NULL |  955 |   100.00 | Using index for group-by |<br>+----+-------------+-----------------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+<br>1 row in set (0.05 sec)<br></code></pre></td></tr></table></figure><p>但对于<code>GROUP BY</code>来说，在MYSQL8.0之前，<code>GROUP Y</code>默认会依据字段进行隐式排序。</p><p>可以看到，下面这条sql语句在使用了临时表的同时，还进行了filesort。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">mysql&gt; explain select int6_bigger_random from test_distinct_groupby GROUP BY int6_bigger_random;<br>+----+-------------+-----------------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+<br>| id | select_type | table                 | partitions | type | possible_keys | key  | key_len | ref  | rows  | filtered | Extra                           |<br>+----+-------------+-----------------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+<br>|  1 | SIMPLE      | test_distinct_groupby | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 97402 |   100.00 | Using temporary; Using filesort |<br>+----+-------------+-----------------------+------------+------+---------------+------+---------+------+-------+----------+---------------------------------+<br>1 row in set (0.04 sec)<br></code></pre></td></tr></table></figure><h3 id="隐式排序"><a href="#隐式排序" class="headerlink" title="隐式排序"></a>隐式排序</h3><p>对于隐式排序，我们可以参考Mysql官方的解释：</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html">https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html</a></p><blockquote><p>GROUP BY implicitly sorts by default (that is, in the absence of ASC or DESC designators for GROUP BY columns). However, relying on implicit GROUP BY sorting (that is, sorting in the absence of ASC or DESC designators) or explicit sorting for GROUP BY (that is, by using explicit ASC or DESC designators for GROUP BY columns) is deprecated. To produce a given sort order, provide an ORDER BY clause.</p></blockquote><p>大致解释一下：</p><blockquote><p>GROUP BY 默认隐式排序（指在 GROUP BY 列没有 ASC 或 DESC 指示符的情况下也会进行排序）。然而，GROUP BY进行显式或隐式排序已经过时（deprecated）了，要生成给定的排序顺序，请提供 ORDER BY 子句。</p></blockquote><p>所以，在Mysql8.0之前,<code>Group by</code>会默认根据作用字段（<code>Group by</code>的后接字段）对结果进行排序。在能利用索引的情况下，<code>Group by</code>不需要额外进行排序操作；但当无法利用索引排序时，Mysql优化器就不得不选择通过使用临时表然后再排序的方式来实现<code>GROUP BY</code>了。</p><p>且当结果集的大小超出系统设置临时表大小时，Mysql会将临时表数据copy到磁盘上面再进行操作，语句的执行效率会变得极低。这也是Mysql选择将此操作（隐式排序）弃用的原因。</p><p>基于上述原因，Mysql在8.0时，对此进行了优化更新：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html">https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html</a></p><blockquote><p>Previously (MySQL 5.7 and lower), GROUP BY sorted implicitly under certain conditions. In MySQL 8.0, that no longer occurs, so specifying ORDER BY NULL at the end to suppress implicit sorting (as was done previously) is no longer necessary. However, query results may differ from previous MySQL versions. To produce a given sort order, provide an ORDER BY clause.</p></blockquote><p>大致解释一下：</p><blockquote><p>从前（Mysql5.7版本之前），Group by会根据确定的条件进行隐式排序。在mysql 8.0中，已经移除了这个功能，所以不再需要通过添加<code>order by null</code> 来禁止隐式排序了，但是，查询结果可能与以前的 MySQL 版本不同。要生成给定顺序的结果，请按通过ORDER BY指定需要进行排序的字段。</p></blockquote><p>因此，我们的结论也出来了：</p><ul><li>在语义相同，有索引的情况下：</li></ul><p><code>group by</code>和distinct都能使用索引，效率相同。因为<code>group by</code>和distinct近乎等价，distinct可以被看做是特殊的<code>group by</code>。</p><ul><li>在语义相同，无索引的情况下：</li></ul><p>distinct效率高于<code>group by</code>。原因是distinct 和 <code>group by</code>都会进行分组操作，但<code>group by</code>在Mysql8.0之前会进行隐式排序，导致触发filesort，sql执行效率低下。</p><p>但从Mysql8.0开始，Mysql就删除了隐式排序，所以，此时在语义相同，无索引的情况下，<code>group by</code>和distinct的执行效率也是近乎等价的。</p><p>推荐group by的原因</p><ol><li><p><code>group by</code>语义更为清晰</p></li><li><p><code>group by</code>可对数据进行更为复杂的一些处理</p></li></ol><p>相比于distinct来说，<code>group by</code>的语义明确。且由于distinct关键字会对所有字段生效，在进行复合业务处理时，<code>group by</code>的使用灵活性更高，<code>group by</code>能根据分组情况，对数据进行更为复杂的处理，例如通过having对数据进行过滤，或通过聚合函数对数据进行运算。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灵光和感悟</title>
    <link href="/2023/07/17/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E7%81%B5%E5%85%89%E5%92%8C%E6%84%9F%E6%82%9F/"/>
    <url>/2023/07/17/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E7%81%B5%E5%85%89%E5%92%8C%E6%84%9F%E6%82%9F/</url>
    
    <content type="html"><![CDATA[<p>1、拔高思维，在目前的层次再次抽象和拔高</p><ul><li><p>思考问题时，在当前的维度，在往上思考一层</p></li><li><p>对当前的问题和困境进行高层次的抽象，可以把复杂的问题简单化，以便更改的理解和解决</p></li></ul><p>2、当答案并不是非此即彼(互斥)，多个选项可以融合以进行取长补短</p><ul><li>当面临选择时，如果选项彼此之间不冲突(大部分时候)，考虑把多个选择进行融合，保留多个选择的优点，掩盖彼此的缺点</li><li>真正操作时，可能需要把问题进行阶段拆解，在不同阶段选择不同的方案</li></ul><p>3、扩展消息渠道，避免单一</p><ul><li>获取某个消息时，不要迷信单一信息来源，去不同来源获取不同信息</li></ul><p>4、对于一件感觉很吃力&#x2F;麻烦&#x2F;难办&#x2F;复杂的事情。思考为什么做，而不是怎么做</p><ul><li>在你心中已经有这个事情大概的做法，这目前存于你的想象中还未落实，内心认为这个解法很麻烦</li><li>需要做的是就是把当前解法摒弃掉，因为你内心已经感觉很难了</li><li>思考这件事想要做到什么效果，这事情最终要办成什么样子，最终的目的是什么</li><li>把目标写下来，基于此目标思考最简单、直接的方式</li></ul><p>5、思考的完整性，思考+扩展对比+模拟代入</p><p>目前想到一个思考的完整链路，持续补充</p><ul><li>思考，首先要想到尽量多的可能性，然后把这些可能性逐条分析</li><li>扩展对比，每一条都要想一下这条的难度和可替代，相较于其他方式有什么优势？【替代】【优势】</li><li>模拟代入，得到方法之后，模拟走一遍实现路径，看看合适吗</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>感悟</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码索引构建scip</title>
    <link href="/2023/07/14/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E4%BB%A3%E7%A0%81%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BAscip/"/>
    <url>/2023/07/14/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/%E4%BB%A3%E7%A0%81%E7%B4%A2%E5%BC%95%E6%9E%84%E5%BB%BAscip/</url>
    
    <content type="html"><![CDATA[<p><strong>代码索引构建</strong></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>代码跳转&#x2F;代码搜索</p><h2 id="主流方案"><a href="#主流方案" class="headerlink" title="主流方案"></a><strong>主流方案</strong></h2><table><thead><tr><th>协议格式</th><th>简介</th></tr></thead><tbody><tr><td>LSP</td><td>适合有源代码的本地仓库,与LSP-Server进行交互</td></tr><tr><td>LSIF</td><td>支持LSP协议格式的离线索引结构</td></tr><tr><td>SCIP</td><td>source-graph开源,解决了LSIF使用过程中遇到的问题,比如json格式没有很强的规范性,由于LSIF的自增主键造成的一系列问题</td></tr></tbody></table><h3 id="对自研代码索引格式进行探索"><a href="#对自研代码索引格式进行探索" class="headerlink" title="对自研代码索引格式进行探索"></a><strong>对自研代码索引格式进行探索</strong></h3><p>由于scip需要对项目进行编译,kuaishou整体的编译速度P50在78s左右,为了提升编译速度,对自研实现索引功能也进行了一定的探索,java的编译过程如下:</p><p><img src="/assets/out-20230714181100859.png" alt="img"></p><p>通过java-parser生成代码的AST树,通过访问ast树进行解析,理论上也能实现相同的功能,但是经过测试发现通过AST解析处理,有两个问题比较难解决:</p><p>1.经过语法分析生成的树带有了语法本身的概念,比如Method&#x2F;field,但实际建立索引的过程是基于更底层的「位置」的概念,与语法树并不相关,所以通过ast建立索引比较困难,猜测scip应该是在生成了tokens流就进行了处理(未论证)</p><p>2.进行ast解析的话如果不配置symbolresolver,得不到全限定名,因此在使用过程中也需要配合maven等构建工具使用,如此以来,与现成的scip方案相比 不具备优势</p><h3 id="自研方案和scip方案对比"><a href="#自研方案和scip方案对比" class="headerlink" title="自研方案和scip方案对比"></a><strong>自研方案和scip方案对比</strong></h3><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>自研</td><td>1.可以实现增量代码分析,速度快2.可以定制更为简单的索引格式提升存储效率和访问速度</td><td>1.工作量高2.大规模使用情况不容易被验证3.需要兼容不同的语言</td></tr><tr><td>SCIP</td><td>1.开源且被sourcegraph公司验证2.多种语言的支持</td><td>1.需要编译2.生成的索引格式复杂</td></tr></tbody></table><h2 id="整体实现"><a href="#整体实现" class="headerlink" title="整体实现"></a><strong>整体实现</strong></h2><h3 id="数据生成与消费"><a href="#数据生成与消费" class="headerlink" title="数据生成与消费"></a><strong>数据生成与消费</strong></h3><h4 id="索引文件生成"><a href="#索引文件生成" class="headerlink" title="索引文件生成"></a><strong>索引文件生成</strong></h4><p>索引文件的生成过程如下图</p><p>1.触发时机: mr创建&#x2F;更新</p><p>2.主要通过halo流水线插件实现scip文件的生成</p><p>3.整个仓库的scip文件整体上传到blobstore进行存储</p><p>4.通过blob的rocketmq消息通知解析模块进行解析</p><p>5.解析之后的数据进入mysql进行存储</p><p><img src="https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAC8czoh0YonXpH7rcn6LpdC:-251077824295707218fcAC8czoh0YonXpH7rcn6LpdC:1689331218473" alt="img"></p><p><strong>索引文件解析和存储</strong></p><p>目前kdev-mr每天创建的MR单数为2k-3k,所属仓库800-1000个,版本数量(5k-6k),diff文件数量10w(所有版本)左右,全仓库构建的话大概需要构建 3000<em>1000&#x3D;300w次,以ks-serveree-cr项目为例,其中的occurrence(某个文档的某个位置出现的字符)有106w,如果都建立索引的话,数据量基数大概 1000 * 106w &#x3D; 1亿,如果活跃仓库一直是这些的话,后续增长的就是diff文件中的occurrence了,假定每个版本变更10个文件,且假定每个diff文件中有1000个occurrence,那么每天新增的数量是10</em>1000&#x3D;1w</p><p>存储方案采用mysql分表存储</p><p>存储结构:</p><p>为了提升可扩展性,整体存储结构的设计尽可能的将索引本身和业务进行分离,本期采用mr触发的方式,后面如果改成代码仓库触发,可以尽可能的少动底层结构</p><p>字面量表: 作为基础表,解决字符串重复存储的问题</p><p>字符表:唯一定位一个仓库中的一个字符</p><p>hash_id生成策略: hash(文件路径+字面量+range+引用类型)  </p><p>讨论:是否需要增加projectId维度</p><p>索引表:表示一次索引的生成过程,module表示引用的模块数据</p><p>symbol增加版本信息(?)</p><p><strong><img src="/assets/out-20230714181100824.png" alt="img"></strong></p><p>整体的存储方案大概如下图</p><p><strong><img src="/assets/out-9329460.png" alt="img"></strong></p><p>hover或者点击跳转到定义的时候:</p><p>1.查询symbol信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span> symbol where <span class="hljs-attribute">file_string_id</span>=hash(filePath) <br><span class="hljs-keyword">and</span> <span class="hljs-attribute">start_line</span>=1 <span class="hljs-keyword">and</span> <span class="hljs-attribute">start_col</span>=2;<br></code></pre></td></tr></table></figure><p>2.根据symbol_string 和refrence_type查询具体文件信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span> symbol where <span class="hljs-attribute">symbol_string_id</span>=<span class="hljs-string">&quot;xxxx&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-attribute">refrence_type</span>=1<br></code></pre></td></tr></table></figure><p>3.根据查到的结果用index表进行过滤</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span>  * <span class="hljs-keyword">from</span> <span class="hljs-keyword">index</span> <span class="hljs-keyword">where</span> project_id=<span class="hljs-number">123</span> <br>and commit_hash=<span class="hljs-string">&#x27;xxx&#x27;</span> and symbol_hash_id <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;xxxx&#x27;</span>,<span class="hljs-string">&#x27;zzzz&#x27;</span>)<br></code></pre></td></tr></table></figure><p>查看接口的实现类</p><p>1.查询symbol信息</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span> symbol where <span class="hljs-attribute">file_string_id</span>=hash(filePath) <br><span class="hljs-keyword">and</span> <span class="hljs-attribute">start_line</span>=1 <span class="hljs-keyword">and</span> <span class="hljs-attribute">start_col</span>=2;<br></code></pre></td></tr></table></figure><p>2.查询relation关系</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">select * <span class="hljs-keyword">from</span> symbol_relation where <span class="hljs-attribute">right_symbol_string_id</span>=<span class="hljs-string">&#x27;xxxx&#x27;</span><br><span class="hljs-keyword">and</span> <span class="hljs-attribute">relation_type</span>=1;<br></code></pre></td></tr></table></figure><h4 id="跨仓库索引"><a href="#跨仓库索引" class="headerlink" title="跨仓库索引"></a><strong>跨仓库索引</strong></h4><p> 目前的触发方式是mr触发,因此如果依赖库没有提过mr(比如kconf这种),那么将无法进行跳转</p><p> 如果假设目标库有索引存在,则需要借助index中的module字段 通过查询制品库获取到依赖仓库的信息,包括仓库id,发布制品的commitId等信息,</p><p>这部分中间信息需要制品库和编译系统协助建设,现状是制品库直接获取的流水线发包时候的信息,流水线发包的这部分数据也有过期时间,目前是存5个版本+5天的有效数据,如果有新增发包任务,则按照上述策略对历史数据进行删除</p><p>以这部分中间信息为媒介,通过上面的索引查询方式进行处理</p><h4 id="增量构建"><a href="#增量构建" class="headerlink" title="增量构建"></a><strong>增量构建</strong></h4><p>目前只能做到增量插入,还做不到增量构建,对于一个mr的版本迭代,在生成新的索引之后,通过比较与前一个版本的变更文件,进行symbols的增量插入,整体流程</p><p><img src="https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAC8czoh0YonXpH7rcn6LpdC:-3490827655101096522fcAC8czoh0YonXpH7rcn6LpdC:1689331218474" alt="img"></p><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a><strong>数据清理</strong></h3><p> 暂无</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a><strong>参考文档</strong></h2><p><a href="https://www.toutiao.com/article/7108906404429185574/?app=news_article&timestamp=1655259304&use_new_style=1&req_id=20220615101503010151204214003BFB4F&group_id=7108906404429185574&share_token=E4E23709-4443-4718-BA7E-0EF9686CE1E2&tt_from=copy_link&utm_source=copy_link&utm_medium=toutiao_ios&utm_campaign=client_share&source=m_redirect">阿里代码索引实践</a></p><p><a href="https://microsoft.github.io/language-server-protocol/overviews/lsp/overview/">LSP&#x2F;LSIF</a></p><p><a href="https://about.sourcegraph.com/blog/announcing-scip">SCIP简介(包含和LSIF的对比)</a></p><p><a href="https://github.com/sourcegraph/scip/blob/main/scip.proto">SCIP具体协议内容</a></p><p><a href="https://github.com/sourcegraph/scip-java">scip-java Github地址</a></p><p><a href="https://sourcegraph.github.io/scip-java/docs/getting-started.html">scip-java主页</a></p><p><a href="https://scalameta.org/docs/semanticdb/guide.html">sematicDB介绍</a></p><p><a href="https://docs.corp.kuaishou.com/k/home/VHJA4UFrYYxw/fcADBhc3sVyvoygK_sJ3EIcAy">上一版本代码索引方案</a></p><h2 id="附-proto解析之后格式"><a href="#附-proto解析之后格式" class="headerlink" title="附(proto解析之后格式):"></a><strong>附(proto解析之后格式):</strong></h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">documents</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">  relative_path:</span> <span class="hljs-string">&quot;ks-serveree-cr-component/src/main/java/com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser.java&quot;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . org/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">26</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . org/springframework/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">27</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">37</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . org/springframework/stereotype/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">38</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">47</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven maven/org.springframework/spring-context 5.1.10-kwai-12 org/springframework/stereotype/Component#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">41</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">42</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">48</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">49</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">55</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">56</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">62</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">63</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">74</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/CrActionLog#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">41</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">42</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">48</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">49</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">54</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">55</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">72</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/DetailOperateType#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">41</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">42</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">47</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/utils/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">48</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">57</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/utils/I18nUtils#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">41</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">42</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">44</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">45</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">53</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">54</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">56</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">57</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">74</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven maven/org.springframework/spring-context 5.1.10-kwai-12 org/springframework/stereotype/Component#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#`&lt;init&gt;`().&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">54</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/LogParserInter#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven jdk 8 java/lang/Override#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">34</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#parse().&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">35</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">55</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ActionLogParseTarget#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">56</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">62</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 0&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">12</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">18</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">36</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">21</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">37</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">51</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ActionLogParseTarget#getCrActionLog().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">19</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/CrActionLog#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">20</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 1&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">34</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 0&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">41</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">55</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ActionLogParseTarget#getCrActionLog().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/DetailOperateType#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">26</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">37</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 2&quot;</span><br><span class="hljs-symbol">    symbol_roles:</span> <span class="hljs-number">1</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">51</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">52</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">65</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/CrActionLog#getObjectType().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">68</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">81</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/ObjectTypeEnum#getDetailType().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">82</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">93</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">25</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">94</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">108</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/CrActionLog#getOperateType().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">26</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">26</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">33</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#builder().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">27</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">23</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#action().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">27</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">35</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">27</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">36</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/DetailOperateType#name().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">27</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#actionName().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 2&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">51</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/event/DetailOperateType#operateDesc().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">34</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#actionDescription().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">35</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">44</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/utils/I18nUtils#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">45</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">67</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/utils/I18nUtils#getActionLogDescByDesc().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">68</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">79</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 1&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">29</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">80</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">88</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/common/domain/entity/CrActionLog#getTitle().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#actionAtGitlab().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven jdk 8 java/lang/Boolean#&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">30</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">40</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">45</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven jdk 8 java/lang/Boolean#FALSE.&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">31</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#display().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">occurrences</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">32</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">17</span><br><span class="hljs-symbol">    range:</span> <span class="hljs-number">22</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/vo/response/vo/ActionLogResponse#ActionLogResponseBuilder#build().&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\n@Component(\&quot;commonLogParser\&quot;)\npublic class CommonLogParser\n```&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot; log\350\256\260\345\275\225\347\232\204\351\200\232\347\224\250\345\256\236\347\216\260\347\261\273\n\n @author yangsimeng &lt;yangsimeng@kuaishou.com&gt;\n Created on 2021/3/26\n&quot;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/LogParserInter#&quot;</span><br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#`&lt;init&gt;`().&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\npublic CommonLogParser()\n```&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommonLogParser#parse().&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\n@Override\npublic ActionLogResponse parse(ActionLogParseTarget target)\n```&quot;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/AddPatchLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ChangeNotifierLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ChangeTargetBranchParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommentLabelLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CommentLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/CrCreateLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/LabelLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/MergeDeclineActionLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/MilestoneLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/RejectMergeActionLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/RelatedResourceLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/RelatedTeamLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/ReviewActionLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/UndoRejectMergeActionLogParser#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-title class_">relationships</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">      symbol:</span> <span class="hljs-string">&quot;semanticdb maven . . com/kuaishou/serveree/cr/component/service/logparser/LogParserInter#parse().&quot;</span><br><span class="hljs-symbol">      is_reference:</span> true<br><span class="hljs-symbol">      is_implementation:</span> true<br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 0&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\nActionLogParseTarget target\n```&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 1&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\nCrActionLog crActionLog\n```&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-title class_">symbols</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    symbol:</span> <span class="hljs-string">&quot;local 2&quot;</span><br><span class="hljs-symbol">    documentation:</span> <span class="hljs-string">&quot;```java\nDetailOperateType operateType\n```&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>智力测验题</title>
    <link href="/2023/07/13/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%99%BA%E5%8A%9B%E6%B5%8B%E9%AA%8C%E9%A2%98/"/>
    <url>/2023/07/13/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%99%BA%E5%8A%9B%E6%B5%8B%E9%AA%8C%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="黑色白色"><a href="#黑色白色" class="headerlink" title="黑色白色"></a>黑色白色</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>假设你被蒙住眼睛，在你面前放着两个质地完全一致，但颜色不一致的棋子。其中一个是白色，一个是黑色，你无法通过触摸辨别棋子颜色。</p><p>在你面前站着两个人，一个人说真话，一个人说假话，二者彼此知道对方说的是真话还是假话。你可以问这两个人一个问题，这两个人只能回答黑色或者白色，其他内容无法回答。</p><p>请问你询问什么问题可以判断手里的棋子颜色？注意，你只能通过问一次问题来判断。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>你可以问：“如果我问另一个人，这个棋子是什么颜色，他会回答什么？”<br>如果你手上拿的是白棋，那么说真话的那个人会知道另一个人会说谎，所以他会回答“黑色”；而说谎话的那个人则会照着他自己的习惯性撒谎回答“黑色”。因此无论问哪个人，“黑色”都是唯一的答案。同理，如果你手上拿的是黑棋，那么无论问哪个人，“白色”都是唯一的答案。</p><p>本题的核心是：一个问题要把两个人都问到，因为二者的互斥性，通过此互斥性来保证答案的唯一</p><h2 id="奸细"><a href="#奸细" class="headerlink" title="奸细"></a>奸细</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>已知角色：发信人、收信人、送信人、人质</p><p>已知物品：</p><ul><li>发信人有：金色锁、金色钥匙、一张写有密码的信纸、一个铁箱</li><li>收信人有：粉碎机</li><li>收信人有：银色锁、银色钥匙、笼子(囚禁人质)</li></ul><p>游戏场景：</p><ul><li><p>发信人场景：委托送信人传送物品，接受送信人传送的物品</p></li><li><p>送信人场景：在发信人和收信人之间传送物品</p></li><li><p>收信人场景：接受送信人传送的物品，委托送信人传送物品</p></li></ul><p>规则：</p><ul><li>规则1：金色锁只能金色钥匙才能打开，银色锁只能银色钥匙才能打开</li><li>规则2：铁箱因尺寸原因无法投入粉碎机，其他物品均可投入粉碎机。对于可以粉碎的物品，送信人一定会粉碎</li><li>规则3：如果物品不能损坏，则送信人一定会把委托传送的物品传送至目的地</li><li>规则4：送信人可以多次来回传送物品</li></ul><p>游戏目的：解救人质，人质被困在收信人的笼子里，笼子的锁需要发信人持有的信纸上的密码才能打开。请问如何做才能解救人质？</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><p>以下是解决这个问题的步骤：</p><ol><li>发信人首先把写有密码的信纸放入铁箱中，并用金色锁把铁箱锁上。然后，他把这个被锁上的铁箱交给送信人。</li><li>送信人无法打开铁箱也无法将其放入粉碎机，于是他将铁箱带到收信人那里。</li><li>收信人接收到铁箱后，他无法打开它，但他可以用银色锁将铁箱再锁上一次（现在铁箱上有两把锁），然后把这个被两把锁锁住的铁箱交给送信人。</li><li>送信人将这个被两把锁锁住的铁箱带回到发信人那里。</li><li>发信人接收到铁箱后，他使用金色钥匙打开金色锁，然后将只剩银色锁的铁箱交给送信人。</li><li>送信人把只剩银色锁的铁箱带回给收信人。</li><li>收信人使用银色钥匙打开银色锁，打开铁箱，获得密码。</li><li>收信人使用获得的密码打开囚禁人质的笼子，从而解救了人质。</li></ol><p>总的来说，这个策略的关键在于让每个人都使用他们自己的锁来保护铁箱，使得送信人无法访问到信纸。发信人先用自己的锁保护铁箱，然后收信人加上他的锁，最后发信人移除他自己的锁，这样收信人就可以使用他的钥匙来打开他的锁，并最终访问到信纸。</p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>智力测验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>智力测验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea激活</title>
    <link href="/2023/07/12/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/idea%E6%BF%80%E6%B4%BB/"/>
    <url>/2023/07/12/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/idea%E6%BF%80%E6%B4%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="2023-2-2版本破解"><a href="#2023-2-2版本破解" class="headerlink" title="2023.2.2版本破解"></a>2023.2.2版本破解</h2><p><a href="https://www.exception.site/essay/idea-reset-eval">https://www.exception.site/essay/idea-reset-eval</a></p><p>破解工具：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk">补丁安装教程：<br>https:<span class="hljs-regexp">//</span>www.exception.site<br><br>补丁网盘链接:<br>链接：https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">1</span>SLqgNTlowhCz_f8SXCuEhg?pwd=rp79 <br>提取码：rp79<br><br>备用链接:<br>链接：https:<span class="hljs-regexp">//</span>pan.baidu.com<span class="hljs-regexp">/s/</span><span class="hljs-number">1</span>DzOZztyQDwlmzsFWdk_6CQ?pwd=<span class="hljs-number">6200</span> <br>提取码：<span class="hljs-number">6200</span><br><br>无限速蓝奏云网盘链接：https:<span class="hljs-regexp">//</span>wwc.lanzoul.com/iSxmd0e57peb<br></code></pre></td></tr></table></figure><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者几乎试了网上几乎所有的 IDEA 破解方案，废了好大气力，汇总了目前网上比较靠谱的三种破解方案（<strong>这三种都是笔者亲测成功的</strong>），小伙伴们任选其一即可：</p><ul><li><strong>第一种【推荐】：👉通过脚本 + 激活码（全自动模式）</strong>，<strong>即本文教程所写，这种方法适合最新的几个版本，具体步骤跟着本文教程一步一步来，运行一下激活脚本，一分钟即可搞定，超级简单</strong>。无图无真相，下面是我激活成功后的截图：</li></ul><blockquote><p><strong>PS: 此方法和下面的第二种方法的补丁原理都是暴力拦截了 IDEA 的剩余使用期网络请求，实际上等于永久激活，至于激活到哪天，在之前的 <code>2021.3.3</code> <code>2021.3.2</code> 等老版本中是可以手动配置的，比如改成激活到 2099 年。可能是太高调了，最新的版本只能显示到 2025 年, 其实效果还是一样的, 都是永久激活，可放心食用。</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-a172f5b2c69199001f521eda3706e9ea.jpg" alt="IDEA 2023.1.3 成功破解激活截图"></p><ul><li><p><strong>第二种：👉<a href="https://www.exception.site/essay/idea-yongjiu-jihuoma">通过破解补丁 + 激活码（手动引入补丁）</a>，相比较第一种直接执行一个脚本就行了，这种方式需要手动引用破解补丁，再输入激活码。此法同样仅适用于最新的几个版本。</strong></p></li><li><p><strong>第三种</strong>：👉 **<a href="https://www.exception.site/essay/how-to-free-use-idea-202022-by-resigter-code">无限重置 IDEA 30 天试用期（适合比较老的版本）</a>**；</p></li></ul><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><strong>本教程适用于 JetBrains 全系列产品，包括 IDEA、Pycharm、WebStorm、Phpstorm、Datagrip、RubyMine、CLion、AppCode 等。</strong></li><li><strong>本教程适用 Windows&#x2F;Mac&#x2F;Linux 系统，文中以 Windows 系统为例做讲解，其他系统同样参考着本教程来就行。</strong></li></ul><h2 id="第一步：下载-IDEA-安装包"><a href="#第一步：下载-IDEA-安装包" class="headerlink" title="第一步：下载 IDEA 安装包"></a>第一步：下载 IDEA 安装包</h2><p>访问 IDEA 官网，下载 IDEA 2023.1.3 版本的安装包，下载链接如下 :</p><p><a href="https://www.jetbrains.com/idea/download/">https://www.jetbrains.com/idea/download/</a></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-137723fb222833d197cf2c7f77a5b0a2.jpg" alt="下载 IDEA 2023.1.3 安装包"></p><p>打开页面后，点击 <code>Download</code> 按钮, 等待 IDEA 专业版下载完毕。</p><h2 id="第二步：卸载老版本-IDEA-未安装则不用管，跳过看下面步骤"><a href="#第二步：卸载老版本-IDEA-未安装则不用管，跳过看下面步骤" class="headerlink" title="第二步：卸载老版本 IDEA(未安装则不用管，跳过看下面步骤)"></a>第二步：卸载老版本 IDEA(未安装则不用管，跳过看下面步骤)</h2><p>注意，安装新版本 IDEA 之前，如果本机安装过老版本的 IDEA, <strong>需要先彻底卸载，以免两者冲突，导致破解失败。</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-b05468580ec2e20e54f8331c184719dc.jpg" alt="破解之前，先卸载老版本 IDEA"></p><p>卸载完成后，点击 <code>Close</code> 按钮关闭弹框：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-03cb5a6f95c6b9b69228f71caf44aef0.jpg" alt="卸载 IDEA 完成"></p><h2 id="第三步：安装-IDEA-2023-1-3-版本"><a href="#第三步：安装-IDEA-2023-1-3-版本" class="headerlink" title="第三步：安装 IDEA 2023.1.3 版本"></a>第三步：安装 IDEA 2023.1.3 版本</h2><p>卸载老版本 IDEA 完成后，双击刚刚下载好的 IDEA <code>2023.1.3</code> 版本安装包。弹框会提示选择安装路径，我这里直接选择的默认安装路径</p><p><code>C:\Program Files\JetBrains\IntelliJ IDEA 2023.1.3</code> , 然后点击 <code>Next</code> 按钮：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-5fb78ef3f6e270475862c41c416f98ca.png" alt="安装 IDEA 2023.1.3 版本"></p><p>然后，勾选 <code>Create Desktop Shortcut</code> 创建 IDEA 桌面快捷启动方式，以方便后面快速打开 IDEA，再点击 <code>Next</code> 按钮 :</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-db5058e604e65e45103af0ff0243a51a.png" alt="开始安装 IDEA 2023.1.3 版本：创建快捷启动图标"></p><p>点击 <code>Install</code> 按钮，开始安装：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-ded9e81c8006802c56bd1c71b4d3f06a.png" alt="开始安装 IDEA 2023.1.3 版本：点击 Install 按钮"></p><p>等待安装完成后，勾选 <code>Run IntellJ IDEA</code>, 点击 <code>Finish</code> 按钮即运行 IDEA :</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-b33c2c54b97748172fe50aa110abbfd5.png" alt="安装 IDEA 2023.1.3 版本成功"></p><p>IDEA 运行成功后，会弹出如下对号框，强制用户需要先登录 JetBrains 账户才能使用：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-57ebdc80b926e95d072201c33aa166ae.png" alt="IDEA 2023.1.3 版本提示需要先登录 JetBrains 账户"></p><p><strong>不用管登录的事，点击 <code>Exit</code> 按钮退出对话框</strong>，装备开始破解激活。</p><h2 id="第四步：破解补丁下载"><a href="#第四步：破解补丁下载" class="headerlink" title="第四步：破解补丁下载"></a>第四步：破解补丁下载</h2><p>破解补丁我放置在了网盘中，提供了多个备用链接，以防下载失效。</p><blockquote><p><strong>提示：破解补丁的网盘链接文末获取~</strong></p></blockquote><p>补丁下载成功后，记得 <strong>先解压</strong> **, 解压后的目录如下, <strong>本文后面所需补丁都在下面标注的这个文件夹中</strong>：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-03d0eaba2ac1ba7616d1f0110d9a5f21.png" alt="IDEA 破解补丁下载"></p><p>点击【方式3】文件夹 , 进入到文件夹 <code>/jetbra</code>，目录如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-69cc48d9d2d003bb9a4857c4e35a5a1b.png" alt="IDEA 破解补丁文件夹最底层目录"></p><h2 id="第五步：开始破解"><a href="#第五步：开始破解" class="headerlink" title="第五步：开始破解"></a>第五步：开始破解</h2><h3 id="Windows-用户"><a href="#Windows-用户" class="headerlink" title="Windows 用户"></a>Windows 用户</h3><p>将上面图示的补丁的所属文件夹 <code>/jetbra</code> 复制电脑某个位置，笔者这里放置到了 <code>D:/</code> 盘根目录下:</p><blockquote><p>注意： <strong>补丁所属文件夹需单独存放</strong>，且<strong>放置的路径不要有中文与空格</strong>，以免 IDEA 读取补丁错误。</p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-6bb52f548dc545b5d471d41429c398f1.png" alt="将 IDEA 破解补丁放置到 D 盘下"></p><p>点击进入 <code>/jetbra</code> 补丁目录，再点击进入 <code>/scripts</code> 文件夹，双击执行 <code>install-current-user.vbs</code> 破解脚本：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-58ae41f4e1d3b60c95355a66d1680a8d.png" alt="IDEA 破解补丁执行脚本"></p><blockquote><p><strong>注意：如果执行脚本被安全软件提示有风险拦截，允许执行即可。</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-4f504781bc5052dec0bfbf05ce56251d.png" alt="IDEA 破解脚本执行后弹框提示信息"></p><p>会提示安装补丁需要等待数秒。点击【<strong>确定</strong>】按钮后，过程大概 10 - 30 秒，如看到弹框提示 <code>Done</code> 时，表示激活破解成功：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-58ba53cd2a06baab2fe901bf4b857c86.png" alt="补丁执行成功后，提示 Done"></p><h3 id="Mac-Linux-用户"><a href="#Mac-Linux-用户" class="headerlink" title="Mac &#x2F; Linux 用户"></a>Mac &#x2F; Linux 用户</h3><p>Mac &#x2F; Linux 系统与上面 Windows 系统一样，需将补丁所属文件 <code>/jetbra</code> 复制到某个路径，且<strong>路径不能包含空格与中文</strong>。</p><p>之后，打开终端，进入到 <code>/jetbra/scripts</code> 文件夹， 执行 <code>install.sh</code> 脚本, 命令如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo bash install<span class="hljs-selector-class">.sh</span><br></code></pre></td></tr></table></figure><p>看到提示 <code>Done</code> , 表示激活成功。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-4e074d8f1831d4c037d57daa1706cd71.png" alt="Mac/Linux 系统执行破解补丁成功后，提示 Done"></p><p>部分小伙伴 Mac 系统执行脚本遇到如下错误：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-7c09eb8fc38913a2bc68aa40dd7b86dc.jpg" alt="Mac 执行破解脚本报错"></p><p><strong>解决方法：</strong></p><p>可先执行如下命令，再执行脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">export LC_COLLATE=&#x27;C&#x27;<br>export LC_CTYPE=&#x27;C&#x27;<br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-36d1f1dcedacb93e32a15c57af7d5ab3.jpg"></p><h3 id="执行脚本，都干了些啥？"><a href="#执行脚本，都干了些啥？" class="headerlink" title="执行脚本，都干了些啥？"></a>执行脚本，都干了些啥？</h3><ul><li><p>Windows 用户执行脚本后，脚本会自动在环境变量 -&gt; 用户变量下添加了 <code>IDEA_VM_OPTIONS</code> 变量，变量值为 <code>/jetbra</code> 文件夹下的 <code>.vmoptions</code> 参数文件绝对路径，如下所示：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-342e32b9d98e58d536226693543bb21a.png"></p><p>然后，脚本自动在 <code>idea.vmoptions</code> 文件中引用了破解补丁 ：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-356f0711e5974a25237cdb960795f50e.png"></p><blockquote><p><strong>提示： 细心的小伙伴应该也发现了，本文的破解方式与文章开头《第二种 IDEA 破解方法》的区别在于，这种方式提供了自动化脚本，脚本免去了手动引入补丁的繁琐步骤，一切都由脚本来完成了。</strong></p></blockquote></li><li><p>Mac &#x2F; Linux 用户执行脚本后，脚本会自动在当期用户环境变量文件中添加了相关参数文件，Mac &#x2F; Linux 需重启系统，以确保环境变量生效。</p></li></ul><p>小伙伴们也可自行检查一下，如果没有自动添加这些参数，说明脚本执行没有成功。</p><h2 id="第六步：重启-IDEA"><a href="#第六步：重启-IDEA" class="headerlink" title="第六步：重启 IDEA"></a>第六步：重启 IDEA</h2><p><strong>脚本执行成功后，一定要重启 IDEA ~~</strong></p><p><strong>脚本执行成功后，一定要重启 IDEA ~~</strong></p><h2 id="第七步：填入指定激活码完成激活"><a href="#第七步：填入指定激活码完成激活" class="headerlink" title="第七步：填入指定激活码完成激活"></a>第七步：填入指定激活码完成激活</h2><p>重新打开 IDEA 后，复制下面的激活码：</p><p>6G5NXCPJZB-eyJsaWNlbnNlSWQiOiI2RzVOWENQSlpCIiwibGljZW5zZWVOYW1lIjoic2lnbnVwIHNjb290ZXIiLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJQU0kiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiSUkiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUEMiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJmYWxsYmFja0RhdGUiOiIyMDI1LTA4LTAxIiwicGFpZFVwVG8iOiIyMDI1LTA4LTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwiZmFsbGJhY2tEYXRlIjoiMjAyNS0wOC0wMSIsInBhaWRVcFRvIjoiMjAyNS0wOC0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsImZhbGxiYWNrRGF0ZSI6IjIwMjUtMDgtMDEiLCJwYWlkVXBUbyI6IjIwMjUtMDgtMDEiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA5MDJQU0FOMDAwMDA1IiwiaGFzaCI6IlRSSUFMOi0xMDc4MzkwNTY4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-SnRVlQQR1&#x2F;9nxZ2AXsQ0seYwU5OjaiUMXrnQIIdNRvykzqQ0Q+vjXlmO7iAUwhwlsyfoMrLuvmLYwoD7fV8Mpz9Gs2gsTR8DfSHuAdvZlFENlIuFoIqyO8BneM9paD0yLxiqxy&#x2F;WWuOqW6c1v9ubbfdT6z9UnzSUjPKlsjXfq9J2gcDALrv9E0RPTOZqKfnsg7PF0wNQ0&#x2F;d00dy1k3zI+zJyTRpDxkCaGgijlY&#x2F;LZ&#x2F;wqd&#x2F;kRfcbQuRzdJ&#x2F;JXa3nj26rACqykKXaBH5thuvkTyySOpZwZMJVJyW7B7ro&#x2F;hkFCljZug3K+bTw5VwySzJtDcQ9tDYuu0zSAeXrcv2qrOg&#x3D;&#x3D;-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCUlaUFc1wf+CfY9wzFWEL2euKQ5nswqb57V8QZG7d7RoR6rwYUIXseTOAFq210oMEe++LCjzKDuqwDfsyhgDNTgZBPAaC4vUU2oy+XR+Fq8nBixWIsH668HeOnRK6RRhsr0rJzRB95aZ3EAPzBuQ2qPaNGm17pAX0Rd6MPRgjp75IWwI9eA6aMEdPQEVN7uyOtM5zSsjoj79Lbu1fjShOnQZuJcsV8tqnayeFkNzv2LTOlofU&#x2F;Tbx502Ro073gGjoeRzNvrynAP03pL486P3KCAyiNPhDs2z8&#x2F;COMrxRlZW5mfzo0xsK0dQGNH3UoG&#x2F;9RVwHG4eS8LFpMTR9oetHZBAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBABqRoNGxAQct9dQUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE&#x2F;BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5&#x2F;FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB&#x2F;R5oUlebwaTE6WZNBs+TA&#x2F;qPj+5&#x2F;we9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329&#x2F;WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V&#x2F;0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ&#x2F;c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0&#x2F;&#x2F;lOmVya&#x2F;PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0&#x2F;WFPl1aw5VV&#x2F;VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH&#x2F;0onD</p><p>粘贴到输入框内，点击 <code>Activate</code> 按钮，就激活成功了。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-6a74180afd427179101f7dc02c3f577e.png" alt="输入 IDEA 破解激活码"></p><blockquote><p>PS: 有部分小伙伴反应，重启 IDEA 填入激活码依然无法激活，重启系统才行，如果有小伙伴遇到这种情况，不妨试试看~</p></blockquote><p>激活成功后，又可以开心的 coding 了 ~</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-a172f5b2c69199001f521eda3706e9ea.jpg" alt="IDEA 2023.1.3 版本激活破解成功"></p><h2 id="你可能会遇到的问题"><a href="#你可能会遇到的问题" class="headerlink" title="你可能会遇到的问题"></a>你可能会遇到的问题</h2><h3 id="一切按照教程来，输入激活码提示-Key-is-invalid？"><a href="#一切按照教程来，输入激活码提示-Key-is-invalid？" class="headerlink" title="一切按照教程来，输入激活码提示 Key is invalid？"></a>一切按照教程来，输入激活码提示 <code>Key is invalid</code>？</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689317048-d5e7424dcebf9a132fe1815236774644.jpg" alt="IDEA 输入激活码提示 key is invalid"></p><p>输入激活码提示 <code>key is invalid</code>, 常见原因汇总到下面这篇文章了，可参考对照一下：</p><p><a href="https://www.quanxiaoha.com/idea-pojie/ide-key-is-invalid.html">《JetBrains 产品输入激活码 Key is invalid 解决方案》</a></p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><h3 id="激活成功后，不要升级-IDEA-版本"><a href="#激活成功后，不要升级-IDEA-版本" class="headerlink" title="激活成功后，不要升级 IDEA 版本"></a>激活成功后，不要升级 IDEA 版本</h3><p>官方反制手段越来越严厉，这个版本能激活，新版本大概率补丁就被限制了。所以，如果打开 IDEA 后，右下角若出现提示升级新版本，请不要升级版本。能用就行，它不香嘛！</p><blockquote><p>也可以手动关闭升级提示，这样就可以防止控制不住自己升级了，如何关闭，参考下面的文章：</p><p><a href="https://www.exception.site/article/30">👉《IntelliJ IDEA 如何关闭更新提示？》</a></p></blockquote><h3 id="激活成功后，补丁文件夹能不能删掉或者移动？"><a href="#激活成功后，补丁文件夹能不能删掉或者移动？" class="headerlink" title="激活成功后，补丁文件夹能不能删掉或者移动？"></a>激活成功后，补丁文件夹能不能删掉或者移动？</h3><p>上文中说到，执行脚本后会添加环境变量，变量值对应了你放置补丁位置的路径，删除掉或者移动，再打开 IDEA 就找不到对应文件了，激活也就失效了。放着吃灰就行，别动它。</p><h2 id="你可能感兴趣的"><a href="#你可能感兴趣的" class="headerlink" title="你可能感兴趣的"></a>你可能感兴趣的</h2><p><a href="https://www.quanxiaoha.com/idea/install-idea.html">👉《IDEA 使用教程 (图文讲解)》</a></p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>本教程只做个人学习使用，请勿用于商业用途！</p><ul><li><p>若资金允许，请点击 <a href="https://www.jetbrains.com/idea/buy/" title="https://www.jetbrains.com/idea/buy/">https://www.jetbrains.com/idea/buy/</a> 购买正版，谢谢合作！</p></li><li><p>学生凭学生证可免费申请 <a href="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-%E5%AD%A6%E7%94%9F%E6%8E%88%E6%9D%83%E7%94%B3%E8%AF%B7%E6%96%B9%E5%BC%8F" title="https://sales.jetbrains.com/hc/zh-cn/articles/207154369-学生授权申请方式">https://sales.jetbrains.com/hc/zh-cn/articles/207154369-学生授权申请方式</a> 正版授权！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>工具激活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具激活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring当中的事务</title>
    <link href="/2023/07/11/Spring/spring%E5%BD%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/"/>
    <url>/2023/07/11/Spring/spring%E5%BD%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="spring事务失效的12种场景"><a href="#spring事务失效的12种场景" class="headerlink" title="spring事务失效的12种场景"></a>spring事务失效的12种场景</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。</p><p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p>一个简单的注解：<code>@Transactional</code>，就能轻松搞定事务。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689141796-e84f42c674dc39fcba333a5ded01ae91.jpeg"></p><h2 id="一-事务不生效"><a href="#一-事务不生效" class="headerlink" title="一 事务不生效"></a>一 事务不生效</h2><h3 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    @<span class="hljs-title class_">Transactional</span><br>    private <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>         <span class="hljs-title function_">saveData</span>(userModel);<br>         <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的访问权限被定义成了<code>private</code>，这样会导致事务失效，spring要求被代理方法必须是<code>public</code>的。</p><p>说白了，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是<code>public</code>，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2. 方法用final修饰"></a>2. 方法用final修饰</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jave">@Service<br>public class UserService &#123;<br><br>    @Transactional<br>    public final void add(UserModel userModel)&#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法被定义成了<code>final</code>的，这样会导致事务失效。</p><p>为什么？</p><p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p><p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p><blockquote><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p></blockquote><h3 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-title function_">updateStatus</span>(userModel);<br>    &#125;<br><br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        <span class="hljs-title function_">doSameThing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成生成新事务。</p><p>但是add方法上的事务是成功创建的，如果updateStatus方法抛出异常，依旧能够触发回滚机制</p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。即同一个类的方法A调用方法B，如果A没有事务，B有事务，那么整个事务机制也是不生效的。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法"><a href="#3-1-新加一个Service方法" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Servcie</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br>   @<span class="hljs-title class_">Autowired</span><br>   prvate <span class="hljs-title class_">ServiceB</span> serviceB;<br><br>   public <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">User user</span>) &#123;<br>         <span class="hljs-title function_">queryData1</span>();<br>         <span class="hljs-title function_">queryData2</span>();<br>         serviceB.<span class="hljs-title function_">doSave</span>(user);<br>   &#125;<br> &#125;<br><br> @<span class="hljs-title class_">Servcie</span><br> public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceB</span> &#123;<br><br>    @<span class="hljs-title class_">Transactional</span>(rollbackFor=<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSave</span>(<span class="hljs-params">User user</span>) &#123;<br>       <span class="hljs-title function_">addData1</span>();<br>       <span class="hljs-title function_">updateData2</span>();<br>    &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-在该Service类中注入自己"><a href="#3-2-在该Service类中注入自己" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Servcie</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br>   @<span class="hljs-title class_">Autowired</span><br>   prvate <span class="hljs-title class_">ServiceA</span> serviceA;<br><br>   public <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">User user</span>) &#123;<br>         <span class="hljs-title function_">queryData1</span>();<br>         <span class="hljs-title function_">queryData2</span>();<br>         serviceA.<span class="hljs-title function_">doSave</span>(user);<br>   &#125;<br><br>   @<span class="hljs-title class_">Transactional</span>(rollbackFor=<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<br>   public <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSave</span>(<span class="hljs-params">User user</span>) &#123;<br>       <span class="hljs-title function_">addData1</span>();<br>       <span class="hljs-title function_">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。</p><h4 id="3-3-通过AopContent类"><a href="#3-3-通过AopContent类" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Servcie</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceA</span> &#123;<br><br>   public <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">User user</span>) &#123;<br>         <span class="hljs-title function_">queryData1</span>();<br>         <span class="hljs-title function_">queryData2</span>();<br>         ((<span class="hljs-title class_">ServiceA</span>)<span class="hljs-title class_">AopContext</span>.<span class="hljs-title function_">currentProxy</span>()).<span class="hljs-title function_">doSave</span>(user);<br>   &#125;<br><br>   @<span class="hljs-title class_">Transactional</span>(rollbackFor=<span class="hljs-title class_">Exception</span>.<span class="hljs-property">class</span>)<br>   public <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSave</span>(<span class="hljs-params">User user</span>) &#123;<br>       <span class="hljs-title function_">addData1</span>();<br>       <span class="hljs-title function_">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>注意这种方式，需要<strong>Set the exposeProxy Property</strong>,否则会抛出IllegalStateException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> PermissionUserServiceImpl <span class="hljs-title function_">permissionUserService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ProxyFactoryBean</span> <span class="hljs-variable">factoryBean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactoryBean</span>();<br>    factoryBean.setTarget(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PermissionUserServiceImpl</span>());<br>    factoryBean.setExposeProxy(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">return</span> (PermissionUserServiceImpl) factoryBean.getObject();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。</p><h3 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Slf4</span>j<br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">UserMapper</span> userMapper;<br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">RoleService</span> roleService;<br><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            roleService.<span class="hljs-title function_">doOtherThing</span>();<br>        &#125;).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br><br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的<a href="https://cloud.tencent.com/solution/database?from=20065&from_column=20065">数据库</a>连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，<strong>可能会知道spring的事务是通过数据库连接来实现的</strong>。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">private <span class="hljs-keyword">static</span> final <span class="hljs-title class_">ThreadLocal</span>&lt;<span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span>&gt;&gt; resources =<br><br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadLocal</span>&lt;&gt;(<span class="hljs-string">&quot;Transactional resources&quot;</span>);<br></code></pre></td></tr></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><p>可以使用@Async和@Transactional来保证事务注解生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    <span class="hljs-meta">@Async</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Saving role table data&quot;</span>);<br>        <span class="hljs-comment">// Let&#x27;s say an exception is thrown here</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-表不支持事务"><a href="#6-表不支持事务" class="headerlink" title="6.表不支持事务"></a>6.表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是<code>myisam</code>。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把<code>ENGINE</code>参数设置成<code>MyISAM</code>即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-string">`category`</span> (<br>  <span class="hljs-string">`id`</span> bigint <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span> <span class="hljs-variable constant_">AUTO_INCREMENT</span>,<br>  <span class="hljs-string">`one_category`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-variable constant_">COLLATE</span> utf8mb4_bin <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span>,<br>  <span class="hljs-string">`two_category`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-variable constant_">COLLATE</span> utf8mb4_bin <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span>,<br>  <span class="hljs-string">`three_category`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-variable constant_">COLLATE</span> utf8mb4_bin <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span>,<br>  <span class="hljs-string">`four_category`</span> <span class="hljs-title function_">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-variable constant_">COLLATE</span> utf8mb4_bin <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">NULL</span>,<br>  <span class="hljs-variable constant_">PRIMARY</span> <span class="hljs-variable constant_">KEY</span> (<span class="hljs-string">`id`</span>)<br>) <span class="hljs-variable constant_">ENGINE</span>=<span class="hljs-title class_">MyISAM</span> <span class="hljs-variable constant_">AUTO_INCREMENT</span>=<span class="hljs-number">4</span> <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">CHARSET</span>=utf8mb4 <span class="hljs-variable constant_">COLLATE</span>=utf8mb4_bin<br></code></pre></td></tr></table></figure><p>myisam好用，但有个很致命的问题是：<code>不支持事务</code>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><blockquote><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p></blockquote><h3 id="7-未开启事务"><a href="#7-未开启事务" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过<code>DataSourceTransactionManagerAutoConfiguration</code>类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置<code>spring.datasource</code>相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">   <br>&lt;!-- 配置事务管理器 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span> <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span> </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span></span> <br>&lt;!-- 用切点把事务切进去 --&gt; <br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.susan.*.*(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span></span> <br></code></pre></td></tr></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二-事务不回滚"><a href="#二-事务不回滚" class="headerlink" title="二 事务不回滚"></a>二 事务不回滚</h2><h3 id="1-错误的传播特性"><a href="#1-错误的传播特性" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用<code>@Transactional</code>注解时，是可以指定<code>propagation</code>参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><ul><li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li><li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li><li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li><li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li><li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li><li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li><li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li></ul><p>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    @<span class="hljs-title class_">Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">NEVER</span>)<br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        <span class="hljs-title function_">saveData</span>(userModel);<br>        <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常"><a href="#2-自己吞了异常" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。</p><p>这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常"><a href="#3-手动抛了别的异常" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Slf4</span>j<br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-title function_">saveData</span>(userModel);<br>             <span class="hljs-title function_">updateData</span>(userModel);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            log.<span class="hljs-title function_">error</span>(e.<span class="hljs-title function_">getMessage</span>(), e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。</p><p>因为spring事务，默认情况下只会回滚<code>RuntimeException</code>（运行时异常）和<code>Error</code>（错误），对于普通的Exception（非运行时异常），它不会回滚。</p><h3 id="4-自定义了回滚异常"><a href="#4-自定义了回滚异常" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置<code>rollbackFor</code>参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Slf4</span>j<br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    @<span class="hljs-title class_">Transactional</span>(rollbackFor = <span class="hljs-title class_">BusinessException</span>.<span class="hljs-property">class</span>)<br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>       <span class="hljs-title function_">saveData</span>(userModel);<br>       <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了"><a href="#5-嵌套事务回滚多了" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">RoleService</span> roleService;<br><br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        roleService.<span class="hljs-title function_">doOtherThing</span>();<br>    &#125;<br>&#125;<br><br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    @<span class="hljs-title class_">Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">NESTED</span>)<br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Slf4</span>j<br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>    @<span class="hljs-title class_">Autowired</span><br>    private <span class="hljs-title class_">RoleService</span> roleService;<br><br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br><br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-keyword">try</span> &#123;<br>            roleService.<span class="hljs-title function_">doOtherThing</span>();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            log.<span class="hljs-title function_">error</span>(e.<span class="hljs-title function_">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将内部嵌套事务放在try&#x2F;catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三-其他"><a href="#三-其他" class="headerlink" title="三 其他"></a>三 其他</h2><h3 id="1-大事务问题"><a href="#1-大事务问题" class="headerlink" title="1 大事务问题"></a>1 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。</p><p>通常情况下，我们会在方法上<code>@Transactional</code>注解，填加事务功能，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <br>    @<span class="hljs-title class_">Autowired</span> <br>    private <span class="hljs-title class_">RoleService</span> roleService;<br>    <br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>       <span class="hljs-title function_">query1</span>();<br>       <span class="hljs-title function_">query2</span>();<br>       <span class="hljs-title function_">query3</span>();<br>       roleService.<span class="hljs-title function_">save</span>(userModel);<br>       <span class="hljs-title function_">update</span>(userModel);<br>    &#125;<br>&#125;<br><br><br>@<span class="hljs-title class_">Service</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br>    <br>    @<span class="hljs-title class_">Autowired</span> <br>    private <span class="hljs-title class_">RoleService</span> roleService;<br>    <br>    @<span class="hljs-title class_">Transactional</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-title class_">UserModel</span> userModel) throws <span class="hljs-title class_">Exception</span> &#123;<br>       <span class="hljs-title function_">query4</span>();<br>       <span class="hljs-title function_">query5</span>();<br>       <span class="hljs-title function_">query6</span>();<br>       <span class="hljs-title function_">saveData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但<code>@Transactional</code>注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">roleService.<span class="hljs-title function_">save</span>(userModel);<br><span class="hljs-title function_">update</span>(userModel);<br></code></pre></td></tr></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">saveData</span>(userModel);<br></code></pre></td></tr></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1689141796-8023d8ec3f8c8097112709e5b391cb3d.jpeg"></p><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2.编程式事务"></a>2.编程式事务</h3><p>上面聊的这些内容都是基于<code>@Transactional</code>注解的，主要说的是它的事务问题，我们把这种事务叫做：<code>声明式事务</code>。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：<code>编程式事务</code>。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">@<span class="hljs-title class_">Autowired</span><br>private <span class="hljs-title class_">TransactionTemplate</span> transactionTemplate;<br><br>...<br><br>public <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">final User user</span>) &#123;<br>      <span class="hljs-title function_">queryData1</span>();<br>      <span class="hljs-title function_">queryData2</span>();<br>      transactionTemplate.<span class="hljs-title function_">execute</span>(<span class="hljs-function">(<span class="hljs-params">status</span>) =&gt;</span> &#123;<br>         <span class="hljs-title function_">addData1</span>();<br>         <span class="hljs-title function_">updateData2</span>();<br>         <span class="hljs-keyword">return</span> <span class="hljs-title class_">Boolean</span>.<span class="hljs-property">TRUE</span>;<br>      &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于<code>@Transactional</code>注解声明式事务，我更建议大家使用，基于<code>TransactionTemplate</code>的编程式事务。主要原因如下：</p><ol><li>避免由于spring aop问题，导致事务失效的问题。</li><li>能够更小粒度的控制事务的范围，更直观。</li></ol><blockquote><p>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab 高可用</title>
    <link href="/2023/07/10/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/gitlab-%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    <url>/2023/07/10/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%B7%A5%E4%BD%9C%E9%A2%86%E5%9F%9F%E6%B1%87%E6%80%BB/gitlab-%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h1><h1 id="OKR回顾"><a href="#OKR回顾" class="headerlink" title="OKR回顾"></a><strong>OKR回顾</strong></h1><p>整体聚焦三部分:</p><table><thead><tr><th><strong>OKR</strong></th><th><strong>成果</strong></th></tr></thead><tbody><tr><td><strong>Gitlab高可用与稳定性保障：</strong>维持<strong>可用性99.95%以上</strong>，<strong>不出现T1+&#x2F;P2+故障</strong>，不出现影响时间在15分钟以上的单业务访问可用性故障</td><td><strong>未出现评级故障</strong>。几次小问题（物理机故障、kgw影响），自身<strong>监控及时发现</strong>，并<strong>分钟级快速自愈恢复</strong>，<strong>影响时间和范围较小</strong>。</td></tr><tr><td><strong>Gitlab自身能力建设与性能提升，</strong>版本升级，提升推拉代码等性能</td><td>Git关键操作**整体性能提升约30%<strong>版本升级</strong>时间和人力成本降低60%**对用户和平台研发交付效率的影响降低</td></tr><tr><td><strong>KDev&amp;Keep等研发效能工具和业务线研发需求能力支持，提升研发交付效率。</strong></td><td>KDev&amp;Keep等研发工具<strong>交付流程优化</strong>和<strong>效率提升</strong>支持<strong>游戏业务</strong>价值千万级高保密代码资产保护</td></tr></tbody></table><h1 id="工作总结"><a href="#工作总结" class="headerlink" title="工作总结"></a><strong>工作总结</strong></h1><h2 id="1-Gitlab能力建设与提升"><a href="#1-Gitlab能力建设与提升" class="headerlink" title="1.Gitlab能力建设与提升"></a><strong>1.Gitlab能力建设与提升</strong></h2><h3 id="1-1-行业怎么做（望远镜）"><a href="#1-1-行业怎么做（望远镜）" class="headerlink" title="1.1 行业怎么做（望远镜）"></a><strong>1.1 行业怎么做（望远镜）</strong></h3><table><thead><tr><th><strong>阿里、腾讯、字节、百度、京东</strong></th><th><strong>滴滴</strong></th><th><strong>Gitlab社区</strong></th><th><strong>快手</strong></th></tr></thead><tbody><tr><td><strong>全自研代码托管平台</strong>（多为小团队维护、大的更新频率较低）</td><td><strong>基于早期Gitlab改造，完全脱离社区</strong>（2~3人小团队维护、主要支持上层研发工具，无大的更新）</td><td><strong>开源、版本不断更新迭代</strong>（60多个国家、3000+贡献者维护每月一个小版本，每年一个大版本）</td><td><strong>两面开花</strong>跟随社区版本升级（2~3次&#x2F;年），同时因地制宜的自研支持</td></tr></tbody></table><h3 id="1-2-做什么-显微镜"><a href="#1-2-做什么-显微镜" class="headerlink" title="1.2 做什么( 显微镜)"></a><strong>1.2 做什么( 显微镜)</strong></h3><p>诉求或痛点？</p><table><thead><tr><th><strong>普通研发视角</strong></th><th><strong>研发工具平台视角</strong></th><th><strong>安全视角</strong></th><th><strong>我的视角</strong></th></tr></thead><tbody><tr><td>代码库上传下载速度快、性能好，尤其是移动端主站等大仓库代码评审方便、高效、加载快、协作流畅</td><td>接口响应速度快、性能高大diff、大mr、大接口优化</td><td>无安全漏洞，代码安全</td><td>运维及oncall成本低系统稳定无bug，全年365*24*60不宕机</td></tr></tbody></table><ul><li><h4 id="Gitlab版本升级（13-12-14-0-14-4-14-10）"><a href="#Gitlab版本升级（13-12-14-0-14-4-14-10）" class="headerlink" title="Gitlab版本升级（13.12-&gt;14.0-&gt;14.4-&gt;14.10）"></a><strong>Gitlab版本升级（13.12-&gt;14.0-&gt;14.4-&gt;14.10）</strong></h4></li></ul><p><strong>【背景或动机】：</strong></p><ol><li>存在<strong>重大安全漏洞</strong>，基础服务代码资产安全重要性，<strong>公司安全部要求升级</strong></li><li><strong>相信开源的力量，充分利用社区开源成果</strong></li></ol><p><strong>【价值收益】：提升代码拉取和上传性能、接口性能，降低pg数据库和gitaly压力；安全漏洞修复</strong></p><ul><li><strong>代码处理性能提升</strong></li></ul><ol><li>提升大库代码<strong>拉取性能</strong>（clone&#x2F;pull&#x2F;fetch），支持git v2协议，可<strong>减少拉取耗时67% （</strong>主站移动端仓库<strong>）</strong></li><li>大幅提升大库的<strong>push代码性能，</strong>其中批量push check<strong>阶段耗时可降低90+%</strong></li><li>提升底层**处理git对象性能30%**左右，降低gitaly内存压力</li><li>提升底层**处理hook事件性能10%**以上，降低gitlay CPU压力</li></ol><ul><li><strong>接口性能提升（尤其是大数据量的接口）</strong></li></ul><ol><li>mr列表接口性能提升（大仓库3000个mr），<strong>接口耗时减少50%（1.5s降为700+ms）</strong></li><li>compare diff接口性能提升（大diff比较），**接口耗时减少50%**（5.5s降为2.7s）</li><li>项目列表、tag列表等大数据量获取接口性能提升</li></ol><ul><li><strong>其他</strong></li></ul><ol><li>pg表存储优化，<strong>减少大表的存储空间</strong></li><li>支持<strong>repo仓库增量备份</strong>，大幅减少备份耗时</li><li>导入外部代码仓库的方式注入重大安全漏洞等修复</li></ol><ul><li><h4 id="Gitlab版本升级主要工作"><a href="#Gitlab版本升级主要工作" class="headerlink" title="Gitlab版本升级主要工作"></a><strong>Gitlab版本升级主要工作</strong></h4></li></ul><p><strong>【难点与挑战】</strong></p><ol><li><strong>Gitlab社区</strong>连续小版本升级支持不停机（前提条件限制），<strong>跨版本升级必须要停机</strong></li><li><strong>缺少行业参考和最佳实践指引</strong>，社区的<strong>帮助文档参考</strong>，<strong>不一定全面和适用</strong></li><li><strong>我们的架构（高可用、多AZ部署）和自研代码改动</strong>与社区官方都<strong>有很大的差异，</strong>两面开花如何高效低成本的合并与适配兼容？</li><li>每次版本升级都是一个庞大的工程，要投入大量的时间和精力去调研评估、环境准备、实践验证、回归测试、架构适配、自研改动兼容等等。</li></ol><p>gitlab版本升级并非简单的按照文档可一键升级，<strong>很多问题是没有相关文档或文档也发现不了的</strong>，需要因地制宜、大量实践验证（<strong>比如最近升级14.10两个pg数据库混部署导致升级失败问题</strong>）</p><p>做了哪些工作？</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201159069.png" alt="img"></p><p><strong>【价值和收益】</strong>：</p><ol><li><p>用于支撑gitlab版本升级，<strong>获得上述版本升级的收益价值</strong></p></li><li><p>同时自身工作提效，<strong>降低gitlab版本升级成本（时间和人力）50%</strong></p></li><li><p><strong>gitlab升级停机时间减少60%（150min降为60min），降低对用户和平台研发交付效率</strong>的影响。</p></li><li><ol><li><strong>Gitlab自身数据</strong> ：<strong>500+&#x2F;min</strong>拉取代码次数、<strong>1~2&#x2F;min</strong>推送代码次数、API请求<strong>4000+&#x2F;min</strong>、<strong>QPM 6000+</strong> </li><li><strong>CI-Pipeline影响</strong>：公司pipeline流水线执行次数110+&#x2F;min，每次升级即<strong>可避免1w多次流水线拉取代码失败</strong></li></ol></li></ol><p>注：以上数据为<strong>非工作日低峰期均值</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201159234.png" alt="img"></p><table><thead><tr><th><strong>时间</strong></th><th><strong>目标版本</strong></th><th><strong>停服不可用时长（分钟）</strong></th><th><strong>操作时长（分钟）</strong></th><th><strong>操作人力(人)</strong></th><th><strong>说明</strong></th><th><strong>图示</strong></th></tr></thead><tbody><tr><td>2020.12</td><td>13.6</td><td>30</td><td>30</td><td>2</td><td><strong>逐步升高的原因：</strong>高可用架构复杂度，部署节点越来越多（36台服务器），笨办法、基本靠手动操作自研变更feature越来越多，代码复杂度提升使用数据量增加，升级DB迁移耗时长</td><td><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201159445.png" alt="img"></td></tr><tr><td>2021.5</td><td>13.10</td><td>60</td><td>60</td><td>2</td><td></td><td></td></tr><tr><td>2021.8</td><td>13.12</td><td>90</td><td>90</td><td>2</td><td></td><td></td></tr><tr><td>2022.4</td><td>14.0.12</td><td>150</td><td>210</td><td>2</td><td></td><td></td></tr><tr><td>2022.7</td><td>14.4.5</td><td>120</td><td>180</td><td>1</td><td><strong>开始下降的原因：1、准备工作、操作和验证实现自动化、流程化、并行化、可复用<br />2、灰度部署、降级预留升级部署方案</strong></td><td></td></tr><tr><td>2022.11</td><td>14.10.5</td><td>60</td><td>120</td><td>1</td><td>多AZ多机房部署，架构进一步复杂</td><td></td></tr></tbody></table><h2 id="2-Gitlab高可用与稳定性建设"><a href="#2-Gitlab高可用与稳定性建设" class="headerlink" title="2.Gitlab高可用与稳定性建设"></a><strong>2.Gitlab高可用与稳定性建设</strong></h2><p><strong>诉求或痛点？</strong></p><ul><li><p>多AZ建设，阻塞点：Gitlab对象存储不满足，不支持AZ逃生</p></li><li><p>依赖治理，降低三方依赖对gitlab稳定性影响</p></li><li><p>上线变更缺少规范化、流程化、标准化管控</p></li><li><p>缺少gitlab问题或故障标准快速处理流程，应急处理指导</p></li><li><p>Gitlab多环境建设不规范，不完整，缺少线上模拟环境和数据</p></li><li><h3 id="多AZ建设，依赖治理、降低三方依赖对gitlab稳定性影响"><a href="#多AZ建设，依赖治理、降低三方依赖对gitlab稳定性影响" class="headerlink" title="多AZ建设，依赖治理、降低三方依赖对gitlab稳定性影响"></a><strong>多AZ建设，依赖治理、降低三方依赖对gitlab稳定性影响</strong></h3></li></ul><ol><li>对象存储迁移改造，由ceph s3迁移至blobstore。实现完成<strong>四种对象3.7TB数据</strong>的<strong>零停机</strong>、<strong>用户无感</strong>的迁移改造。<strong>对象存储依赖具备AZ逃生能力</strong>，降低依赖故障对gitlab影响</li><li>LB负载均衡依赖改造，gitlab内部组件改造为使用域名替换IP直连LB方式，降低单点故障影响，提升故障自愈能力。（曾出现过LB变更影响导致gitlab故障）</li></ol><p><strong>【高可用成果举例】：</strong></p><ul><li><p>gitlab服务其中1台物理机故障（3次），机器宕机。gitlab服务10s自动检测故障节点并摘除。机器重启后服务自动恢复。故障造成影响单节点时长1min左右（冷启动时长）</p></li><li><h3 id="上线变更管控，故障处理SOP等流程化、标准化实现。降低变更风险，提升故障应急处理能力。"><a href="#上线变更管控，故障处理SOP等流程化、标准化实现。降低变更风险，提升故障应急处理能力。" class="headerlink" title="上线变更管控，故障处理SOP等流程化、标准化实现。降低变更风险，提升故障应急处理能力。"></a><strong>上线变更管控，故障处理SOP等流程化、标准化实现。降低变更风险，提升故障应急处理能力。</strong></h3></li></ul><p><strong>【价值与收益】：</strong>gitlab<strong>上线变更引起的故障数为0</strong></p><hr><h1 id="KDev命令行（15-）"><a href="#KDev命令行（15-）" class="headerlink" title="KDev命令行（15%）"></a><strong>KDev命令行（15%）</strong></h1><h2 id="OKR"><a href="#OKR" class="headerlink" title="OKR"></a><strong>OKR</strong></h2><p>（2022Q2）完善kdev命令行工具，支持较完整的从拉分支、commit、push到MR、提测等和kdev服务端交互功能，命令行工具支持完善灰度能力</p><h2 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a><strong>完成情况</strong></h2><ol><li><p>功能需求方面，新增7个子命令，包括拉分支、mr等相关操作，交付了电商、移动端等使用方的多个需求。<a href="https://docs.corp.kuaishou.com/d/home/fcADfTPfpKQFuP_KOarBFye8q">Kdev命令行使用文档</a></p></li><li><p>技术优化方面：</p></li><li><ol><li>支持了二进制灰度发布能力，提高交付质量。</li><li>改进了二进制升级方式，支持平滑升级，不再需要单独的升级步骤，提升用户体验。</li><li>支持了命令行本地埋点日志及上报能力，用于了解命令行使用情况，问题诊断等方面。</li><li>探索命令行自动补全（AutoComplete），支持了静态补全，动态补全方面还存在技术难点。</li></ol></li></ol><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201255212.png" alt="img"></p><h1 id="Gitlab（80-）"><a href="#Gitlab（80-）" class="headerlink" title="Gitlab（80%）"></a><strong>Gitlab（80%）</strong></h1><h2 id="OKR-1"><a href="#OKR-1" class="headerlink" title="OKR"></a><strong>OKR</strong></h2><p>（2022Q2）问题定位与止损效率提升，目标单次问题15分钟内止损或恢复</p><p>（2022Q3）建立完备的Gitlab周期冷备机制，后续压缩恢复时间到1小时以内</p><p>（2022Q3）Gitlab双AZ建设，具备AZ逃生能力</p><p>（2022Q4）检测自身可用性，并通过停止或者摘除入口，或者切换DNS等方式自动恢复</p><p>（2022Q4）【愿景型】重构代码搜索功能，提升性能和体验</p><h2 id="完成情况-1"><a href="#完成情况-1" class="headerlink" title="完成情况"></a><strong>完成情况</strong></h2><ol><li><p>问题定位方面：<a href="https://grafana.corp.kuaishou.com/d/vMlg_xUMk/gitlabjian-kong-da-pan?orgId=3">Gitlab监控大盘</a></p></li><li><p>首先尽量打通Gitlab内部各组件之间的correlation_id、username、client ip的传递。其次收集Gitlab日志到Clickhouse中，通过Clickhouse实现基于用户，仓库等粒度的监控及专项分析面板。对于常见类问题的定位（某个用户、仓库的突发大量调用、慢请求url提取）做到一眼看到，同时做了环比、同比分析，对于缓慢上升流量有预防监控的作用。<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201257340.png" alt="img"><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201256870.png" alt="img"></p><ul><li><p>补充e2e监控，从Gitlab集群外部进行拨测，对核心可用性进行监控，目前支持git clone、ssh连通性测试用例，后续待继续补充。</p></li><li><p>对错误日志分析，通过日志规则匹配，对于已经明确原因的错误日志，进行原因打标。目标对所有错误日志进行自动化判别，对于不能识别的错误日志发出报警。（能力建设基本完成，规则完善中）<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201255887.png" alt="img"></p></li></ul></li><li><p>可用性提升方面：</p></li><li><p>已建立Gitlab冷备&amp;恢复机制，仓库数据支持仓库级别增量备份，整体恢复时间压缩到1小时以内。</p><p>完成双AZ建设，支持整体，单组件AZ逃生能力，后续需要随着AZ2.0的推进，进一步规范物理机部署方式，避免逃生演练中故障域不清晰导致的无法逃生问题。<a href="https://docs.corp.kuaishou.com/k/home/VMIVhPdD2nXg/fcACFqmSzxOt8ldxdMf3o0AVI">Gitlab跨AZ部署</a><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230105201255419.png" alt="img"></p><p>引入haproxy实现长连接限流与排队，达到削峰填谷的目的。</p></li><li><p>能力建设：</p><ol><li>实现Gitlab SMTP邮件代理服务，解决Gitlab邮件过多被限流，及sidekiq任务堆积问题。通过存储异步转发，分流发送等方式来解决，同时提供邮件通知转kim通知的能力，确保高优消息即使触达。<a href="https://docs.corp.kuaishou.com/k/home/VIvYATzF6OoY/fcAADASM9OQmjAIrlmWrDq9Tt">gitlab smtp代理服务文档</a></li><li>代码搜索：<a href="https://docs.corp.kuaishou.com/k/home/VXvb_Vt1mavU/fcADdbJpRNtvpOhpOwJ-TODUA">Code Search</a><ol><li>基于zoekt建立新的代码搜索服务，提供全量仓库代码快速搜索，时间上由当前版本的代码搜索的分钟级降到秒级，同时可以支持仓库粒度索引的即时更新，不再需要定期进行长达几个小时的重启以更新索引。（未上线）</li><li>探索Gitlab Advanced Search（收费功能）自研改造，基于ES实现代码、issue、mr、评论等信息的实时秒级搜索（进行中）。</li></ol></li></ol></li></ol><h1 id="SVN（5-）"><a href="#SVN（5-）" class="headerlink" title="SVN（5%）"></a><strong>SVN（5%）</strong></h1><h2 id="OKR-2"><a href="#OKR-2" class="headerlink" title="OKR"></a><strong>OKR</strong></h2><p>（2022Q3）建立完备的SVN周期冷备机制</p><p>（2022Q4）完成SVN双AZ建设，具备AZ逃生能力</p><h2 id="完成情况-2"><a href="#完成情况-2" class="headerlink" title="完成情况"></a><strong>完成情况</strong></h2><ol><li>已建立SVN冷备&amp;恢复机制，整体恢复时间压缩到30分钟以内。</li><li>完成SVN双AZ建设，由于SVN无服务自身限制，无法自动逃生需要手动操作，逃生时间在10分钟以内。</li></ol><h1 id="总结思考"><a href="#总结思考" class="headerlink" title="总结思考"></a><strong>总结思考</strong></h1><p>个别OKR完成情况不好。比如Gitlab的“单次问题15分钟内止损或恢复”：</p><p>1、对目标思考的不够深入。想到的解决方案比较片面，初期认为监控做全就可以缩短故障定位止损时间，于是不停地在加监控，grafana上的图表接近上百，结果真的出现问题的时候看不过来，需要某个指标的时候也找不到，并且还是会发现有些监控缺失，然后继续加监控，整体收效甚微。</p><p>2、缺乏对目标拆解，没有设立阶段性目标。这个目标不是一蹴而就的，需要一步步实现甚至长期演进。应该合理的划分阶段，定立里程碑，先达到什么效果，再做到什么程度，优先解决优先级较高的问题子域。</p><p>3、没有考虑指标量化。既然目标中本身就有量化数据，在开始之前就应该搞清楚当前处理时间是多久，每完成一阶段的工作，提升了多少，都应该有体现。无法实现量化的结果就是，可能做了很多工作，却连自己都不知道到底有没有起到正向作用，最后也不知道到底是否达成目标。</p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工作领域</tag>
      
      <tag>gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring如何解决循环依赖</title>
    <link href="/2023/07/10/Spring/spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <url>/2023/07/10/Spring/spring%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的核心思想主要分下面几点</p><ol><li>什么是循环依赖？</li><li>什么情况下循环依赖可以被处理？</li><li>Spring是如何解决的循环依赖？</li></ol><p>同时本文希望纠正几个目前业界内经常出现的几个关于循环依赖的错误的说法</p><ol><li>只有在setter方式注入的情况下，循环依赖才能解决（<strong>错</strong>）</li><li>三级缓存的目的是为了提高效率（<strong>错</strong>）</li></ol><h2 id="什么是循环依赖？"><a href="#什么是循环依赖？" class="headerlink" title="什么是循环依赖？"></a>什么是循环依赖？</h2><p>从字面上来理解就是A依赖B的同时B也依赖了A，就像下面这样</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-09e35b75575e765fd410837395fe7701.png" alt="image-20200705175322521"></p><p>体现到代码层次就是这个样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// A中注入了B</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// B中也注入了A</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这是最常见的一种循环依赖，比较特殊的还有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自己依赖自己</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// A中注入了A</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然体现形式不一样，但是实际上都是循环依赖</p><h2 id="什么情况下循环依赖可以被处理？"><a href="#什么情况下循环依赖可以被处理？" class="headerlink" title="什么情况下循环依赖可以被处理？"></a>什么情况下循环依赖可以被处理？</h2><p>在回答这个问题之前首先要明确一点，Spring解决循环依赖是有前置条件的</p><ol><li>出现循环依赖的Bean必须要是单例</li><li>依赖注入的方式不能全是构造器注入的方式（很多博客上说，只能解决setter方法的循环依赖，这是错误的）</li></ol><p>其中第一点应该很好理解，第二点：不能全是构造器注入是什么意思呢？我们还是用代码说话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-comment">//    @Autowired</span><br><span class="hljs-comment">//    private B b;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(B b)</span> &#123;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br><span class="hljs-comment">//    @Autowired</span><br><span class="hljs-comment">//    private A a;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(A a)</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，A中注入B的方式是通过构造器，B中注入A的方式也是通过构造器，这个时候循环依赖是无法被解决，如果你的项目中有两个这样相互依赖的Bean，在启动时就会报出以下错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="hljs-string">&#x27;a&#x27;</span>: Requested bean is currently in creation: Is there an unresolvable circular reference?<br></code></pre></td></tr></table></figure><p>为了测试循环依赖的解决情况跟注入方式的关系，我们做如下四种情况的测试</p><table><thead><tr><th>依赖情况</th><th>依赖注入方式</th><th>循环依赖是否被解决</th></tr></thead><tbody><tr><td>AB相互依赖（循环依赖）</td><td>均采用setter方法注入</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>均采用构造器注入</td><td>否</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td>否</td></tr></tbody></table><p>具体的测试代码跟简单，我就不放了。从上面的测试结果我们可以看到，不是只有在setter方法注入的情况下循环依赖才能被解决，即使存在构造器注入的场景下，循环依赖依然被可以被正常处理掉。</p><p>那么到底是为什么呢？Spring到底是怎么处理的循环依赖呢？不要急，我们接着往下看</p><h2 id="Spring是如何解决的循环依赖？"><a href="#Spring是如何解决的循环依赖？" class="headerlink" title="Spring是如何解决的循环依赖？"></a>Spring是如何解决的循环依赖？</h2><p>关于循环依赖的解决方式应该要分两种情况来讨论</p><ol><li>简单的循环依赖（没有AOP）</li><li>结合了AOP的循环依赖</li></ol><h3 id="简单的循环依赖（没有AOP）"><a href="#简单的循环依赖（没有AOP）" class="headerlink" title="简单的循环依赖（没有AOP）"></a>简单的循环依赖（没有AOP）</h3><p>我们先来分析一个最简单的例子，就是上面提到的那个demo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">// A中注入了B</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-comment">// B中也注入了A</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上文我们已经知道了这种情况下的循环依赖是能够被解决的，那么具体的流程是什么呢？我们一步步分析</p><p>首先，我们要知道<strong>Spring在创建Bean的时候默认是按照自然排序来进行创建的，所以第一步Spring会去创建A</strong>。</p><p>与此同时，我们应该知道，Spring在创建Bean的过程中分为三步</p><ol><li>实例化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>中的<code>createBeanInstance</code>方法</li><li>属性注入，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>populateBean</code>方法</li><li>初始化，对应方法：<code>AbstractAutowireCapableBeanFactory</code>的<code>initializeBean</code></li></ol><p>这些方法在之前源码分析的文章中都做过详细的解读了，如果你之前没看过我的文章，那么你只需要知道</p><ol><li>实例化，简单理解就是new了一个对象</li><li>属性注入，为实例化中new出来的对象填充属性</li><li>初始化，执行aware接口中的方法，初始化方法，完成<code>AOP</code>代理</li></ol><p>基于上面的知识，我们开始解读整个循环依赖处理的过程，整个流程应该是以A的创建为起点，前文也说了，第一步就是创建A嘛！</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-7d23f6fa572b212c3d3599c3b1607347.png" alt="image-20200706092738559"></p><p>创建A的过程实际上就是调用<code>getBean</code>方法，这个方法有两层含义</p><ol><li>创建一个新的Bean</li><li>从缓存中获取到已经被创建的对象</li></ol><p>我们现在分析的是第一层含义，因为这个时候缓存中还没有A嘛！</p><h4 id="调用getSingleton-beanName"><a href="#调用getSingleton-beanName" class="headerlink" title="调用getSingleton(beanName)"></a>调用getSingleton(beanName)</h4><p>首先调用<code>getSingleton(a)</code>方法，这个方法又会调用<code>getSingleton(beanName, true)</code>，在上图中我省略了这一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> getSingleton(beanName, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getSingleton(beanName, true)</code>这个方法实际上就是到缓存中尝试去获取Bean，整个缓存分为三级</p><ol><li><code>singletonObjects</code>，一级缓存，存储的是所有创建好了的单例Bean</li><li><code>earlySingletonObjects</code>，完成实例化，但是还未进行属性注入及初始化的对象</li><li><code>singletonFactories</code>，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象</li></ol><p>因为A是第一次被创建，所以不管哪个缓存中必然都是没有的，因此会进入<code>getSingleton</code>的另外一个重载方法<code>getSingleton(beanName, singletonFactory)</code>。</p><h4 id="调用getSingleton-beanName-singletonFactory"><a href="#调用getSingleton-beanName-singletonFactory" class="headerlink" title="调用getSingleton(beanName, singletonFactory)"></a>调用getSingleton(beanName, singletonFactory)</h4><p>这个方法就是用来创建Bean的，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingleton</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(beanName, <span class="hljs-string">&quot;Bean name must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>        <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-comment">// ....</span><br>            <span class="hljs-comment">// 省略异常处理及日志</span><br>            <span class="hljs-comment">// ....</span><br><br>            <span class="hljs-comment">// 在单例对象创建前先做一个标记</span><br>            <span class="hljs-comment">// 将beanName放入到singletonsCurrentlyInCreation这个集合中</span><br>            <span class="hljs-comment">// 标志着这个单例Bean正在创建</span><br>            <span class="hljs-comment">// 如果同一个单例Bean多次被创建，这里会抛出异常</span><br>            beforeSingletonCreation(beanName);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">newSingleton</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">recordSuppressedExceptions</span> <span class="hljs-operator">=</span> (<span class="hljs-built_in">this</span>.suppressedExceptions == <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 上游传入的lambda在这里会被执行，调用createBean方法创建一个Bean后返回</span><br>                singletonObject = singletonFactory.getObject();<br>                newSingleton = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-comment">// 省略catch异常处理</span><br>            <span class="hljs-comment">// ...</span><br>            <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (recordSuppressedExceptions) &#123;<br>                    <span class="hljs-built_in">this</span>.suppressedExceptions = <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-comment">// 创建完成后将对应的beanName从singletonsCurrentlyInCreation移除</span><br>                afterSingletonCreation(beanName);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (newSingleton) &#123;<br>                <span class="hljs-comment">// 添加到一级缓存singletonObjects中</span><br>                addSingleton(beanName, singletonObject);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singletonObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码我们主要抓住一点，通过<code>createBean</code>方法返回的Bean最终被放到了一级缓存，也就是单例池中。</p><p>那么到这里我们可以得出一个结论：<strong>一级缓存中存储的是已经完全创建好了的单例Bean</strong></p><h4 id="调用addSingletonFactory方法"><a href="#调用addSingletonFactory方法" class="headerlink" title="调用addSingletonFactory方法"></a>调用addSingletonFactory方法</h4><p>如下图所示：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-3e0616dab68c11656172511162365207.png" alt="image-20200706105535307"></p><p>在完成Bean的实例化后，属性注入之前，Spring将Bean包装成一个工厂添加进了三级缓存中，对应源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里传入的参数也是一个lambda表达式，() -&gt; getEarlyBeanReference(beanName, mbd, bean)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>    Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br>            <span class="hljs-comment">// 添加到三级缓存中</span><br>            <span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br>            <span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br>            <span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里只是添加了一个工厂，通过这个工厂（<code>ObjectFactory</code>）的<code>getObject</code>方法可以得到一个对象，而这个对象实际上就是通过<code>getEarlyBeanReference</code>这个方法创建的。那么，什么时候会去调用这个工厂的<code>getObject</code>方法呢？这个时候就要到创建B的流程了。</p><p>当A完成了实例化并添加进了三级缓存后，就要开始为A进行属性注入了，在注入时发现A依赖了B，那么这个时候Spring又会去<code>getBean(b)</code>，然后反射调用setter方法完成属性注入。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-28557208ba294a2b9655b260d3af507f.png" alt="image-20200706114501300"></p><p>因为B需要注入A，所以在创建B的时候，又会去调用<code>getBean(a)</code>，这个时候就又回到之前的流程了，但是不同的是，之前的<code>getBean</code>是为了创建Bean，而此时再调用<code>getBean</code>不是为了创建了，而是要从缓存中获取，因为之前A在实例化后已经将其放入了三级缓存<code>singletonFactories</code>中，所以此时<code>getBean(a)</code>的流程就是这样子了</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-708844db852f91673fa549e7449fdb21.png" alt="image-20200706115959250"></p><p>从这里我们可以看出，注入到B中的A是通过<code>getEarlyBeanReference</code>方法提前暴露出去的一个对象，还不是一个完整的Bean，那么<code>getEarlyBeanReference</code>到底干了啥了，我们看下它的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>                <span class="hljs-type">SmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>它实际上就是调用了后置处理器的<code>getEarlyBeanReference</code>，而真正实现了这个方法的后置处理器只有一个，就是通过<code>@EnableAspectJAutoProxy</code>注解导入的<code>AnnotationAwareAspectJAutoProxyCreator</code>。<strong>也就是说如果在不考虑<code>AOP</code>的情况下，上面的代码等价于：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>也就是说这个工厂啥都没干，直接将实例化阶段创建的对象返回了！所以说在不考虑<code>AOP</code>的情况下三级缓存有用嘛？讲道理，真的没什么用</strong>，我直接将这个对象放到二级缓存中不是一点问题都没有吗？如果你说它提高了效率，那你告诉我提高的效率在哪?</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-ab8c1b4c249b25f67c202675aed6765e.png" alt="image-20200706124118108"></p><p>那么三级缓存到底有什么作用呢？不要急，我们先把整个流程走完，在下文结合<code>AOP</code>分析循环依赖的时候你就能体会到三级缓存的作用！</p><p>到这里不知道小伙伴们会不会有疑问，B中提前注入了一个没有经过初始化的A类型对象不会有问题吗？</p><p>答：不会</p><p>这个时候我们需要将整个创建A这个Bean的流程走完，如下图：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-7213229f186504a6587ebda81528c449.png" alt="image-20200706133018669"></p><p>从上图中我们可以看到，虽然在创建B时会提前给B注入了一个还未初始化的A对象，但是在创建A的流程中一直使用的是注入到B中的A对象的引用，之后会根据这个引用对A进行初始化，所以这是没有问题的。</p><h3 id="结合了AOP的循环依赖"><a href="#结合了AOP的循环依赖" class="headerlink" title="结合了AOP的循环依赖"></a>结合了AOP的循环依赖</h3><p>之前我们已经说过了，在普通的循环依赖的情况下，三级缓存没有任何作用。三级缓存实际上跟Spring中的<code>AOP</code>相关，我们再来看一看<code>getEarlyBeanReference</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>                <span class="hljs-type">SmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在开启<code>AOP</code>的情况下，那么就是调用到<code>AnnotationAwareAspectJAutoProxyCreator</code>的<code>getEarlyBeanReference</code>方法，对应的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>    <span class="hljs-built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);<br>    <span class="hljs-comment">// 如果需要代理，返回一个代理对象，不需要代理，直接返回当前传入的这个bean对象</span><br>    <span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>回到上面的例子，我们对A进行了<code>AOP</code>代理的话，那么此时<code>getEarlyBeanReference</code>将返回一个代理后的对象，而不是实例化阶段创建的对象，这样就意味着B中注入的A将是一个代理对象而不是A的实例化阶段创建后的对象。<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-d707756bce86d4cecee10895ea4bd480.png" alt="image-20200706161709829"></p><p>看到这个图你可能会产生下面这些疑问</p><ol><li>在给B注入的时候为什么要注入一个代理对象？</li></ol><p>答：当我们对A进行了<code>AOP</code>代理时，说明我们希望从容器中获取到的就是A代理后的对象而不是A本身，因此把A当作依赖进行注入时也要注入它的代理对象</p><ol><li>明明初始化的时候是A对象，那么Spring是在哪里将代理对象放入到容器中的呢？</li></ol><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-7b1169d54dd22ab03bc4100de836bc44.png" alt="image-20200706160542584"></p><p>在完成初始化后，Spring又调用了一次<code>getSingleton</code>方法，这一次传入的参数又不一样了，false可以理解为禁用三级缓存，前面图中已经提到过了，在为B中注入A时已经将三级缓存中的工厂取出，并从工厂中获取到了一个对象放入到了二级缓存中，所以这里的这个<code>getSingleton</code>方法做的时间就是从二级缓存中获取到这个代理后的A对象。<code>exposedObject == bean</code>可以认为是必定成立的，除非你非要在初始化阶段的后置处理器中替换掉正常流程中的Bean，例如增加一个后置处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">if</span> (beanName.equals(<span class="hljs-string">&quot;a&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，请不要做这种骚操作，徒增烦恼！</p><ol><li>初始化的时候是对A对象本身进行初始化，而容器中以及注入到B中的都是代理对象，这样不会有问题吗？</li></ol><p>答：不会，这是因为不管是<code>cglib</code>代理还是<code>jdk</code>动态代理生成的代理类，内部都持有一个目标类的引用，当调用代理对象的方法时，实际会去调用目标对象的方法，A完成初始化相当于代理对象自身也完成了初始化</p><ol><li>三级缓存为什么要使用工厂而不是直接使用引用？换而言之，为什么需要这个三级缓存，直接通过二级缓存暴露一个引用不行吗？</li></ol><p>答：<strong>这个工厂的目的在于延迟对实例化阶段生成的对象的代理，只有真正发生循环依赖的时候，才去提前生成代理对象，否则只会创建一个工厂并将其放入到三级缓存中，但是不会去通过这个工厂去真正创建对象</strong></p><p>我们思考一种简单的情况，就以单独创建A为例，假设AB之间现在没有依赖关系，但是A被代理了，这个时候当A完成实例化后还是会进入下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A是单例的，mbd.isSingleton()条件满足</span><br><span class="hljs-comment">// allowCircularReferences：这个变量代表是否允许循环依赖，默认是开启的，条件也满足</span><br><span class="hljs-comment">// isSingletonCurrentlyInCreation：正在在创建A，也满足</span><br><span class="hljs-comment">// 所以earlySingletonExposure=true</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>                                  isSingletonCurrentlyInCreation(beanName));<br><span class="hljs-comment">// 还是会进入到这段代码中</span><br><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">// 还是会通过三级缓存提前暴露一个工厂对象</span><br>    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>&#125;<br></code></pre></td></tr></table></figure><p>看到了吧，即使没有循环依赖，也会将其添加到三级缓存中，而且是不得不添加到三级缓存中，因为到目前为止Spring也不能确定这个Bean有没有跟别的Bean出现循环依赖。</p><p>假设我们在这里直接使用二级缓存的话，那么意味着所有的Bean在这一步都要完成<code>AOP</code>代理。这样做有必要吗？</p><p>不仅没有必要，而且违背了Spring在结合<code>AOP</code>跟Bean的生命周期的设计！Spring结合<code>AOP</code>跟Bean的生命周期本身就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来完成的，在这个后置处理的<code>postProcessAfterInitialization</code>方法中对初始化后的Bean完成<code>AOP</code>代理。如果出现了循环依赖，那没有办法，只有给Bean先创建代理，但是没有出现循环依赖的情况下，设计之初就是让Bean在生命周期的最后一步完成代理而不是在实例化后就立马完成代理。</p><h3 id="三级缓存真的提高了效率了吗？"><a href="#三级缓存真的提高了效率了吗？" class="headerlink" title="三级缓存真的提高了效率了吗？"></a>三级缓存真的提高了效率了吗？</h3><p>现在我们已经知道了三级缓存的真正作用，但是这个答案可能还无法说服你，所以我们再最后总结分析一波，三级缓存真的提高了效率了吗？分为两点讨论：</p><ol><li>没有进行<code>AOP</code>的Bean间的循环依赖</li></ol><p>从上文分析可以看出，这种情况下三级缓存根本没用！所以不会存在什么提高了效率的说法</p><ol><li>进行了<code>AOP</code>的Bean间的循环依赖</li></ol><p>就以我们上的A、B为例，其中A被<code>AOP</code>代理，我们先分析下使用了三级缓存的情况下，A、B的创建流程</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-6475ec1d567ee6fda480efe1e5eee7f2.png" alt="image-20200706171514327"></p><p>假设不使用三级缓存，直接在二级缓存中</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1688988948-184f0915b159abc29f0005bd763e9833.png" alt="image-20200706172523258"></p><p>上面两个流程的唯一区别在于为A对象创建代理的时机不同，在使用了三级缓存的情况下为A创建代理的时机是在B中需要注入A的时候，而不使用三级缓存的话在A实例化后就需要马上为A创建代理然后放入到二级缓存中去。对于整个A、B的创建过程而言，消耗的时间是一样的</p><p>综上，不管是哪种情况，三级缓存提高了效率这种说法都是错误的！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试官：”Spring是如何解决的循环依赖？“</p><p>答：Spring通过三级缓存解决了循环依赖，其中一级缓存为单例池（<code>singletonObjects</code>）,二级缓存为早期曝光对象<code>earlySingletonObjects</code>，三级缓存为早期曝光对象工厂（<code>singletonFactories</code>）。当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，如果A没有被AOP代理，那么这个工厂获取到的就是A实例化的对象。当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！</p><p>面试官：”为什么要使用三级缓存呢？二级缓存能解决循环依赖吗？“</p><p>答：如果要使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样违背了Spring设计的原则，Spring在设计之初就是通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个后置处理器来在Bean生命周期的最后一步来完成AOP代理，而不是在实例化后就立马进行AOP代理。</p><h2 id="一道思考题"><a href="#一道思考题" class="headerlink" title="一道思考题"></a>一道思考题</h2><p>为什么在下表中的第三种情况的循环依赖能被解决，而第四种情况不能被解决呢？</p><p>提示：Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建</p><table><thead><tr><th>依赖情况</th><th>依赖注入方式</th><th>循环依赖是否被解决</th></tr></thead><tbody><tr><td>AB相互依赖（循环依赖）</td><td>均采用setter方法注入</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>均采用构造器注入</td><td>否</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>A中注入B的方式为setter方法，B中注入A的方式为构造器</td><td>是</td></tr><tr><td>AB相互依赖（循环依赖）</td><td>B中注入A的方式为setter方法，A中注入B的方式为构造器</td><td>否</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中状态机的多种实现</title>
    <link href="/2023/06/30/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java%E4%B8%AD%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/06/30/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/java%E4%B8%AD%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在java后端项目的开发过程中，经常会碰到需要进行状态转换的场景，比如订单的状态、任务的状态等等，通常会使用枚举对状态进行定义，并在需要时更改其枚举值。</p><p>但是在一些比较复杂的场景下，例如状态数大于等于5个，或者大状态拥有子状态的场景（如订单【交易中】的状态包含【待发货】【已发货】等子状态），再直接通过修改枚举值的方式已经难以进行维护，且会导致状态变更的代码在项目中散布，不仅在实现上不够优雅，而且在需要添加或者修改状态时牵一发而动全身。因此，我们需要有一种技术手段，来对状态进行统一管理，以及收束变更状态的代码入口。</p><p><strong>有限状态机（Finite State Machine, FSM）就是用来干这个事的！</strong></p><p>该文是一个系列文章，本章先介绍基本概念及其简单实现</p><h1 id="什么是有限状态机"><a href="#什么是有限状态机" class="headerlink" title="什么是有限状态机"></a>什么是有限状态机</h1><p>引用参考文档1的说明</p><blockquote><p><em>A <em><strong>Finite State Machine</strong></em> is a model of computation based on a hypothetical machine made of one or more states. Only one single state of this machine can be active at the same time. It means the machine has to transition from one state to another in to perform different actions.</em></p></blockquote><p>状态机就是包含多个状态的数学模型，并可以在状态之间进行变换并且触发一些动作。</p><p>一个状态机一般包含以下几个元素</p><ol><li><code>State</code> 当前状态</li><li><code>Event</code> 触发事件</li><li><code>Transition</code> 状态变换，或者说下一个状态(次态)</li><li><code>Action</code> 要执行的动作</li></ol><blockquote><p>在一些文章中，会将触发事件和执行动作的名称互换，这里笔者采用开源状态机 <code>Squirrel</code> 的定义</p></blockquote><p>即在一个状态下，某些事件触发后变换成了另一个状态，并执行了一些操作</p><h1 id="如何实现一个简单的状态机"><a href="#如何实现一个简单的状态机" class="headerlink" title="如何实现一个简单的状态机"></a>如何实现一个简单的状态机</h1><p>这里根据多篇参考文档，总结以下四种实现方式并进行简述，具体的实现代码可以查看参考文档2</p><h2 id="1-switch-case"><a href="#1-switch-case" class="headerlink" title="1. switch...case"></a>1. <code>switch...case</code></h2><ul><li>保存当前状态</li><li>状态变更时传入变更事件event, 先通过<code>if...else</code> 判断是哪个事件，再对当前事件 <code>event</code> 进行 <code>switch...case</code> 确定要执行的操作</li><li>进入下一个状态，并执行 <code>action</code></li></ul><p>简单代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachine</span> &#123;<br>    <span class="hljs-comment">// 当前状态</span><br>    <span class="hljs-keyword">private</span> State currState;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StateMachine</span><span class="hljs-params">(State initState)</span> &#123;<br>        <span class="hljs-built_in">this</span>.currState = initState;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transist</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">if</span> (当前是状态<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">switch</span> (event) &#123;<br>                <span class="hljs-keyword">case</span> 事件<span class="hljs-number">1</span>:<br>                    <span class="hljs-comment">// 设置下一个状态</span><br>                    <span class="hljs-comment">// 执行action</span><br>                <span class="hljs-keyword">case</span> 事件<span class="hljs-number">2</span>:<br>                  ...<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// ......</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该种方法实现是最简单的实现方法，在状态数量较少时，这是一个很高效的实现方案。但是在较复杂的状态下，会导致嵌套大量的 <code>if...else</code> 和 <code>switch...case</code> 语句，维护起来费劲而且实现不够优雅。</p><h2 id="2-状态模式-State-Design-Pattern"><a href="#2-状态模式-State-Design-Pattern" class="headerlink" title="2. 状态模式 (State Design Pattern)"></a>2. 状态模式 (<code>State Design Pattern</code>)</h2><p>原始定义如下</p><blockquote><p>Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.</p></blockquote><p>采用参考文档4的翻译对其进行解释</p><blockquote><p>外部的调用不用知道其内部如何实现状态和行为变化的</p></blockquote><p>状态模式主要就是对转换规则进行封装，封装状态而暴露行为，状态的改变看起来就是行为发生改变，总结起来，状态模式干了这么几件事</p><ul><li><p>需要定义状态抽象类 <code>AbstractState</code>，其中需要包含上下文 <code>Context</code>, 以及所有的抽象事件（<code>event</code>）对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractState</span> &#123;<br>    <span class="hljs-comment">// 上下文信息</span><br>    <span class="hljs-keyword">protected</span> Context context;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 事件操作放在具体的状态定义内</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event2</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>具体的状态需要继承并实现抽象状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">State1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractState</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">event1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// set next state</span><br>        <span class="hljs-comment">// do something else</span><br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>上下文 <code>Context</code> 中需要包含所有所需信息，包括所有的状态实例，并指定一个属性指示当前是哪个状态实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br><br>    <span class="hljs-comment">// 当前状态实例</span><br>    <span class="hljs-keyword">protected</span> AbstractState currState;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">State1</span> <span class="hljs-variable">state1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">State1</span>();<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">State2</span> <span class="hljs-variable">state2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">State2</span>();<br>    <span class="hljs-comment">// ......</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(AbstractState state)</span> &#123;<br>        setState(state);<br>    &#125;<br><br>    <span class="hljs-comment">// 具体的事件调用当前状态进行执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">event1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.currState.event1();<br>    &#125;<br><br>    <span class="hljs-comment">// ......</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>由上可见，状态模式将与行为与状态相绑定，避免了直接去写大量的 <code>if...else</code> 和 <code>switch...case</code> 编写时可以方便地增加新的状态，并且只需要改变对象的状态就可以改变对象的行为，</p><h2 id="3-Java枚举实现"><a href="#3-Java枚举实现" class="headerlink" title="3. Java枚举实现"></a>3. Java枚举实现</h2><p>利用枚举来实现，其主要思想在于可以将状态 <code>State</code> 和 事件 <code>Event</code> 都定义成一个枚举类型，并利用枚举也可以定义抽象方法的特性，使得其定义和动作可以写在一起</p><p>简单来说，其定义如下</p><ul><li><p>定义状态枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">StateEnum</span> &#123;<br>    State1 &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent1</span><span class="hljs-params">(StateMachine stateMachine)</span> &#123;<br>            <span class="hljs-comment">// set next state</span><br>            <span class="hljs-comment">// do something else</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent2</span><span class="hljs-params">(StateMachine stateMachine)</span> &#123;<br>            <span class="hljs-comment">// set next state</span><br>            <span class="hljs-comment">// do something else</span><br>        &#125;<br>        <span class="hljs-comment">// ......</span><br>    &#125;,<br>    <span class="hljs-comment">// .......</span><br>    ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent1</span><span class="hljs-params">(StateMachine stateMachine)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doEvent2</span><span class="hljs-params">(StateMachine stateMachine)</span>;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>定义事件枚举</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">EventEnum</span> &#123;<br>    Event1 &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trigger</span><span class="hljs-params">(StateMachine stateMachine, StateEnum state)</span> &#123;<br>            <span class="hljs-keyword">return</span> state.doEvent1(stateMachine);<br>        &#125;<br>    &#125;,<br>    <span class="hljs-comment">// ......</span><br>    ;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trigger</span><span class="hljs-params">(StateMachine stateMachine, StateEnum state)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>组装状态机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachine</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StateEnum state;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StateMachine</span><span class="hljs-params">(StateEnum state)</span> &#123;<br>        <span class="hljs-built_in">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(EventEnum event)</span> &#123;<br>        event.trigger(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">this</span>.state);<br>    &#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>该实现根据参考文档2做抽象，具体例子可以查看其文章</p><p>使用枚举来定义可以使得我们的代码更加清晰</p><h2 id="4-保存转换映射"><a href="#4-保存转换映射" class="headerlink" title="4. 保存转换映射"></a>4. 保存转换映射</h2><p>一言以蔽之，就是将状态机每一个状态转换所需要的几个要素都保存下来，在触发对应的事件时，遍历所有的状态映射记录，并根据状态以及上下文信息找到对应的记录，并执行转换得到次态</p><p>状态机的转换记录定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StateMachineRecord</span> &#123;<br>    <span class="hljs-comment">// 当前状态</span><br>    <span class="hljs-keyword">private</span> State currentState;<br>    <span class="hljs-comment">// 触发事件</span><br>    <span class="hljs-keyword">private</span> Event event;<br>    <span class="hljs-comment">// 次态</span><br>    <span class="hljs-keyword">private</span> State nextState;<br>    <span class="hljs-comment">// 执行动作</span><br>    <span class="hljs-keyword">private</span> Action action;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种方式实际上就是很多开源状态机的基础实现方式，不过在其实现中，会通过自定义注解的形式来使得代码更加简洁明了和优雅，并进行其他一些优化来优化性能，如记录索引以及懒加载等。</p><h2 id="5-srping-statemachine"><a href="#5-srping-statemachine" class="headerlink" title="5.srping statemachine"></a>5.srping statemachine</h2><p>当满足以下条件时，使用状态机是一个不错的选择：</p><ol><li>你可以将应用程序或其部分结构表示为状态。</li><li>你想将复杂的逻辑分解为较小的可管理的任务。</li><li>应用程序已经存在并发问题，例如某些事件以异步方式发生。</li></ol><p>当你满足以下条件时，你已经在尝试实现一个状态机：</p><ol><li>使用布尔标志或枚举来模拟情况。</li><li>某些变量仅在应用程序生命周期的某个部分具有意义。</li><li>通过 if-else 结构（或者更糟糕的是，多个这样的结构）进行循环，检查特定标志或枚举是否已设置，然后根据标志和枚举的组合存在与否进一步确定要执行的操作。</li></ol><p><a href="https://docs.spring.io/spring-statemachine/docs/3.2.1/reference/#quick-example">https://docs.spring.io/spring-statemachine/docs/3.2.1/reference/#quick-example</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">States</span> &#123;<br>STATE1, STATE2<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Events</span> &#123;<br>EVENT1, EVENT2<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableStateMachine</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EnumStateMachineConfigurerAdapter</span>&lt;States, Events&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(StateMachineStateConfigurer&lt;States, Events&gt; states)</span><br><span class="hljs-keyword">throws</span> Exception &#123;<br>states<br>.withStates()<br>.initial(States.STATE1)<br>.states(EnumSet.allOf(States.class));<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(StateMachineTransitionConfigurer&lt;States, Events&gt; transitions)</span><br><span class="hljs-keyword">throws</span> Exception &#123;<br>transitions<br>.withExternal()<br>.source(States.STATE1).target(States.STATE2)<br>.event(Events.EVENT1)<br>.and()<br>.withExternal()<br>.source(States.STATE2).target(States.STATE1)<br>.event(Events.EVENT2);<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@WithStateMachine</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> &#123;<br><br><span class="hljs-meta">@OnTransition(target = &quot;STATE1&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">toState1</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@OnTransition(target = &quot;STATE2&quot;)</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">toState2</span><span class="hljs-params">()</span> &#123;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br>StateMachine&lt;States, Events&gt; stateMachine;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignals</span><span class="hljs-params">()</span> &#123;<br>stateMachine<br>.sendEvent(Mono.just(MessageBuilder<br>.withPayload(Events.EVENT1).build()))<br>.subscribe();<br>stateMachine<br>.sendEvent(Mono.just(MessageBuilder<br>.withPayload(Events.EVENT2).build()))<br>.subscribe();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><a href="https://link.juejin.cn/?target=https://medium.com/@mlbors/what-is-a-finite-state-machine-6d8dec727e2c" title="https://medium.com/@mlbors/what-is-a-finite-state-machine-6d8dec727e2c">What is a Finite State Machine?. In this article, we are going to see… | by Mátyás Lancelot Bors | Medium</a></li><li><a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/97442825" title="https://zhuanlan.zhihu.com/p/97442825">Java有限状态机的4种实现对比</a></li><li><a href="https://link.juejin.cn/?target=https://www.jianshu.com/p/e335799a5a0b" title="https://www.jianshu.com/p/e335799a5a0b">设计模式之状态模式（State Pattern）</a></li><li><a href="https://link.juejin.cn/?target=https://blog.csdn.net/xiaxl/article/details/86306406" title="https://blog.csdn.net/xiaxl/article/details/86306406">Java 有限状态机 (设计模式——状态模式)_xiaxveliang-CSDN博客_java有限状态机</a></li><li><a href="https://link.juejin.cn/?target=https://www.baeldung.com/java-enum-simple-state-machine" title="https://www.baeldung.com/java-enum-simple-state-machine">Implementing Simple State Machines with Java Enums | Baeldung</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>CodeAesthetic</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeAesthetic</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态机/状态模式</title>
    <link href="/2023/06/27/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%9C%BA-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/06/27/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%9C%BA-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><p><strong>状态模式</strong>是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-1f5dace4bd23e47fe095a52e31d11525.png" alt="状态设计模式"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>状态模式与<strong>有限状态机</strong> 的概念紧密相关。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-a0105417ed6e6c8b61b838cb97e7b9cd.png" alt="有限状态机"></p><p>有限状态机。</p><p>其主要思想是程序在任意时刻仅可处于几种_有限_的_状态_中。 在任何一个特定状态中， 程序的行为都不相同， 且可瞬间从一个状态切换到另一个状态。 不过， 根据当前状态， 程序可能会切换到另外一种状态， 也可能会保持当前状态不变。 这些数量有限且预先定义的状态切换规则被称为_转移_。</p><p>你还可将该方法应用在对象上。 假如你有一个 <code>文档</code>Document类。 文档可能会处于 <code>草稿</code>Draft 、  <code>审阅中</code>Moderation和 <code>已发布</code>Published三种状态中的一种。 文档的 <code>publish</code>发布方法在不同状态下的行为略有不同：</p><ul><li>处于 <code>草稿</code>状态时， 它会将文档转移到审阅中状态。</li><li>处于 <code>审阅中</code>状态时， 如果当前用户是管理员， 它会公开发布文档。</li><li>处于 <code>已发布</code>状态时， 它不会进行任何操作。</li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-ff8c9b7256e3e66ea3930d214b902c33.png" alt="文档对象的全部状态"></p><p>文档对象的全部状态和转移。</p><p>状态机通常由众多条件运算符 （ <code>if</code>或 <code>switch</code> ） 实现， 可根据对象的当前状态选择相应的行为。  “状态” 通常只是对象中的一组成员变量值。 即使你之前从未听说过有限状态机， 你也很可能已经实现过状态模式。 下面的代码应该能帮助你回忆起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plain">class Document is<br>    field state: string<br>    // ……<br>    method publish() is<br>        switch (state)<br>            &quot;draft&quot;:<br>                state = &quot;moderation&quot;<br>                break<br>            &quot;moderation&quot;:<br>                if (currentUser.role == &quot;admin&quot;)<br>                    state = &quot;published&quot;<br>                break<br>            &quot;published&quot;:<br>                // 什么也不做。<br>                break<br>    // ……<br></code></pre></td></tr></table></figure><p>当我们逐步在 <code>文档</code>类中添加更多状态和依赖于状态的行为后， 基于条件语句的状态机就会暴露其最大的弱点。 为了能根据当前状态选择完成相应行为的方法， 绝大部分方法中会包含复杂的条件语句。 修改其转换逻辑可能会涉及到修改所有方法中的状态条件语句， 导致代码的维护工作非常艰难。</p><p>这个问题会随着项目进行变得越发严重。 我们很难在设计阶段预测到所有可能的状态和转换。 随着时间推移， 最初仅包含有限条件语句的简洁状态机可能会变成臃肿的一团乱麻。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中。</p><p>原始对象被称为_上下文_ （context）， 它并不会自行实现所有行为， 而是会保存一个指向表示当前状态的状态对象的引用， 且将所有与状态相关的工作委派给该对象。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-8d0a63ca2ae550c20c0a31a4f2404123.png" alt="文档将工作委派给一个状态对象"></p><p>文档将工作委派给一个状态对象。</p><p>如需将上下文转换为另外一种状态， 则需将当前活动的状态对象替换为另外一个代表新状态的对象。 采用这种方式是有前提的： 所有状态类都必须遵循同样的接口， 而且上下文必须仅通过接口与这些对象进行交互。</p><p>这个结构可能看上去与<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>模式相似， 但有一个关键性的不同——在状态模式中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； 策略则几乎完全不知道其他策略的存在。</p><h2 id="真实世界类比"><a href="#真实世界类比" class="headerlink" title="真实世界类比"></a>真实世界类比</h2><p>智能手机的按键和开关会根据设备当前状态完成不同行为：</p><ul><li>当手机处于解锁状态时， 按下按键将执行各种功能。</li><li>当手机处于锁定状态时， 按下任何按键都将解锁屏幕。</li><li>当手机电量不足时， 按下任何按键都将显示充电页面。</li></ul><h2 id="状态模式结构"><a href="#状态模式结构" class="headerlink" title="状态模式结构"></a>状态模式结构</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-bbd4143421b2d03c517a477ed08dbb3d.png" alt="状态设计模式的结构"></p><ol><li><p><strong>上下文</strong> （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。</p></li><li><p><strong>状态</strong> （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。</p></li><li><p><strong>具体状态</strong> （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。</p><p>状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。</p></li><li><p>上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。</p></li></ol><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p>在本例中， <strong>状态</strong>模式将根据当前回放状态， 让媒体播放器中的相同控件完成不同的行为。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687838996-6ec77b761096bed25ee61bccb472b268.png" alt="状态模式示例的结构"></p><p>使用状态对象更改对象行为的示例。</p><p>播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象， 以此改变播放器对于用户互动所作出的反应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs plain">// 音频播放器（Audio­Player）类即为上下文。它还会维护指向状态类实例的引用，<br>// 该状态类则用于表示音频播放器当前的状态。<br>class AudioPlayer is<br>    field state: State<br>    field UI, volume, playlist, currentSong<br><br>    constructor AudioPlayer() is<br>        this.state = new ReadyState(this)<br><br>        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不<br>        // 同的方式处理输入，其结果自然将依赖于当前所处的状态。<br>        UI = new UserInterface()<br>        UI.lockButton.onClick(this.clickLock)<br>        UI.playButton.onClick(this.clickPlay)<br>        UI.nextButton.onClick(this.clickNext)<br>        UI.prevButton.onClick(this.clickPrevious)<br><br>    // 其他对象必须能切换音频播放器当前所处的状态。<br>    method changeState(state: State) is<br>        this.state = state<br><br>    // UI 方法会将执行工作委派给当前状态。<br>    method clickLock() is<br>        state.clickLock()<br>    method clickPlay() is<br>        state.clickPlay()<br>    method clickNext() is<br>        state.clickNext()<br>    method clickPrevious() is<br>        state.clickPrevious()<br><br>    // 状态可调用上下文的一些服务方法。<br>    method startPlayback() is<br>        // ……<br>    method stopPlayback() is<br>        // ……<br>    method nextSong() is<br>        // ……<br>    method previousSong() is<br>        // ……<br>    method fastForward(time) is<br>        // ……<br>    method rewind(time) is<br>        // ……<br><br><br>// 所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相<br>// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。<br>abstract class State is<br>    protected field player: AudioPlayer<br><br>    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的<br>    // 上下文数据。<br>    constructor State(player) is<br>        this.player = player<br><br>    abstract method clickLock()<br>    abstract method clickPlay()<br>    abstract method clickNext()<br>    abstract method clickPrevious()<br><br><br>// 具体状态会实现与上下文状态相关的多种行为。<br>class LockedState extends State is<br><br>    // 当你解锁一个锁定的播放器时，它可能处于两种状态之一。<br>    method clickLock() is<br>        if (player.playing)<br>            player.changeState(new PlayingState(player))<br>        else<br>            player.changeState(new ReadyState(player))<br><br>    method clickPlay() is<br>        // 已锁定，什么也不做。<br><br>    method clickNext() is<br>        // 已锁定，什么也不做。<br><br>    method clickPrevious() is<br>        // 已锁定，什么也不做。<br><br><br>// 它们还可在上下文中触发状态转换。<br>class ReadyState extends State is<br>    method clickLock() is<br>        player.changeState(new LockedState(player))<br><br>    method clickPlay() is<br>        player.startPlayback()<br>        player.changeState(new PlayingState(player))<br><br>    method clickNext() is<br>        player.nextSong()<br><br>    method clickPrevious() is<br>        player.previousSong()<br><br><br>class PlayingState extends State is<br>    method clickLock() is<br>        player.changeState(new LockedState(player))<br><br>    method clickPlay() is<br>        player.stopPlayback()<br>        player.changeState(new ReadyState(player))<br><br>    method clickNext() is<br>        if (event.doubleclick)<br>            player.nextSong()<br>        else<br>            player.fastForward(5)<br><br>    method clickPrevious() is<br>        if (event.doubleclick)<br>            player.previous()<br>        else<br>            player.rewind(5)<br></code></pre></td></tr></table></figure><h2 id="状态模式适合应用场景"><a href="#状态模式适合应用场景" class="headerlink" title="状态模式适合应用场景"></a>状态模式适合应用场景</h2><p>如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。</p><p>模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。</p><p>如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。</p><p>状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。</p><p>当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。</p><p>状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ol><li><p>确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。</p></li><li><p>声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。</p></li><li><p>为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。</p><p>在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：</p><ul><li>将这些成员变量或方法设为公有。</li><li>将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。</li><li>将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。</li></ul></li><li><p>在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。</p></li><li><p>再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。</p></li><li><p>为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。</p></li></ol><h2 id="状态模式优缺点"><a href="#状态模式优缺点" class="headerlink" title="状态模式优缺点"></a>状态模式优缺点</h2><ul><li><p>_单一职责原则_。 将与特定状态相关的代码放在单独的类中。</p></li><li><p>_开闭原则_。 无需修改已有状态类和上下文就能引入新状态。</p></li><li><p>通过消除臃肿的状态机条件语句简化上下文代码。</p></li><li><p>如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。</p></li></ul><h2 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h2><ul><li><p><a href="https://refactoringguru.cn/design-patterns/bridge">桥接模式</a>、 <a href="https://refactoringguru.cn/design-patterns/state">状态模式</a>和<a href="https://refactoringguru.cn/design-patterns/strategy">策略模式</a> （在某种程度上包括<a href="https://refactoringguru.cn/design-patterns/adapter">适配器模式</a>） 模式的接口非常相似。 实际上， 它们都基于<a href="https://refactoringguru.cn/design-patterns/composite">组合模式</a>——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</p></li><li><p><a href="https://refactoringguru.cn/design-patterns/state">状态</a>可被视为<a href="https://refactoringguru.cn/design-patterns/strategy">策略</a>的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 _策略_使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但_状态_模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。</p></li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p><a href="https://refactoringguru.cn/design-patterns/state/java/example">java状态机代码</a></p><p><a href="https://refactoringguru.cn/design-patterns/catalog">设计模式目录</a></p>]]></content>
    
    
    <categories>
      
      <category>CodeAesthetic</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeAesthetic</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML类图</title>
    <link href="/2023/06/26/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%96%87%E6%A1%A3%E8%83%BD%E5%8A%9B/UML%E7%B1%BB%E5%9B%BE/"/>
    <url>/2023/06/26/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%96%87%E6%A1%A3%E8%83%BD%E5%8A%9B/UML%E7%B1%BB%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>UML图有很多种，但是并非必须掌握所有的UML图，才能完整系统分析和设计工作。一般说来，在UML图中，只要掌握类图、用例图、时序图的使用，就能完成大部分的工作。也就是说，掌握UML的20%，就能做80%的事情。对于程序员来说，最频繁使用的莫过于类图。因此，这里我们只讲解UML类图。至于其它UML图，请在以后的工作中参阅更多UML学习资料继续学习。</p><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p><h2 id="类图中具体类、抽象、接口和包的表示法"><a href="#类图中具体类、抽象、接口和包的表示法" class="headerlink" title="类图中具体类、抽象、接口和包的表示法"></a>类图中具体类、抽象、接口和包的表示法</h2><p>UML类图中具体类、抽象类、接口和包有不同的表示方法。</p><h3 id="1）在UML类图中表示具体类"><a href="#1）在UML类图中表示具体类" class="headerlink" title="1）在UML类图中表示具体类"></a>1）在UML类图中表示具体类</h3><p>具体类在类图中用矩形框表示，矩形框分为三层：第一层是类名字。第二层是类的成员变量；第三层是类的方法。成员变量以及方法前的访问修饰符用符号来表示：</p><ul><li>“+”表示 <code>public</code>；</li><li>“-”表示 <code>private</code>；</li><li>“#”表示 <code>protected</code>；</li><li>不带符号表示 <code>default</code>。</li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-76d10deeefd09d9c63fdbeebe3fa185b.webp"></p><h3 id="2）在UML类图中表示抽象类"><a href="#2）在UML类图中表示抽象类" class="headerlink" title="2）在UML类图中表示抽象类"></a>2）在UML类图中表示抽象类</h3><p>抽象类在UML类图中同样用矩形框表示，但是抽象类的类名以及抽象方法的名字都用斜体字表示，如图2所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-b24d2f8986d0b7f37d7468b5904c1bd4.webp"></p><h3 id="3）在UML类图中表示接口"><a href="#3）在UML类图中表示接口" class="headerlink" title="3）在UML类图中表示接口"></a>3）在UML类图中表示接口</h3><p>接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 &lt;<interface>&gt;表示，下面是接口的名字，第二层是方法，如图3所示。此外，接口还有另一种表示法，俗称棒棒糖表示法，就是类上面的一根棒棒糖（圆圈+实线）。圆圈旁为接口名称，接口方法在实现类中出现。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-aebaad80516b96524cfedcab8166b260.webp"></p><h3 id="4）在UML类图中表示包"><a href="#4）在UML类图中表示包" class="headerlink" title="4）在UML类图中表示包"></a>4）在UML类图中表示包</h3><p>类和接口一般都出现在包中，UML类图中包的表示形式如图4所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-8c8eca9697c958e10b88ffc3e5229e0e.webp"></p><h2 id="在类图中表示关系"><a href="#在类图中表示关系" class="headerlink" title="在类图中表示关系"></a>在类图中表示关系</h2><p>类和类、类和接口、接口和接口之间存在一定关系，UML类图中一般会有连线指明它们之间的关系。关系共有六种类型，分别是实现关系、泛化关系、关联关系、依赖关系、聚合关系、组合关系，如图6所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-4228555c00591dbd1d650077120d06a5.webp"></p><p>下面我们详细讲述这些关系，以及在UML类图中如何表示这些关系。</p><h3 id="1）实现关系"><a href="#1）实现关系" class="headerlink" title="1）实现关系"></a>1）实现关系</h3><p>实现关系是指接口及其实现类之间的关系。在UML类图中，实现关系用空心三角和虚线组成的箭头来表示，从实现类指向接口，如图1.9所示。在Java代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-53984084fd799034920b1d869098cff9.webp"></p><h3 id="2）泛化关系"><a href="#2）泛化关系" class="headerlink" title="2）泛化关系"></a>2）泛化关系</h3><p>泛化关系（Generalization）是指对象与对象之间的继承关系。如果对象A和对象B之间的“is a”关系成立，那么二者之间就存在继承关系，对象B是父对象，对象A是子对象。例如，一个年薪制员工“is a”员工，很显然年薪制员工Salary对象和员工Employee对象之间存在继承关系，Employee对象是父对象，Salary对象是子对象。</p><p>在UML类图中，泛化关系用空心三角和实线组成的箭头表示，从子类指向父类，如图8所示。在Java代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-baece5e3b1d7b76792836d42715bc07c.webp"></p><h3 id="3）关联关系"><a href="#3）关联关系" class="headerlink" title="3）关联关系"></a>3）关联关系</h3><p>关联关系（Association）是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在Java中，关联关系的代码表现形式为一个对象含有另一个对象的引用。也就是说，如果一个对象的类代码中，包含有另一个对象的引用，那么这两个对象之间就是关联关系。</p><p>关联关系有单向关联和双向关联。如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</p><p>在UML图中，双向关联关系用带双箭头的实线或者无箭头的实线双线表示。单向关联用一个带箭头的实线表示，箭头指向被关联的对象，如图9所示。这就是导航性（Navigatity）。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-cc93e22907f1813cba7a961a58a5b49d.webp"></p><p>一个对象可以持有其它对象的数组或者集合。在UML中，通过放置多重性（multipicity）表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。多重性允许的表达式示例如下：</p><ul><li>数字：精确的数量</li><li><code>*</code>或者<code>0..*</code>：表示0到多个</li><li><code>0..1</code>：表示0或者1个，在Java中经常用一个空引用来实现</li><li><code>1..*</code>：表示1到多个</li></ul><p>关联关系又分为依赖关联、聚合关联和组合关联三种类型。</p><h3 id="4）依赖关系"><a href="#4）依赖关系" class="headerlink" title="4）依赖关系"></a>4）依赖关系</h3><p>依赖（Dependency）关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象A依赖于对象B，则 A “use a” B。比如驾驶员和汽车的关系，驾驶员使用汽车，二者之间就是依赖关系。</p><p>在UML类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用，如图10所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-4250106b233c796b8936c5f10d829d84.webp"></p><p>依赖关系在Java中的具体代码表现形式为<strong>B为A的构造器</strong>或<strong>方法中的局部变量</strong>、<strong>方法或构造器的参数</strong>、<strong>方法的返回值</strong>，或者<strong>A调用B的静态方法</strong>。</p><p>下面我们用代码清单1和代码清单2所示的Java代码来演示对象和对象之间的依赖关系。</p><p>代码清单1所示的<code>B</code>类定义了一个成员变量 <code>field1</code>，一个普通方法 <code>method1()</code> 和一个静态方法 <code>method2()</code>。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">//代码清单1 B.java<br>public class B &#123;<br>  public String field1;   //成员变量<br><br>  public void method1() &#123;<br>    System.println(&quot;在类B的方法1中&quot;);<br>  &#125;<br><br>  public static void method2() &#123;                 //静态方法<br>    System.out.println(&quot;在类B的静态方法2中&quot;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码清单2所示的<code>A</code>类依赖于<code>B</code>类，在<code>A</code>类中定义了四个方法，分别演示四种依赖形式。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs text">/* 代码清单2 A.java<br>  A依赖于B<br>*/<br><br>public class A &#123;<br>  public void method1() &#123;<br>    //A依赖于B的第一种表现形式：B为A的局部变量<br>    B b = new B();<br>    b.method1();<br>  &#125;<br><br>  public void method2() &#123;<br>    //A依赖于B的第二种表现形式： 调用B的静态方法<br>    B.method2();<br>  &#125;<br><br>  public void method3(B b)  &#123;<br>    //A依赖于B的第三种表现形式：B作为A的方法参数<br>    String s = b.field1;<br>  &#125;<br><br>  //A依赖于B的第四种表现形式：B作为A的方法的返回值<br>  public B method4() &#123;<br>    return new B();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5）聚合关系与组合关系"><a href="#5）聚合关系与组合关系" class="headerlink" title="5）聚合关系与组合关系"></a>5）聚合关系与组合关系</h3><p>聚合（Aggregation）是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。例如，公司部门与员工的关系，一个员工可以属于多个部门，一个部门撤消了，员工可以转到其它部门。</p><p>在UML图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方，如图11所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-aebc9fd69e23a717271a518cb151352b.webp"></p><p>组合（Composition）也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期。这种关系比聚合更强，也称为强聚合。如果<code>A</code>组合<code>B</code>，则<code>A</code>需要知道<code>B</code>的生存周期，即可能<code>A</code>负责生成或者释放<code>B</code>，或者<code>A</code>通过某种途径知道<code>B</code>的生成和释放。</p><p>例如，人包含头、躯干、四肢，它们的生命周期一致。当人出生时，头、躯干、四肢同时诞生。当人死亡时，作为人体组成部分的头、躯干、四肢同时死亡。</p><p>在UML图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方，如图12所示。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687759606-e551841a4128318ed4b801df0cf14503.webp"></p><p>在Java代码形式上，聚合和组合关系中的部分对象是整体对象的一个成员变量。但是，在实际应用开发时，两个对象之间的关系到底是聚合还是组合，有时候很难区别。在Java中，仅从类代码本身是区分不了聚合和组合的。如果一定要区分，那么如果在删除整体对象的时候，必须删掉部分对象，那么就是组合关系，否则可能就是聚合关系。从业务角度上来看，如果作为整体的对象必须要部分对象的参与，才能完成自己的职责，那么二者之间就是组合关系，否则就是聚合关系。</p><p>例如，汽车与轮胎，汽车作为整体，轮胎作为部分。如果用在二手车销售业务环境下，二者之间就是聚合关系。因为轮胎作为汽车的一个组成部分，它和汽车可以分别生产以后装配起来使用，但汽车可以换新轮胎，轮胎也可以卸下来给其它汽车使用。如果用在驾驶系统业务环境上，汽车如果没有轮胎，就无法完成行驶任务，二者之间就是一个组合关系。再比如网上书店业务中的订单和订单项之间的关系，如果订单没有订单项，也就无法完成订单的业务，所以二者之间是组合关系。而购物车和商品之间的关系，因为商品的生命周期并不被购物车控制，商品可以被多个购物车共享，因此，二者之间是聚合关系。</p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>文档能力</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文档能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只是完成了需求，研发的竞争优势在哪里？</title>
    <link href="/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E5%8F%AA%E6%98%AF%E5%AE%8C%E6%88%90%E4%BA%86%E9%9C%80%E6%B1%82%EF%BC%8C%E7%A0%94%E5%8F%91%E7%9A%84%E7%AB%9E%E4%BA%89%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F/"/>
    <url>/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E5%8F%AA%E6%98%AF%E5%AE%8C%E6%88%90%E4%BA%86%E9%9C%80%E6%B1%82%EF%BC%8C%E7%A0%94%E5%8F%91%E7%9A%84%E7%AB%9E%E4%BA%89%E4%BC%98%E5%8A%BF%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>  灵魂拷问：“只是完成了输入的需求，那你作为研发的竞争优势在哪里？”  </p><p>  初看这个问题，一脸懵。研发的职责不就是承接产品需求、按时按质量交付功能效果嘛。既然已经完成了需求，这个问题还能回答出什么呢？</p><h2 id="什么是需求"><a href="#什么是需求" class="headerlink" title="什么是需求"></a>什么是需求</h2><p>  首先，什么是需求？不翻书本上的定义，我们可以简单把需求理解为“用户的需要和要求”。比如：</p><ul><li>功能的DAU上升10%；</li><li>提升网络传输安全性；</li><li>在公司的电脑点Ctrl+C后，在家里面可以Ctrl+V粘贴出来；</li><li>基于手机壳颜色调整UI配色；</li><li>刷1000个Q币；</li><li>去西藏净化心灵；</li><li>做一个淘宝&#x2F;百度那样的网站；<br>等等等等。</li></ul><p>  需求自然是从用户(通常是非技术人员层面)角度来考虑的，它的重心是放在目标、收益这个层面的，重点阐述的是“为什么要做”和“做成什么样”。通过对这些内容的阐述，需求方可以调整优先级，争取到宝贵的人力资源和排期。<br>  需求有一个核心特点，凡是能被提交到研发手里的，都会被认为是“可达成”的。俗称“<strong>这个需求很简单，怎么实现你随便–明天上线</strong>”和“<strong>我有一个绝妙的点子，就差一个研发</strong>”。那么，如果仅仅是按时按质量的完成了目标，对于需求方来说就是“<strong>符合预期</strong>”，自然也就是“是个研发都能做”，沦为耗材和工具人，确实没有什么特殊优势。<br>  如果我们不满足于“符合预期”，那该怎么办呢？</p><h2 id="需求的研发过程"><a href="#需求的研发过程" class="headerlink" title="需求的研发过程"></a>需求的研发过程</h2><p>  从研发的角度讲，收到输入的需求后，直观的想法就是制定技术方案、立刻投入研发。需求的基本的处理流程可能包括以下环节：</p><ol><li>需求沟通：明确输入方到底要干什么，确认需求的实现难度<br>  * 用户的手机壳到底有多少种颜色？与UI配色的映射关系是什么</li><li>方案设计与评审：明确研发方案，识别各个环节的修改点和资源投入<br>  * 如何获取手机壳的颜色<br>  * 如何调整UI配色</li><li>研发实现与自测：按照研发方案，实现各个需求，完成自测<br>  * 自测：在我的手机上能运行</li><li>QA测试与入版：重点验收各个功能是否符合预期，尤其是在极限场景<br>  * 常规Case：套红色手机壳；套绿色手机壳<br>  * 极限Case：套透明手机壳；套两个手机壳；不套手机壳；套半个手机壳</li><li>bugfix：线上badcase调查与修复</li></ol><p>  上面是一个基本的需求研发的过程，除了涉及到研发自身以外，还引入了需求和QA测试等团队。对于任何一个研发同学而言，都需要能够完成上述研发工作。</p><p>  那么，针对本文的核心问题“研发的竞争优势”，我们该如何回答呢？</p><h2 id="研发的价值"><a href="#研发的价值" class="headerlink" title="研发的价值"></a>研发的价值</h2><p>  研发的优势，或者研发同学的能力，在已经交付需求的前提下，还能如何衡量呢？</p><ul><li>代码数量？但从来没有拿代码行数来折算工资；</li><li>需求数量？不同需求的体量差异巨大，不能一概而论；</li><li>线上收益？直接影响就是旱涝不均，直接收益低的任务会被所有人排斥(磨刀不如去砍柴)；</li></ul><p>  既然上面这些都不是，那不如我们在深入剖析一下研发过程，还有哪些工作能力是研发所具备乃至仅有研发才具备的呢？</p><table><thead><tr><th>阶段</th><th>研发所具备的能力</th><th>备注</th></tr></thead><tbody><tr><td>需求沟通</td><td>1.该不该：需求的价值所在<br />2.能不能：需求的可行性评估和成本<br />3.先后顺序：不同需求的关联和优先级评估</td><td>1.SMART原则<br />2.研发团队也会发起需求</td></tr><tr><td>方案设计与评审</td><td>1.制定方案：从用户需求到技术方案<br />2.系统性思维：需求的深层关联和隐藏影响<br />3.验证手段：验证项目目标是否达成<br />4.前瞻空间：为未来预留优化和扩展空间<br />5.协作：跨团队的沟通、分工和协作</td><td>1.祖传代码的诅咒<br />2.需求之间的关联影响；</td></tr><tr><td>研发实现与自测</td><td>1.实现：基于研发方案实现需求<br />2.自测：在研发过程中review项目目标可否达成<br />3.基建：构建正确和高效的自测能力</td><td>1.专业知识沉淀是研发自身的成长</td></tr><tr><td>QA测试与入版</td><td>1.提测：向QA输出需求的影响范围(直接和间接)<br />2.基建：配合QA构建测试能力(日志、开关等)</td><td>1.“全功能回测”是耍流氓</td></tr><tr><td>收益与复盘</td><td>1.收益：线上数据埋点与收益分析<br />2.售后：线上问题和用户反馈的分析与解决<br />3.复盘：完成需求与研发复盘，改正过程问题</td><td>1.看广告、更要看疗效</td></tr></tbody></table><p>  上述这个表格还可以继续补充内容，接下来我们针对几个子问题抛砖引玉。</p><h3 id="需求沟通–可行性评估和成本"><a href="#需求沟通–可行性评估和成本" class="headerlink" title="需求沟通–可行性评估和成本"></a>需求沟通–可行性评估和成本</h3><p>  需求通常是从用户和业务的需要角度来制定的，天然就需要技术判定。这里最重要的判定就是可行性和成本分析。这一点必须由研发团队来基于当前的技术前沿水平、研发团队的技术积累等等，共同确定需求是否可行以及相应的前提条件与成本。<strong>可行性判定，从来不是为了证明不可行，而是要明确需求可行的前提条件(如技术发展、政策空间等)和相应的成本(人力投入、机器资源、外部团队协作)等</strong>。<br>  良好的可行性评估，也需要研发在技术上的嗅觉和判断力，这很考验一个研发的技术沉淀和对业务的理解。<br>  例如：“<a href="https://www.douban.com/group/topic/6440945/?_i=9725441JkC1i_x,1011298JkC1i_x">是这样的张总：你在家里的电脑上按了CTRL+C,然后在公司的电脑上再按CTRL+V是肯定不行的。即使同一篇文章也不行。不不，多贵的电脑都不行</a>”，在2009年看这个需求是个搞笑段子(前提条件不成熟)。但是在互联网尤其是移动互联网时代，基于<strong>云端互联和账号体系</strong>，这个需求就成为现实<a href="https://support.microsoft.com/zh-cn/windows/%E5%89%AA%E8%B4%B4%E6%9D%BFwindows-c436501e-985d-1c8d-97ea-fe46ddf338c6">Windows10-使用基于云的剪贴板从一台电脑上复制图像和文本并粘贴到另一台电脑上</a>。<br>  总之，从研发的角度看，最强的FLAG自然是“<strong>只有想不到、没有做不到</strong>”，永远不要给自己设限。</p><h3 id="需求沟通–不同需求的关联和优先级"><a href="#需求沟通–不同需求的关联和优先级" class="headerlink" title="需求沟通–不同需求的关联和优先级"></a>需求沟通–不同需求的关联和优先级</h3><p>  “上面千条线、下面一根针”。所有的需求，不管是从哪个来源输入的，都会统一汇总到研发团队手中。此时，研发团队就具有比任何团队都全面的信息优势–“<strong>所有需求的合集</strong>”。由于来自不同来源(包括研发自驱)，这些需求之间就存在很多可能的关联和影响：</p><ul><li>顺序依赖：某些需求在实现方案上有依赖，导致在时间上要有先后关系；</li><li>相互排斥：各个需求来源都有自己的目标体系，因此会输出一些互相妨碍的需求。例如，“缩减安装包体积提升下载成功率”和“将资源文件内置在安装包内以优化启动耗时”；</li><li>化零为整：需求是可以合并完成的，那在研发时可以并案处理，比如针对安卓和iOS的类似需求；</li><li>举一反三：需求在未来明显有扩展的空间，那就可以与需求方沟通明确，是否要把未来的需求也合并处理；<br>  总之，需求沟通阶段，研发团队要基于自身独有的信息优势，灵活的与各个需求方沟通探讨，将视野从单个需求走向所有需求和所有业务，合理区分优先级和调配资源投入方向，确保在关键方向拿到关键结果。</li></ul><h3 id="需求沟通–研发自我驱动的需求"><a href="#需求沟通–研发自我驱动的需求" class="headerlink" title="需求沟通–研发自我驱动的需求"></a>需求沟通–研发自我驱动的需求</h3><p>  研发团队在日常工作中，基于对用户需要的理解和研发过程中的痛点，也会主动发起一些需求。研发在发起需求时，需要考虑如下因素：</p><ul><li>三思而行：研发自驱的需求，通常都能明确解决某一类问题(比如研发自身所直接面临的问题)，其价值是明确的。但过程中还是会存在一些风险，要积极排除这些风险的影响；<ul><li>我即世界：指以个人喜好代表了全体用户的选择，在没有数据支撑的前提下就盲目立项和启动，反而可能在某些用户群体上产生强烈的排斥(如强行颠覆对方的使用习惯)；</li><li>盲目追求极致：研发作为技术控，默认会在技术上追求极致，有时候也会陷入误区。比如，对重复周期很大(如月活为1)的工作进行人效优化，其必要性有待商榷；</li><li>忽视相关团队：研发自驱的需求通常会由研发团队自行评审和实现，这个过程中产品和业务等团队可能是无感的，此时就容易出现需求冲突和资源竞争等问题。建议在事前积极与产品团队沟通协调、搞好合作关系，提升团队信任度和影响力，争取更多资源，必要时将需求转为<strong>产研共建</strong>需求，避免沟通不通畅带来的负向影响。</li></ul></li><li>宜早不宜晚：基础设施建设类的需求是<strong>利在千秋</strong>的工作。因此，对于确实重要的任务要积极提升优先级、争取早日完成建设，并在后续的研发过程中持续收益。</li><li>有节制：特指基础设施建设类需求，如CodeReview流程、自动化测试、日志回收系统等。该类需求对研发过程有较大帮助，但也存在以下风险，需要积极避免。<ul><li>收益衡量：基建类工作的直接服务对象是研发自身，容易出现收益无法量化、业务方缺乏感知等问题。因此，在启动这类需求时，一定要预先明确如何评估价值收益；</li><li>收益递减：基建类工作可以无止境的进行下去，如CodeReview环节可以层层加码的检查，其收益是持续存在、但逐步变小，此时要特别注意性价比考量；</li><li>需求数量：考虑到OKR结算周期，可以拉长非紧急基建需求的建设周期，避免影响单个周期中个人与团队的业绩。</li></ul></li></ul><h3 id="方案设计与评审–系统性思维"><a href="#方案设计与评审–系统性思维" class="headerlink" title="方案设计与评审–系统性思维"></a>方案设计与评审–系统性思维</h3><p>  系统性思维，是指在进行方案设计与评审时，能够把输入的单个需求和历史现状当成一个整体，从全局的角度来制定和评判方案的优劣性。这样的好处是：</p><ul><li>全局最优：从全局制定的技术方案，能够避免陷入到局部最优，确保不会因为个别需求导致系统崩塌；</li><li>容易识别关联影响：精确识别出关联影响后，可以减少历史功能被劣化的可能性，也会大大提升研发自测和QA测试的效率；</li><li>项目分工：通过系统性思考，能够更科学的进行任务分解，在具体研发时也便于研发之间的协同与配合；</li></ul><p>  通过系统性的思维建设，能够走出个体视野的局限、跨越单个需求的边界，从整个系统的层次来考虑方案，往前、往外多走一步，方案的可靠程度也更高一些。</p><h3 id="业务数据观察–数据埋点与分析"><a href="#业务数据观察–数据埋点与分析" class="headerlink" title="业务数据观察–数据埋点与分析"></a>业务数据观察–数据埋点与分析</h3><p>  所有需求的目的肯定都是直接或间接的服务业务，而研发的惯性很容易出现“只注重交付、不关注收益”的情况。一旦落入这个陷阱，那研发的存在价值就被需求方所掌握，<strong>需求方靠谱时趁机喝点汤、需求方不靠谱时直接傻眼</strong>，彻底退化为工具人。在降本增效的前提下，不关注、不了解产出详情是非常不利的。</p><ul><li>收益评估：这里的收益通常说的是业务收益。从研发角度看，一些重要的过程指标(如关键子模块的耗时、奔溃率等)也需要关注，确保符合需求目标(尤其是防劣化)。为达成该目的，需要在研发阶段就统筹规划并建设埋点上报机制，及时发现非预期变化。</li><li>问题调查和修复：当收益不符合预期(显著超出或低于)时，就需要使用预先构建的问题调查手段，如关键埋点、日志上报、调试平台等。这些能力也需要研发主动建设并持续完善。</li></ul><p>  总而言之，线上数据的实际情况是研发必须关注和负责的，尤其是针对异常情况的分析定位(以及相应的能力建设)，更是研发所独有的能力。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  回到一开始的问题，如果仅仅只是“完成”了输入需求，那自然也就只是一个跟随的角色、随着外部指挥棒而起舞，对自身的能力建设和自我展示都不够。在未来的项目主R、晋升答辩的过程中，也会受到挑战和质疑。如果能够拓宽角色并超越“<strong>写代码</strong>”的局限，将研发同学的价值体现在“<strong>从需求输入到线上验证的每一个环节</strong>”，跳出圈子来看需求、解决问题，这才是一个研发所具备的独特的价值。</p><p>  <strong>一个不想当“用户”、“需求方”、“QA”、“数据分析”等等的研发不是一个好研发。</strong></p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>晋升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晋升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>晋升汇报之道(打怪兽版)</title>
    <link href="/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E6%99%8B%E5%8D%87%E6%B1%87%E6%8A%A5%E4%B9%8B%E9%81%93-%E6%89%93%E6%80%AA%E5%85%BD%E7%89%88/"/>
    <url>/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E6%99%8B%E5%8D%87%E6%B1%87%E6%8A%A5%E4%B9%8B%E9%81%93-%E6%89%93%E6%80%AA%E5%85%BD%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="1-什么是晋升汇报？"><a href="#1-什么是晋升汇报？" class="headerlink" title="1.什么是晋升汇报？"></a><strong>1.什么是晋升汇报？</strong></h1><h2 id="1）晋升汇报-≠-工作汇报，晋升汇报-≈-求职陈述-面试"><a href="#1）晋升汇报-≠-工作汇报，晋升汇报-≈-求职陈述-面试" class="headerlink" title="1）晋升汇报 ≠ 工作汇报，晋升汇报 ≈ 求职陈述&#x2F;面试"></a><strong>1）晋升汇报</strong> <strong>≠</strong> <strong>工作汇报，晋升汇报</strong> <strong>≈</strong> <strong>求职陈述&#x2F;面试</strong></h2><p>晋升汇报跟工作汇报不太一样，差别很大。</p><p>晋升汇报，不是把平时的工作汇报做一个加法 summary 起来，也不是工作汇报，而是“求职陈述&#x2F;面试”。求职的时候是怎么跟面试官讲自己的，你是需要这家公司买你&#x2F;给你发offer，而晋升汇报也就是他的后续。求职是进门，晋升是继续往前迈台阶。所以它不是工作汇报的近亲，而是求职陈述的近亲。</p><p>具体来看，工作汇报是考察的是事情做得怎么样，晋升汇报是通过过往的战功来考察你的人怎么样，你的能力怎么样。</p><h2 id="2）晋升汇报难在哪？"><a href="#2）晋升汇报难在哪？" class="headerlink" title="2）晋升汇报难在哪？"></a><strong>2）晋升汇报难在哪？</strong></h2><p>晋升汇报的难点：</p><ul><li>领导&#x2F;评委要看什么？</li><li>跨部门领导不懂我的专业？</li><li>时间有限如何表达好亮点？</li><li>今年工作不出彩就代表评优&#x2F;晋级无望？</li></ul><p>接下来要讲两部分，第一部分要讲思考视角，第二部分讲逻辑框架。</p><h1 id="2-晋升汇报中的思考视角"><a href="#2-晋升汇报中的思考视角" class="headerlink" title="2.晋升汇报中的思考视角"></a><strong>2.晋升汇报中的思考视角</strong></h1><p>思考视角分三块，毕竟是晋升汇报，不可能离开工作。</p><p>工作是载体，能力是关键，思考要前瞻。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-bb178f28d675af8e117c9579aedb73bb.png"></p><h2 id="1）工作是载体"><a href="#1）工作是载体" class="headerlink" title="1）工作是载体"></a><strong>1）工作是载体</strong></h2><p>首先在晋升汇报中不要流水账，要讲重点。很多评委老师说，看同学的能力有没有够对应级别，最多讲三个项目就好了，如三个项目都讲不清楚自己的能力是怎样的，讲再多也无用。</p><p>工作当中二八原理就是这样：20% 的员工贡献了公司 80% 的价值和利润，无论是公司、组织还是个人，都存在二八原理。</p><p>有些职位它不是项目制的，它是平台型工作，日复一日地完成这些工作，这种情况要怎么讲呢？平台型的工作在晋升汇报的时候，评委关注的是长板原理，长板原理关注的是最强之处，有一个非常厉害的地方，就已经能证明评委值得给开放一个晋升理由了。当然，短板原理叫一票否决制，只要你那块出了问题可能就失去资格了。</p><p><strong>如何选择你的3个项目？</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-64b9bf7bc6c3c5236947469175976e6c.png"></p><p>做晋升汇报的时候，如果存在这样 A、B 两个项目，应该选哪一个？</p><p>很多同学可能会受不了诱惑会讲 A，不是不可以讲 A，但这样是有风险的，如果这三个风险你都能避免，就可以讲A。</p><p>第一， A 项目是公司非常厉害的项目，你要知道坐在面前的评委和领导可能更加熟悉这个项目，甚至超过你的熟悉程度，评委对这个项目的价值&#x2F;背后的意义悟得很透，你如果讲的浅了，评委就会觉得你理解的太浅了。</p><p>第二，评委问你问题的时候，可能你发现你还不如他了解，会答不出来，再追问两句就答不出来了，因为他太了解了，信息对称度不一样。</p><p>第三，晋升考察的是能力，这种项目你勉强在里边，虽然项目很成功，可是他真的是你的能力吗？这次项目做的不错，可能是有老板帮你，或者是什么其他利好，如果再来一个大项目你还能搞定吗？</p><p>如果三个问题都认为有点悬，这种情况下讲 A 就是不明智的，因为这个项目必须是能展示你真正的能力，能 hold 得住再来一个类似的项目也不怕的话，这个项目就值得讲，否则建议还是讲 B。B 是自己能胜任的，而且不怕问，因为你的参与度极高，你是项目经理，什么细节你都知道，评委一问你就知道非常好。 所以建议不要贪图 A 项目，而是选 B 项目，讲真正属于你自己的项目，就是能跟你能力结合的非常好的那种项目。</p><h2 id="2）能力是关键"><a href="#2）能力是关键" class="headerlink" title="2）能力是关键"></a><strong>2）能力是关键</strong></h2><p>刚才讲工作是载体，接下来讲“表达能力是关键”。载体就是船。船上的货物才是最重要的，船是要载它的，所以工作是载体。船上的货就是能力，这个能力你能不能传递到河对岸，这个很关键。</p><p>如果你是导演&#x2F;编剧，要设计一部戏&#x2F;电影，想表达主人公能力强，会怎么去写这个剧本？这个故事要出现什么样的故事才能表达主人公能力强？如果主人公一出场，遇到什么事都搞得定，你以为他能力强，其实这种电影是最乏味的。更多的导演&#x2F;编剧基本是要让主人公去跟一个非常强大的对手干一仗，貌似干不过，甚至一开始都打不过，最后想办法把对手干掉了，这个时候这个角色的强大才得以树立起来。</p><p><strong>只讲你用什么打的、怎么打的就行了，不要讲日常工作，也不要讲职位描述。</strong></p><p>产品经理就干产品，你开发经理就是做开发，职位描述不是晋升汇报的内容，打怪兽就有难度的事情，所以说就是用什么方法&#x2F;资源解决很难的问题，这个地方一旦说通，我们就认为晋升汇报表达能力就到位了。这个方法叫问题及解决模式，这种模式是相当多的汇报中出现的一种模式，很多同学连问题都没有说清楚，就说自己干了什么，你干的事情到底解决啥问题，光说一个结果是没有什么用的，所以这种模式简化一下也叫做“打怪兽模式”。</p><p>用暗喻的方法来理解，假设自己是一款产品，公司应该支付更高的职位和薪水来聘请你，怎么售卖自己这个产品呢？从这个维度往下想，其实就是就给大家一个卖产品的成熟框架——<strong>FAB（Features、Advantages、Benefits）</strong>，这三个维度其实蛮重要的。</p><p>FAB 法则：</p><ul><li>Feature - 工作本身是什么样子</li><li>Advantage - 和之前做相同的工作相比提升了什么&#x2F;和竞对对比有什么优势</li><li>Benefit - 给公司、社会带来什么价值</li></ul><p>Benefit 不仅是吸引人，而且还要表达价值。晋升汇报必须表达你对公司的价值，这个方向感一定要把它说好，往下说价值要落在角色上，不能空对空。各位同学的岗位不同，不能一概而论，但还有很多因为你的存在而感受到价值的角色，具体是前端用户在感知？还是平台的小伙伴们去感知？财务上有感知吗？竞争对手害怕我们吗？这都是要有感知的价值才行。把自己当成产品来卖，对公司的某个角色有感知的价值一定要说出来。</p><h2 id="3）思考要前瞻"><a href="#3）思考要前瞻" class="headerlink" title="3）思考要前瞻"></a><strong>3）思考要前瞻</strong></h2><p>工作是载体，能力是关键，但晋升不能光看这些硬性的东西，还有软性的思考，思考水准就是我们晋升当中最柔性的或者最有弹性的一部分，在这方面表达得很好的同学通常会胜出，那怎么表达思考呢？</p><p>这里只强调一个思考方向叫前瞻思考。过去一年做的所有事情，无论是用三个项目还是长板原理也好，过去的事情只证明了你胜任当下的职位，但是要把你放到更高的地方去，怎么能胜任那个职位，所以晋升必须得有前瞻性视角&#x2F;思考，就让评委感觉到如果把你放到那个高度，你仍然可以搞定。</p><p>所以每位同学可以想一想，你在这个工作岗位上，未来1<del>2年，高管要想到2</del>3年，中层职位、基层职位至少想一年，你有想法吗？对于专业线的同学，比如律师等有明显的专业标签的同学，再比如有些同学是有赛道的，比如 A 同学就是做这个产品线的，那么在这个产品赛道上，你就要带着竞争视角、专业视角讲讲未来打算怎么往下走才行，要让评委对你未来的胜任潜力做出一个比较肯定的评价，所以思考要前瞻。</p><h1 id="3-晋升汇报中的逻辑框架"><a href="#3-晋升汇报中的逻辑框架" class="headerlink" title="3.晋升汇报中的逻辑框架"></a><strong>3.晋升汇报中的逻辑框架</strong></h1><p>接下来详细说说，如何把刚才提到的“工作是载体、能力是关键、思考要前瞻”融到一个逻辑框架里去。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-29c0afe1372552a6e7a7762b099b3b1a.png"></p><h2 id="1）概述："><a href="#1）概述：" class="headerlink" title="1）概述："></a><strong>1）概述：</strong></h2><p>概述就是对过去的一年的总结，把所有的工作给评委一个大画面。建议的结构是：【关键指标】+【要义主题句】。</p><p>如果你能用几个关键指标加上一个主题句，几组这样的东西，每组只要两行字，这样就能比较清晰地表达出来，示例：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-951cfa4bed8bcaa0ba3d27ecaa88365e.png"></p><h2 id="2）挑战与冲突："><a href="#2）挑战与冲突：" class="headerlink" title="2）挑战与冲突："></a><strong>2）挑战与冲突：</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-6ed6fd8cb3b9f3074b11e55e3cb86af8.png"></p><p>挑战和冲突对应的是前面讲的“打怪兽”部分，注意到这里有三个白色的小圆点，这里表示的是陈述量。困难与压力只有一个小点，也就意味着少讲一点。有的同学说挑战和困难不是一回事吗？是怎么区分的？</p><p>其实是有一个维度，挑战是外在的，如果你的工作是来自于行业的变化、国家政策趋势的变化带来的影响、友商的压力，这些都叫外在的挑战和冲突，冲突就是跟友商。困难和压力是内在的。比方说你团队的同学都是新手，这对你来讲很有压力，或者你是空降过来一个新岗位的，你对这个东西也是陌生的，那也是压力。建议多说外在，少说内在。</p><p>为什么要讲困难和挑战呢？因为坐在你面前的评委，更加资深的多，有时候资深的评委如果不对你足够了解，可能容易觉得你做的东西“其实也还好吧”。这时因没有设定基准，我们自己知道这一年已经有很大的进步，如果他看看去年的你，再看看今年的你，他才能看到你的改变和进步。</p><p>那么怎么表达这一段的变化？要讲你怎么打的怪兽，你当时遇到了什么困难把它战胜了，是不是这个过程？所以一定要让评委理解。</p><p>最糟糕的汇报，就是直接谈中间这个节点完成了什么，而没有左边这个节点，评委根本不知道这中间的变化，也不知道你的难度，只讲个结果，就是一个绝对值在中间，你觉得他怎么衡量，只能用他的水平来衡量。</p><h2 id="3）问题与解决：原则-方法-努力-资源-机遇"><a href="#3）问题与解决：原则-方法-努力-资源-机遇" class="headerlink" title="3）问题与解决：原则&#x2F;方法&#x2F;努力&#x2F;资源&#x2F;机遇"></a><strong>3）问题与解决：原则&#x2F;方法&#x2F;努力&#x2F;资源&#x2F;机遇</strong></h2><p>困难讲完了，怪兽立在这里总得打，问题就出在这里，前面“怪兽内容”摆了一堆，后边没见打。问题得解决，怪兽和解决方法一定要match上，可以通过原则&#x2F;方法&#x2F;努力&#x2F;资源&#x2F;机遇来展开说明。</p><ul><li>原则，有些岗位是有原则的，这个是不能动的，雷打都不能动，天塌下来都不能动，这种原则要坚守、维护。</li><li>方法，方法不是凭空产生的，面对你前面提到的问题，你是用什么方法解决的。</li><li>努力，努力是什么？就是辛苦，很多同学不善于表达自己多辛苦，因为大家都辛苦，所以也就不善于表达，但是表达好有几句话就可以了。原则、方法和努力都是来自于你自己很拼、很聪明去做的，接下来资源和机遇就不同了。</li><li>资源与机遇，外部资源就是公司给的，机遇是行业给的，是外部的条件。如果你今年的业绩不错，可能是由外部条件、公司给的资源、行业给的机会，而完成了一个很漂亮的工作。要讲明白是如何利用好资源和机遇，来做好事情，而不是因为“台风来了，猪都能飞起来”。</li></ul><h2 id="4）成果："><a href="#4）成果：" class="headerlink" title="4）成果："></a><strong>4）成果：</strong></h2><p>有同学会问，在前面的概述阶段也亮出一些指标性的成果，怎么后边又要写成果和收获呢？还有，汇报到底是结论先行还是结论后行？结论先行就先说结论，结论后行就先分析。其实都可以，结论先行&#x2F;后行主要的依据是你跟对方对这件事情的信息对称度或者叫理念对称度。这件事情双方都懂，那就结论先行没错，理念对称度，就是我同意你也同意，就先说结论。但是当信息对称度极差，我们就分析先行或者故事先行。</p><p>讲完成果收获，如果是跨部门的评委，你对他有什么价值？需要知道他是谁的价值的代表者，是公司价值、还是组织价值？代表着 FAB 的 Benefit，你怎么才能讲到公司价值，因为你把经验沉淀下来，复制了一些，交给了&#x2F;分享了&#x2F;传承了给其他团队，那么这就牛了。在成果这个方面，个人视角就叫成果，组织视角叫经验的传承。</p><h2 id="5）未来规划："><a href="#5）未来规划：" class="headerlink" title="5）未来规划："></a><strong>5）未来规划：</strong></h2><p>谈未来≠谈工作计划。评委老师不会听你明年1月打算做什么，2月打算做什么，或是这个产品怎么做，评委很难看这么细。今年你“打怪兽”很成功，明年要打的怪兽（即挑战和风险）是什么，你判断对了吗？机会和创新又是什么？如果说连这个想法都没有，就要自己多想想了。这就是前瞻性思考，这些足以说明你的思考水平，而不是事务性的东西。总结过去是能力，看到未来是眼光，这会是一个很好的晋升汇报。</p><p><strong>简化版本：</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-8398ee7db1688b35e48e7817487d5e11.png"></p><p><strong>汇报15分钟一定讲得完，具体来看：</strong></p><ul><li><strong>概述</strong>，只要一页PPT，讲自己工作的大图，这里需要大概半分钟，最多一分钟。</li><li><strong>“打怪兽”</strong>，讲真正属于自己的项目，如果按二八原理就讲三个。一定要是用问题及解决模式来讲，挑战是什么，应对是什么。这一块七八分钟，就算是一个项目讲三分钟，讲到这里大约花了十分钟。</li><li><strong>成长收获+未来观点</strong>，1-2分钟，主要是能力的成长+对公司的价值。到这里加起来大概已经12-13分钟，再花2-3分钟讲讲对未来思考的点、创新点、机会点或者是机遇挑战。</li></ul><p>总结下，概述1页，几个挑战&amp;压力项目5-6页（如1页说怪兽，1页说怎么打，成长与收获一页，未来的思考1-2页），总计大约10页左右。工作是载体，能力是关键，思考要前瞻，刚才的思考视角融到这里来了。</p><h1 id="4-其他tips："><a href="#4-其他tips：" class="headerlink" title="4.其他tips："></a><strong>4.其他tips：</strong></h1><h2 id="1）应对提问"><a href="#1）应对提问" class="headerlink" title="1）应对提问"></a><strong>1）应对提问</strong></h2><p>明确回答问题的误区：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-28c15f7d6d96a7848d69887b7c60e629.png"></p><p>判断提问的动机：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-2761836822c1681c90d827159a259e9e.png"></p><p>回应问题：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-15b7ca372e7800816151b3149a7009e4.png"></p><ul><li>“问题-答案”PPT：对于回答问题部分，提前整理好问题清单（可能被问到的问题），针对性的做PPT。</li></ul><h2 id="2）梳理思路、制作PPT的方法"><a href="#2）梳理思路、制作PPT的方法" class="headerlink" title="2）梳理思路、制作PPT的方法"></a><strong>2）梳理思路、制作PPT的方法</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-ac4b9bedb176591569c04575c26e8f4e.png"></p><p>可使用用storyboarding帮助自己梳理材料框架：</p><ul><li>15-20分钟的presentation，贴30-40个便利贴就足够梳理清楚框架了。</li><li>简单写每一张便利贴上的内容。</li><li>每一部分便利贴的数量尽量均衡。</li><li>内容颗粒度不能过于细致（逐字稿），主要梳理内容骨架。</li></ul><h2 id="3）内容演练"><a href="#3）内容演练" class="headerlink" title="3）内容演练"></a><strong>3）内容演练</strong></h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1687426539-00c0da73a3f52f171a723ba7cd30804f.png"></p><ul><li>演练不能是对照着PPT默练</li><li>演练过程中及时调整内容</li><li>多多练习</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>晋升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晋升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业晋升模板(ks版)</title>
    <link href="/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E4%B8%93%E4%B8%9A%E6%99%8B%E5%8D%87%E6%A8%A1%E6%9D%BF-ks%E7%89%88/"/>
    <url>/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/%E4%B8%93%E4%B8%9A%E6%99%8B%E5%8D%87%E6%A8%A1%E6%9D%BF-ks%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="专业晋升述职模板-2023快手版"><a href="#专业晋升述职模板-2023快手版" class="headerlink" title="专业晋升述职模板(2023快手版)"></a>专业晋升述职模板(2023快手版)</h2><p><strong>呈现形式：</strong>围绕述职内容展开，呈现形式可根据通道整体要求自选，除整体介绍工作内容和成果以外，<strong>请重点介绍自身在成果中的实际贡献和思考、充分展现个人能力和价值</strong>。</p><p><strong>述职时间：</strong></p><ul><li>述职15-20分钟&#x2F;人、问答15-20分钟&#x2F;人；</li><li>高职级评审答辩时间延长，保证评委充分了解候选人：建议整体评审时间50-60分钟。</li><li>具体安排请遵循部门或通道通知。</li></ul><p><strong>述职内容：</strong>可从个人经历&#x2F;工作内容概述、主要工作成果及心得体会、专业影响力和贡献、专业领域专长和待提升项等4个方面展开</p><p><strong>1、个人经历&#x2F;工作内容概述（简要介绍）：</strong></p><p>介绍个人信息和工作简历，包括非快手的和快手的工作经历；</p><p>介绍本人目前的工作内容；</p><p><strong>2、主要工作成果及心得体会（重点阐述）：</strong></p><p>介绍进入快手后负责的主要项目及工作成果，重点谈你的实际贡献和心得体会；</p><p>谈一谈对所在业务&#x2F;专业领域的思考，比如自己所在专业&#x2F;业务领域的价值闭环、全局策略等；</p><p>具体谈你认为最成功或最能体现个人专业能力的项目或成果，明确你在其中的贡献和价值，比如：  </p><ul><li><strong>对部门&#x2F;公司有什么价值，如：业务突破、技术进步、管理提升等</strong></li><li><strong>过程中的挑战和难度在哪里，你如何克服的</strong></li><li><strong>过程中你做过哪些重要的决策或抉择</strong></li><li><strong>有哪些方法论&#x2F;工具的应用或突破</strong></li><li><strong>也可介绍一个你负责的比较遗憾或失败的项目及对失败原因的思考</strong></li></ul><p><strong>3、专业影响力和贡献：</strong></p><p>介绍个人在部门&#x2F;公司专业能力提升上的贡献，如经验知识的分享与传承、讲授课程、课程反馈效果、人员培养、流程&#x2F;方法&#x2F;工具的优化、专业课程的开发讲授、对通道的贡献、内部客户评价等。</p><p><strong>4、专业领域专长和待提升项：</strong></p><p>介绍个人在技术&#x2F;业务领域的最突出的几项专长，及过往如何在工作中应用和发挥。</p><p>在自身的职业发展中还有哪些待提升的能力项。</p><h2 id="2023年个人晋升汇报的模板"><a href="#2023年个人晋升汇报的模板" class="headerlink" title="2023年个人晋升汇报的模板"></a>2023年个人晋升汇报的模板</h2><p>原文链接：<a href="http://coder-xieshijie.cn/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/2023%E5%B9%B42%E6%9C%88-%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9-2b-3a/">2023年2月 晋升答辩(2b-3a)</a></p><ol><li><p>个人简介</p></li><li><ol><li>2021年12月加入快手，目前已经有一年半</li><li>独立负责：</li><li>新参与：</li></ol></li><li><p>主要工作成果</p></li><li><ol><li><p>平台一：</p></li><li><ol><li><p>现状一</p></li><li><p>打法思路</p></li><li><ol><li>具备的能力</li><li>建成之后的新流程</li></ol></li><li><p>现状二</p></li><li><p>打法思路</p></li><li><ol><li>具体建设过程&#x2F;步骤，建成的能力</li><li>建成之后的新流程</li></ol></li><li><p>现状三（技术难点）</p></li><li><p>打法思路</p></li><li><ol><li>把技术难度一步一步的体现出来</li></ol></li><li><p>项目整体收益成果</p></li></ol></li><li><p>平台二：</p></li><li><ol><li>背景现状</li><li>打法一二三</li><li>项目整体收益</li></ol></li></ol></li><li><p>思考规划</p></li><li><p>成长总结</p></li></ol><p>PS:如果我是评委，我希望在最后能够进行一下review，因为我中间可能会miss掉很多东西</p><ol><li><ol><li>把我介绍内容的最精髓的部分展示出来</li><li>把各个工作内容的关联性展示出来</li><li>用图展示，把关联关系用图展示</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>晋升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晋升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年2月 晋升答辩(2b-3a)</title>
    <link href="/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/2023%E5%B9%B42%E6%9C%88-%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9-2b-3a/"/>
    <url>/2023/06/22/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E6%99%8B%E5%8D%87/2023%E5%B9%B42%E6%9C%88-%E6%99%8B%E5%8D%87%E7%AD%94%E8%BE%A9-2b-3a/</url>
    
    <content type="html"><![CDATA[<p><strong>专业职级晋升评审</strong></p><blockquote><p><strong>答辩人：谢世杰</strong></p></blockquote><blockquote><p><strong>部门：研发管理办公室&#x2F;交付工具组</strong></p></blockquote><blockquote><p><strong>日期：2023-3</strong></p></blockquote><h1 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a><strong>个人简介</strong></h1><p><strong>2020年11月-2021年12月，校招实习生</strong> </p><p><strong>2021年12月-至今，正式职员</strong> </p><p><strong>独立负责：</strong>   </p><ul><li><strong>API管理平台，自动解析接口的接口管理平台</strong>   </li><li><strong>Sentry平台，开源的日志上报监控平台</strong>   </li><li><strong>UPM平台，为KDEV、测试服务化等做权限管理的平台</strong></li></ul><p><strong>新参与：代码扫描平台</strong>  </p><h1 id="主要工作及成果"><a href="#主要工作及成果" class="headerlink" title="主要工作及成果"></a><strong>主要工作及成果</strong></h1><h2 id="一、API管理平台"><a href="#一、API管理平台" class="headerlink" title="一、API管理平台"></a><strong>一、API管理平台</strong></h2><h3 id="现状一："><a href="#现状一：" class="headerlink" title="现状一："></a><strong>现状一：</strong></h3><p><strong>研发手工编写接口，存在接口编写的误差，导致前后端在联调阶段频繁重新定义接口，耗时耗力，严重时后端研发修改接口定义之后没有及时通知前端从而导致线上事故。快手内部缺少一个这样的平台，它至少具备</strong></p><ul><li><strong>用户低成本接入，能够自动生成接口文档。</strong></li><li><strong>能够及时让相关接口人感知接口变化</strong></li></ul><p><strong>我们调研了内部的接口平台：openapi、kapi、api-center，均没有自动生成接口的能力和接口变化的感知能力。</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out.png" alt="img"></p><h3 id="打法思路"><a href="#打法思路" class="headerlink" title="打法思路"></a><strong>打法思路</strong></h3><p><strong>（1）从0到1构建API管理平台，建成的API管理提供了以下的能力：</strong></p><p><strong>●  打通git和pipeline</strong> </p><p><strong>●</strong>  <strong>获取编译产物并自动解析接口</strong></p><p><strong>●</strong>  <strong>进行接口diff产出报告并Kim通知</strong> </p><p><strong>●  自动化构建mock和测试数据</strong> </p><p><strong>●</strong>  <strong>用户0成本接入</strong> </p><p><strong>（2）建成之后流程如下</strong></p><p>后端研发同学完成编码，push代码到gitlab并执行流水线，API管理的解析服务会收到通知并拉起编译产物进行接口元信息解析，解析完成并自动生成接口文档之后，一方面，会把信息同步到API管理界面提供MOCK、case用户、交互等基本能力。另一方面会跟之前版本的接口进行diff，如果存在diff会通过kim发送diff报告到制定的前端接口人，那前端研发同学就会修改制定的代码。</p><p><strong>建立起以自动解析接口文档为核心的接口管理平台</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602604.png" alt="img"></p><h3 id="现状二："><a href="#现状二：" class="headerlink" title="现状二："></a><strong>现状二：</strong></h3><p><strong>在从0到1建成API管理平台之后，目前还存在：</strong></p><p><strong>（1）后端研发同学定义部署RPC接口，前端研发同学定义并请求HTTP接口，导致前后端研发同学整体开发联通流程割裂。</strong></p><p><strong>（2）KDEV、KEEP、KFC三端联调没有统一的平台去规范定义和度量【联调】阶段。</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602644.png" alt="img"></p><h3 id="打法思路-1"><a href="#打法思路-1" class="headerlink" title="打法思路"></a><strong>打法思路</strong></h3><p><strong>（1）从1到多推广API管理平台，提供多端联通解决方案，具体建设如下：</strong></p><p><strong>●  第一步：将apicenter的rpc接口同步到api管理平台之上，让前端可以复用api管理的mock、测试、代理能力</strong></p><p><strong>●  第二步：将平台的接口与teamid建立关联，使三端研发流平台能够通过teamid关联自动解析的接口</strong></p><p><strong>●  第三步：建立接口状态变更触发team状态翻转的能力，使三端能够通过接口来标记联调阶段并度量联调时长</strong></p><p>最终结果：建立起以API管理为核心的联调体系</p><p><strong>（2）建成之后流程如下</strong></p><p>首先，将API-Center的RPC接口同步到API管理平台并将其改造为HTTP接口方便前段研发同学开发测试联调，然后建立teamId与API管理http接口的关联关系。至此将API管理、API-center平台与kdev、kfc、keep三端等平台打通。前后端研发同学隔离的联通流程得以打通，可以关联接口并改变接口状态从而翻转接口关联的team状态，复用API管理的基础能力。规范了联调流程并度量联通时长。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603083.png" alt="img"></p><h3 id="现状三："><a href="#现状三：" class="headerlink" title="现状三："></a><strong>现状三：</strong></h3><p><strong>KAT、流量录制等平台以及主站、用户增长等业务线依赖RPC解析的接口数据做打标度量和接口覆盖率统计等能力，但是RPC解析成功率低(29%)，无法为业务方提供准确全面的RPC接口。</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602610.png" alt="img"></p><h3 id="打法思路-2"><a href="#打法思路-2" class="headerlink" title="打法思路"></a><strong>打法思路</strong></h3><p><strong>重构API管理的RPC解析服务</strong></p><p><strong>第1步、分析当前rpc解析qdox框架，发现如下问题</strong></p><p><strong>● 已不再维护，部分解析方式会异常</strong> </p><p><strong>● 只解析java文件，若打包配置只有class则无法解析</strong> </p><p><strong>第2步、将qdox解析框架改为动态反射，复用spring的LuanchedURLclassloader，带来如下问题</strong></p><ul><li><strong>文件句柄泄露</strong></li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602537.png" alt="img"></p><ul><li><strong>频繁oom</strong></li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602646.png" alt="img"></p><p><strong>第3步、使用MAT分析dump文件</strong></p><p><strong>通过分析oom产生的dump文件发现JarFile引用被大量持有导致内存耗尽和文件句柄泄漏</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602847.png" alt="img"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602839.png" alt="img"></p><p><strong>第4步、查看源码分析jarFile引用被持有的原因</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602876.png" alt="img"></p><p>JarFile都被spring的classloader所引用，加载器会在spring的生命周期中一直存在，清理底层是实现了Object.finalize() 方法，finalize()方法并不会立刻清除，而是先加入F-Queue中，然后由一个低优先级的Finalizer线程去清理F-Queue队列，在高并发场景队列一直堆积最终造成内存耗尽。 </p><p><strong>第5步、重写classloader，功能如下</strong></p><p><strong>● 加载rpc的spring boot和spring mvc两种类型的jar</strong> </p><p><strong>● 快速清理过期jar</strong> </p><p><strong>● 自动准确索引runner依赖的sdk</strong> </p><p><strong>第6步、建立服务监控、日志、降级等体系</strong></p><p><strong>● sentry：监控平台</strong> </p><p><strong>● grafana：数据大盘</strong> </p><p><strong>● redis：流量控制、全局参数缓存、幂等性</strong> </p><p><strong>● kconf：全局开关、快速降级</strong> </p><p><strong>● 天问日志：日志平台，快速定位问题</strong> </p><p><strong>解析成功率从29%提升至99%</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103602904.png" alt="img"></p><h3 id="项目成果"><a href="#项目成果" class="headerlink" title="项目成果"></a><strong>项目成果</strong></h3><ol><li><strong>从0到1搭建API管理平台，并主R其开发、运维和升级</strong> </li><li><strong>平台与git和pipeline打通，用户0成本接入解析流程并自动生成接口文档</strong> </li><li><strong>自动解析接口1500w+，人工接口4w+，git仓库模块3700+，服务电商、商业化、主站、基础技术、支付、效率工程等多个部门</strong> </li><li><strong>rpc解析能力升级优化，解析成功率从29%提升到99%</strong> </li><li><strong>多端接口文档统一管理，规范联调流程，度量联调时长</strong> </li><li><strong>建设接口优先级和服务等级的一致性校验等能力，为主站、电商、商业化等业务方提供全量接口统计和度量</strong></li></ol><h2 id="二、Sentry平台"><a href="#二、Sentry平台" class="headerlink" title="二、Sentry平台"></a><strong>二、Sentry平台</strong></h2><h3 id="背景和现状"><a href="#背景和现状" class="headerlink" title="背景和现状"></a><strong>背景和现状</strong></h3><p><strong>Sentry是一个实时日志监控、记录和聚合平台。</strong> </p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603065.png" alt="img"></p><ul><li><strong>现状一：单点问题。 pgsql和rabbitMq都是单物理机部署，一旦实例挂掉，整体服务将不可用</strong></li><li><strong>现状二：前端上报不稳定。依赖sdk下载稳定性差，sourceMap上传不稳定</strong> </li><li><strong>现状三：通知手段单一。仅支持Kim通知，未与oncall报警平台打通</strong> </li><li><strong>现状四：海外环境不支持sentry。</strong></li></ul><h3 id="打法思路-3"><a href="#打法思路-3" class="headerlink" title="打法思路"></a><strong>打法思路</strong></h3><h4 id="打法一：通过增加冷备解决数据单点问题"><a href="#打法一：通过增加冷备解决数据单点问题" class="headerlink" title="打法一：通过增加冷备解决数据单点问题"></a><strong>打法一：通过增加冷备解决数据单点问题</strong></h4><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603057.png" alt="img"></p><p><strong>为pgsql和rabbitMQ搭建冷备，后台线程同步数据，并写了探活脚本，当发生故障时，切换数据库源，即可正常使用。</strong></p><h4 id="打法二：同步kcdn和迁移ceph，解决前端上报不稳定"><a href="#打法二：同步kcdn和迁移ceph，解决前端上报不稳定" class="headerlink" title="打法二：同步kcdn和迁移ceph，解决前端上报不稳定"></a><strong>打法二：同步kcdn和迁移ceph，解决前端上报不稳定</strong></h4><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603141.png" alt="img"></p><p><strong>前端上传组件从官网下载迁移到内部kcdn下载，并优化其下载逻辑，sourceMap上传的方式从ceph在线集群迁移为离线集群</strong>  </p><h4 id="打法三：与oncall报警平台打通，解决报警单一"><a href="#打法三：与oncall报警平台打通，解决报警单一" class="headerlink" title="打法三：与oncall报警平台打通，解决报警单一"></a><strong>打法三：与oncall报警平台打通，解决报警单一</strong></h4><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603339.png" alt="img"></p><p><strong>独立开发了一个sentry的插件并集成到sentry平台上，接受报警信息并给kafka发送消息，开发consumer去消费kafka消息，处理并聚合消息然后发送到oncall报警平台，完全兼容sentry的报警过滤参数和规则，用户只需勾选插件即可接口，成本低</strong> </p><h3 id="项目成果-1"><a href="#项目成果-1" class="headerlink" title="项目成果"></a><strong>项目成果</strong></h3><ol><li>接手公司级监控项目sentry平台，并<strong>独立负责</strong>其开发、运维和升级 </li><li>前端上报优化，组件下载优化，ceph数据迁移，稳定性提升至<strong>99.95%</strong> </li><li>交接sentry时，平台用户<strong>3100+<strong>， 项目数</strong>2000+<strong>，日均异常上报</strong>5000w+</strong> </li><li>迁移pgsql和rabbitMQ中间件并增加冷备，提升物理机的管控和维护能力，解决数据单点问题 </li><li>打通sentry与oncall报警平台，促进报警的整合；通过复用oncall平台的统计和回执能力，提升问题的接手率，提高问题定位效率。 </li><li>参与海外sentry的部署搭建，为海外业务方提供sentry报警能力</li></ol><h1 id="思考规划"><a href="#思考规划" class="headerlink" title="思考规划"></a><strong>思考规划</strong></h1><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603259.png" alt="img"></p><p>能力建设完成之后，我开始思考平台在为前后端提供接口文档定义以及联调<strong>还能做什么？</strong> </p><p><strong>思考如下：</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230622103603189.png" alt="img"></p><p><strong>黄色部分是新增功能</strong></p><p><strong>基础能力建设</strong></p><p>● <strong>代码生成服务并自动提交MR</strong>：通过接口元信息自动生成ts接口定义，解决前端工程师的痛点</p><p>● <strong>python等语言自动解析</strong>：支持更多语言的接口自动生成</p><p>● <strong>接口覆盖率</strong>：统计全公司的接口数据，查看各个业务线接口的覆盖率</p><p><strong>合作共建</strong></p><p>● <strong>健康度检查</strong>：与代码扫描深度合作，静态扫描+动态解析，支持更加细粒度的健康度检查</p><p>● <strong>staging发布</strong>：配合流水线，作为staging部署的一个入口，方便前后端测试验证</p><p>● <strong>提测卡点</strong>：对比接口diff，如果存在接口diff则无法进行体测的准入和准出</p><p>● <strong>自动测试</strong>：跟测试服务化和kat平台合作，复用已有的接口出入参定义，升级测试case，生产接口测试报告</p><h1 id="成长总结"><a href="#成长总结" class="headerlink" title="成长总结"></a><strong>成长总结</strong></h1><p><strong>知识宽度：</strong></p><p>加入快手以来，负责的项目让我见识到更多方向，拓宽了自己的知识面。在遇到问题时，能够使用不同的工具和方式方法相对独立的去解决问题。 </p><p><strong>业务沟通能力：</strong></p><p>独立负责oncall时期，积极的沟通协商去解决问题，能够更快速的理解和更明晰的沟通，减少沟通成本，提升工作效率 。</p><p><strong>owner意识：</strong></p><p>项目切换时能够快速进入状态，独立承担sentry和API管理相关工作。意识驱动行为，通过自驱的方式去承担项目职责并与各方业务线进行沟通。 </p><p><strong>工具&#x2F;方法论的突破：</strong></p><p>更熟悉使用ER图、UML类图、流程图等领域模型的设计。 有意识建立监控体系和日志体系去预防和发现问题。降级策略，重要服务要有一键降级的能力。代码更具“设计感” </p>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>晋升</category>
      
    </categories>
    
    
    <tags>
      
      <tag>晋升</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复杂查询sql整理</title>
    <link href="/2023/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2sql%E6%95%B4%E7%90%86/"/>
    <url>/2023/06/20/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2sql%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1、强制在join中使用索引"><a href="#1、强制在join中使用索引" class="headerlink" title="1、强制在join中使用索引"></a>1、强制在join中使用索引</h2><h2 id="2、concat函数"><a href="#2、concat函数" class="headerlink" title="2、concat函数"></a>2、concat函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> pi.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> package_info pi force index <span class="hljs-keyword">for</span> <span class="hljs-keyword">join</span>(idx_branch_id) <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> repo_branch_collection rbc <span class="hljs-keyword">on</span> pi.version_id <span class="hljs-operator">=</span> rbc.target_id <span class="hljs-keyword">and</span> rbc.target_type <span class="hljs-operator">=</span> ? <span class="hljs-keyword">and</span> rbc.deleted <span class="hljs-operator">=</span> ? <span class="hljs-keyword">and</span> rbc.collector <span class="hljs-operator">=</span> ? <br><span class="hljs-keyword">where</span> branch_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> branch <span class="hljs-keyword">where</span> repo_id <span class="hljs-operator">=</span> ?) <br><span class="hljs-keyword">and</span> creator <span class="hljs-operator">=</span> ? <br><span class="hljs-keyword">and</span> version_type <span class="hljs-operator">=</span> ? <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> concat(rbc.create_time <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,pi.create_time) <span class="hljs-keyword">desc</span> limit ?,?<br></code></pre></td></tr></table></figure><ul><li><p>查询中使用了 <code>FORCE INDEX FOR JOIN(idx_branch_id)</code>，这表示你正在强制MySQL使用<code>idx_branch_id</code>索引进行join操作。</p></li><li><p><code>concat()</code>函数是MySQL中用来连接两个或更多字符串的函数。在这里，它首先将<code>rbc.create_time is not null</code>的布尔结果（TRUE or FALSE）转换为字符串（’1’ 或 ‘0’），然后将它与<code>pi.create_time</code>的字符串表示形式连接起来。这种做法可能是试图在一定程度上保持<code>rbc.create_time</code>的存在性以及<code>pi.create_time</code>的顺序。</p></li></ul><p>注意：此种用法可能并不是最佳用法，首先，<code>concat()</code>会将所有参数都视为字符串进行连接。这意味着时间字段（<code>create_time</code>）会被视为字符串，而非日期类型，可能会导致排序行为出现问题。其次，<code>rbc.create_time is not null</code>的结果（0 或 1）会被置于<code>pi.create_time</code>之前，可能导致排序首先依据<code>rbc.create_time</code>是否存在，然后才是<code>pi.create_time</code>。</p><p>一般来说，如果你想要基于多个字段进行排序，并考虑到某些字段可能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <br>  <span class="hljs-keyword">CASE</span> <br>    <span class="hljs-keyword">WHEN</span> rbc.create_time <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">THEN</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">ELSE</span> rbc.create_time<br>  <span class="hljs-keyword">END</span>,<br>  pi.create_time <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure><p>这样的语句会首先考虑<code>rbc.create_time</code>是否为空，然后再根据<code>pi.create_time</code>进行排序。如果<code>rbc.create_time</code>为空，该行会被放在结果的后部分。</p><h2 id="3、在group-by中同时使用多个聚合函数"><a href="#3、在group-by中同时使用多个聚合函数" class="headerlink" title="3、在group by中同时使用多个聚合函数"></a>3、在group by中同时使用多个聚合函数</h2><p>– 查询所有两门及两门以上不及格的人的平均成绩 name、subject、score （having by）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name,<span class="hljs-built_in">sum</span>(score<span class="hljs-operator">&lt;</span><span class="hljs-number">60</span>) <span class="hljs-keyword">as</span> num, <span class="hljs-built_in">avg</span>(score)<br><span class="hljs-keyword">From</span> info<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> name<br><span class="hljs-keyword">HAVING</span> num <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="4、group-by-count-order-by-limit-统计前几最"><a href="#4、group-by-count-order-by-limit-统计前几最" class="headerlink" title="4、group by + count + order by + limit 统计前几最"></a>4、group by + count + order by + limit 统计前几最</h2><p>–  统计重名最多的十个城市名字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> git_url<br><span class="hljs-keyword">from</span> http_api_doc<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> git_url<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">count</span>(git_url) <span class="hljs-keyword">DESC</span><br>limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>——统计最近的5条记录，记录存在重复的情况(group by + order by + limit)</p><p>Ps:limit 是在 order by 之后</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> tool_id , <span class="hljs-built_in">max</span>(update_time) <span class="hljs-keyword">as</span> <span class="hljs-type">time</span><br><span class="hljs-keyword">from</span> ee_tool_hot<br><span class="hljs-keyword">where</span> tool_user <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xie&#x27;</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> tool_id<br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-type">time</span> <span class="hljs-keyword">desc</span><br>limit <span class="hljs-number">0</span>, <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>5、同样一张表，自身联表查询实现group by查全部信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> oi.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> openapi_info oi<br><span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> (<br>    <span class="hljs-keyword">SELECT</span> module_name, branch_name, <span class="hljs-built_in">MAX</span>(create_time) max_create_time<br>    <span class="hljs-keyword">FROM</span> openapi_info<br>    <span class="hljs-keyword">WHERE</span> koas_module_id <span class="hljs-operator">=</span> <span class="hljs-number">633</span><br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> module_name, branch_name<br>) grouped_oi <span class="hljs-keyword">ON</span> oi.module_name <span class="hljs-operator">=</span> grouped_oi.module_name <br>    <span class="hljs-keyword">AND</span> oi.branch_name <span class="hljs-operator">=</span> grouped_oi.branch_name <br>    <span class="hljs-keyword">AND</span> oi.create_time <span class="hljs-operator">=</span> grouped_oi.max_create_time<br><br><span class="hljs-comment">-- 查询group by之后，根据返回的列与自身进行连表查询，返回表的全部字段</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码重构技巧(from kstack)</title>
    <link href="/2023/06/12/CodeAesthetic/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7-from-kstack/"/>
    <url>/2023/06/12/CodeAesthetic/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E6%8A%80%E5%B7%A7-from-kstack/</url>
    
    <content type="html"><![CDATA[<h1 id="代码重构技巧"><a href="#代码重构技巧" class="headerlink" title="代码重构技巧"></a>代码重构技巧</h1><p>文章摘要：项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。</p><h1 id="关于重构"><a href="#关于重构" class="headerlink" title="关于重构"></a>关于重构</h1><h2 id="1-为什么要重构"><a href="#1-为什么要重构" class="headerlink" title="1.为什么要重构"></a>1.为什么要重构</h2><p>项目在不断演进过程中，代码不停地在堆砌。如果没有人为代码的质量负责，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，项目的维护成本已经高过重新开发一套新代码的成本，想要再去重构，已经没有人能做到了。<br>造成这样的原因往往有以下几点：</p><ul><li><p>编码之前缺乏有效的设计</p></li><li><p>成本上的考虑，在原功能堆砌式编程</p></li><li><p>缺乏有效代码质量监督机制</p></li></ul><p>对于此类问题，业界已有有很好的解决思路：通过持续不断的重构将代码中的“坏味道”清除掉。</p><h2 id="2-什么是重构"><a href="#2-什么是重构" class="headerlink" title="2.什么是重构"></a>2.什么是重构</h2><p>重构一书的作者Martin Fowler对重构的定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。<br>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。<br></code></pre></td></tr></table></figure><p>根据重构的规模可以大致分为大型重构和小型重构：<br><strong>大型重构</strong> ：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入bug的风险也会相对比较大。<br><strong>小型重构</strong>：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名和注释、消除超大类或函数、提取重复代码等等。小型重构更多的是使用统一的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入bug的风险相对来说也会比较小。</p><p>什么时候重构 :<br>新功能开发、修bug或者代码review中出现“代码坏味道”，我们就应该及时进行重构。持续在日常开发中进行小重构，能够降低重构和测试的成本。</p><h1 id="代码的坏味道"><a href="#代码的坏味道" class="headerlink" title="代码的坏味道"></a>代码的坏味道</h1><ul><li><p><strong>代码重复</strong>:实现逻辑相同、执行流程相同  </p></li><li><p><strong>方法过长</strong>:</p><ul><li><p>方法中的语句不在同一个抽象层级</p></li><li><p>逻辑难以理解，需要大量的注释</p></li><li><p>面向过程编程而非面向对象</p></li></ul></li><li><p><strong>过大的类</strong></p><ul><li>类做了太多的事情</li><li>包含过多的实例变量和方法</li></ul><ul><li>类的命名不足以描述所做的事情</li></ul></li><li><p><strong>逻辑分散</strong></p><ul><li>发散式变化：某个类经常因为不同的原因在不同的方向上发生变化</li><li>散弹式修改：发生某种变化时，需要在多个类中做修改</li></ul></li><li><p><strong>严重的情结依恋</strong>:某个类的方法过多的使用其他类的成员  </p></li><li><p><strong>数据泥团&#x2F;基本类型偏执</strong></p><ul><li><p>两个类、方法签名中包含相同的字段或参数</p></li><li><p>应该使用类但使用基本类型，比如表示数值与币种的Money类、起始值与结束值的Range类</p></li></ul></li><li><p><strong>不合理的继承体系</strong></p><ul><li><p>继承打破了封装性，子类依赖其父类中特定功能的实现细节</p><ul><li>子类必须跟着其父类的更新而演变，除非父类是专门为了扩展而设计，并且有很好的文档说明</li></ul></li></ul></li><li><p><strong>过多的条件判断</strong>  </p></li><li><p><strong>过长的参数列</strong>  </p></li><li><p><strong>临时变量过多</strong>  </p></li><li><p><strong>令人迷惑的暂时字段</strong>:某个实例变量仅为某种特定情况而设置,将实例变量与相应的方法提取到新的类中</p></li><li><p><strong>纯数据类</strong>:仅包含字段和访问（读写）这些字段的方法,此类被称为数据容器，应保持最小可变性  </p></li><li><p><strong>不恰当的命名</strong></p><ul><li><p>命名无法准确描述做的事情</p><ul><li>命名不符合约定俗称的惯例</li></ul></li></ul></li><li><p><strong>过多的注释或者过时的注释</strong></p><h2 id="1-坏代码的问题"><a href="#1-坏代码的问题" class="headerlink" title="1.坏代码的问题"></a>1.坏代码的问题</h2></li></ul><ul><li><p>难以复用：系统关联性过多，导致很难分离可重用部分</p></li><li><p>难于变化：一处变化导致其他很多部分的修改，不利于系统稳定</p></li><li><p>难于理解：命名杂乱，结构混乱，难于阅读和理解</p></li><li><p>难以测试：分支、依赖较多，难以覆盖全面</p><h2 id="2-什么是好代码"><a href="#2-什么是好代码" class="headerlink" title="2.什么是好代码"></a>2.什么是好代码</h2></li><li><p>代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁。这些词汇是从不同的维度去评价代码质量的。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。</p></li><li><p>要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。</p></li></ul><p><strong>PS</strong> : 其实这里，个人感觉，更多情况下，还是会有很强的个人主观意识，比如 空格，table 之争，但是，核心还是是否按照各自的软件设计和编码规范即可，细节可能会带有浓重的个人主观意识色彩，大局还是仍需要按照规范进行</p><h1 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h1><h2 id="1-SOLID原则"><a href="#1-SOLID原则" class="headerlink" title="1.SOLID原则"></a>1.SOLID原则</h2><p>  <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686548772-7f4e128060877635a18c09937b37f1d6.png" alt="file"></p><h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h2><ul><li><p>软件开发人员在软件开发过程中面临的一般问题的解决方案。</p></li><li><p>这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p></li><li><p>每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686548772-827700a9b966d053c03c39acc4b131c8.png" alt="file"></p></li></ul><h2 id="3-代码分层"><a href="#3-代码分层" class="headerlink" title="3.代码分层"></a>3.代码分层</h2><p>  <img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686548772-7370d65a15eb983a625d1fbed28c2851.png" alt="file"></p><p><strong>模块结构说明</strong></p><ul><li><p>server_main：配置层，负责整个项目的module管理，maven配置管理、资源管理等；</p></li><li><p>server_application：应用接入层，承接外部流量入口，例如：RPC接口实现、消息处理、定时任务等；不要在此包含业务逻辑；</p></li><li><p>server_biz：核心业务层，用例服务、领域实体、领域事件等</p></li><li><p>server_irepository：资源接口层，负责资源接口的暴露</p></li><li><p>server_repository：资源层，负责资源的proxy访问，统一外部资源访问，隔离变化。注意：这里强调的是弱业务性，强数据性；</p></li><li><p>server_common：公共层，vo、工具等</p></li></ul><p>代码开发要遵守各层的规范，并注意层级之间的依赖关系。</p><h2 id="4-命名规范"><a href="#4-命名规范" class="headerlink" title="4.命名规范"></a>4.命名规范</h2><p>  一个好的命名应该要满足以下两个条件：</p><ul><li><p>准确描述所做得事情</p></li><li><p>格式符合通用的惯例</p></li></ul><p>如果你觉得一个类或方法难以命名的时候，可能是其承载的功能太多了，需要进一步拆分。</p><h1 id="重构的技巧"><a href="#重构的技巧" class="headerlink" title="重构的技巧"></a>重构的技巧</h1><h2 id="1-提炼方法"><a href="#1-提炼方法" class="headerlink" title="1.提炼方法"></a>1.提炼方法</h2><p>多个方法代码重复、方法中代码过长或者方法中的语句不在一个抽象层级。</p><p>方法是代码复用的最小粒度，方法过长不利于复用，可读性低，提炼方法往往是重构工作的第一步。  </p><p><strong>意图导向编程</strong> ：把处理某件事的流程和具体做事的实现方式分开。</p><ul><li><p>把一个问题分解为一系列功能性步骤，并假定这些功能步骤已经实现</p></li><li><p>我们只需把把各个函数组织在一起即可解决这一问题</p></li><li><p>在组织好整个功能后，我们在分别实现各个方法函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">commit</span><span class="hljs-params">(String command)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    String[] tokens = tokenize(command);<br>    normalizeTokens(tokens);<br>    <span class="hljs-keyword">if</span> (isALargeTransaction(tokens)) &#123;<br>      result = processLargeTransaction(tokens);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result = processSmallTransaction(tokens);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-以函数对象取代函数"><a href="#2-以函数对象取代函数" class="headerlink" title="2.以函数对象取代函数"></a>2.以函数对象取代函数</h2><p>将函数放进一个单独对象中，如此一来局部变量就变成了对象内的字段。</p><p>然后你可以在同一个对象中将这个大型函数分解为多个小型函数。</p><h2 id="3-引入参数对象"><a href="#3-引入参数对象" class="headerlink" title="3.引入参数对象"></a>3.引入参数对象</h2><p>方法参数比较多时，将参数封装为参数对象</p><h2 id="4-移除对参数的绝对赋值"><a href="#4-移除对参数的绝对赋值" class="headerlink" title="4.移除对参数的绝对赋值"></a>4.移除对参数的绝对赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(<span class="hljs-type">int</span> inputVal, <span class="hljs-type">int</span> quantity, <span class="hljs-type">int</span> yearToDate)</span> &#123;<br>  <span class="hljs-keyword">if</span> (inputVal &gt; <span class="hljs-number">50</span>) inputVal -= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (quantity &gt; <span class="hljs-number">100</span>) inputVal -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (yearToDate &gt; <span class="hljs-number">10000</span>) inputVal -= <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> inputVal;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">discount</span><span class="hljs-params">(<span class="hljs-type">int</span> inputVal, <span class="hljs-type">int</span> quantity, <span class="hljs-type">int</span> yearToDate)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> inputVal;<br>  <span class="hljs-keyword">if</span> (inputVal &gt; <span class="hljs-number">50</span>) result -= <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">if</span> (quantity &gt; <span class="hljs-number">100</span>) result -= <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> (yearToDate &gt; <span class="hljs-number">10000</span>) result -= <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-将查询与修改分离"><a href="#5-将查询与修改分离" class="headerlink" title="5.将查询与修改分离"></a>5.将查询与修改分离</h2><p>任何有返回值的方法，都不应该有副作用</p><ul><li>不要在convert中调用写操作，避免副作用</li><li>常见的例外：将查询结果缓存到本地</li></ul><h2 id="6-移除不必要临时变量"><a href="#6-移除不必要临时变量" class="headerlink" title="6.移除不必要临时变量"></a>6.移除不必要临时变量</h2><pre><code class="hljs">临时变量仅使用一次或者取值逻辑成本很低的情况下</code></pre><h2 id="7-引入解释变量"><a href="#7-引入解释变量" class="headerlink" title="7.引入解释变量"></a>7.引入解释变量</h2><p>将复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">if</span> ((platform.toUpperCase().indexOf(<span class="hljs-string">&quot;MAC&quot;</span>) &gt; -<span class="hljs-number">1</span>)<br>  &amp;&amp; (browser.toUpperCase().indexOf(<span class="hljs-string">&quot;IE&quot;</span>) &gt; -<span class="hljs-number">1</span>) &amp;&amp; wasInitialized() &amp;&amp; resize &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br><br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isMacOs</span> <span class="hljs-operator">=</span> platform.toUpperCase().indexOf(<span class="hljs-string">&quot;MAC&quot;</span>) &gt; -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isIEBrowser</span> <span class="hljs-operator">=</span> browser.toUpperCase().indexOf(<span class="hljs-string">&quot;IE&quot;</span>) &gt; -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">wasResized</span> <span class="hljs-operator">=</span> resize &gt; <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (isMacOs &amp;&amp; isIEBrowser &amp;&amp; wasInitialized() &amp;&amp; wasResized) &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-使用卫语句替代嵌套条件判断"><a href="#8-使用卫语句替代嵌套条件判断" class="headerlink" title="8.使用卫语句替代嵌套条件判断"></a>8.使用卫语句替代嵌套条件判断</h2><p>把复杂的条件表达式拆分成多个条件表达式，减少嵌套。<br>嵌套了好几层的if - then-else语句，转换为多个if语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//未使用卫语句</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHello</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>  <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">return</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>              <span class="hljs-keyword">return</span>;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              setHello();<br>          &#125;<br>      &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//使用卫语句</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getHello</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>  <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br>  setHello();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-使用多态替代条件判断"><a href="#9-使用多态替代条件判断" class="headerlink" title="9.使用多态替代条件判断"></a>9.使用多态替代条件判断</h2><p>当出现大量类型检查和判断时，if else（或switch）语句的体积会比较臃肿，这无疑降低了代码的可读性。当存在这样一类条件表达式，它根据对象类型的不同选择不同的行为。可以将这种表达式的每个分支放进一个子类内的复写函数中，然后将原始函数声明为抽象函数。  </p><p>另外，if else（或switch）本身就是一个“变化点”，当需要扩展新的类型时，我们不得不追加if else（或switch）语句块，以及相应的逻辑，这无疑降低了程序的可扩展性，也违反了面向对象的开闭原则。</p><p>基于这种场景，我们可以考虑使用“多态”来代替冗长的条件判断，将if else（或switch）中的“变化点”封装到子类中。这样，就不需要使用if else（或switch）语句了，取而代之的是子类多态的实例，从而使得提高代码的可读性和可扩展性。很多设计模式使用都是这种套路，比如策略模式、状态模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 未使用多态</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, String operator)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;add&quot;</span>.equals(operator)) &#123;<br>        result = a + b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;multiply&quot;</span>.equals(operator)) &#123;<br>        result = a * b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;divide&quot;</span>.equals(operator)) &#123;<br>        result = a / b;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;subtract&quot;</span>.equals(operator)) &#123;<br>        result = a - b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 使用多态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Operation</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Addition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Operation</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>        &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;String, Operation&gt; operationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        operationMap.put(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>());<br>        operationMap.put(<span class="hljs-string">&quot;divide&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Division</span>());<br>        <span class="hljs-comment">// more operators</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">getOperation</span><span class="hljs-params">(String operator)</span> &#123;<br>        <span class="hljs-keyword">return</span> operationMap.get(operator);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, String operator)</span> &#123;<br>    <span class="hljs-keyword">if</span> (OperatorFactory .getOperation == <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid Operator&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> OperatorFactory .getOperation(operator).apply(a, b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-使用异常替代返回错误"><a href="#10-使用异常替代返回错误" class="headerlink" title="10.使用异常替代返回错误"></a>10.使用异常替代返回错误</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用错误码</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (balance &lt; amount) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        balance -= amount;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//使用异常</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>    <span class="hljs-keyword">if</span> (amount &gt; balance) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;amount too large&quot;</span>);<br>    &#125;<br>    balance -= amount;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-引入断言"><a href="#11-引入断言" class="headerlink" title="11.引入断言"></a>11.引入断言</h2><p>某一段代码需要对程序状态做出某种假设，以断言明确表现这种假设。</p><ul><li><p>不要滥用断言，不要使用它来检查“应该为真”的条件，只使用它来检查“一定必须为真”的条件</p></li><li><p>如果断言所指示的约束条件不能满足，代码是否仍能正常运行？如果可以就去掉断言</p></li></ul><h2 id="12-引入Null对象或特殊对象"><a href="#12-引入Null对象或特殊对象" class="headerlink" title="12.引入Null对象或特殊对象"></a>12.引入Null对象或特殊对象</h2><p>当使用一个方法返回的对象时，而这个对象可能为空，这个时候需要对这个对象进行操作前，需要进行判空，否则就会报空指针。当这种判断频繁的出现在各处代码之中，就会影响代码的美观程度和可读性，甚至增加Bug的几率。  </p><p>空引用的问题在Java中无法避免，但可以通过代码编程技巧（引入空对象）来改善这一问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//空对象的例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperatorFactory</span> &#123;<br>  <span class="hljs-keyword">static</span> Map&lt;String, Operation&gt; operationMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">static</span> &#123;<br>    operationMap.put(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Addition</span>());<br>    operationMap.put(<span class="hljs-string">&quot;divide&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Division</span>());<br>    <span class="hljs-comment">// more operators</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Optional&lt;Operation&gt; <span class="hljs-title function_">getOperation</span><span class="hljs-params">(String operator)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(operationMap.get(operator));<br>  &#125;<br>&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, String operator)</span> &#123;<br>  <span class="hljs-type">Operation</span> <span class="hljs-variable">targetOperation</span> <span class="hljs-operator">=</span> OperatorFactory.getOperation(operator)<br>     .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid Operator&quot;</span>));<br>  <span class="hljs-keyword">return</span> targetOperation.apply(a, b);<br>  &#125;<br><br>  <span class="hljs-comment">//特殊对象的例子</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InvalidOp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Operation</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Invalid Operator&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-提炼类"><a href="#13-提炼类" class="headerlink" title="13.提炼类"></a>13.提炼类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//原始类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String officeAreaCode;<br>  <span class="hljs-keyword">private</span> String officeNumber;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> name;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTelephoneNumber</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(&quot;</span> + officeAreaCode + <span class="hljs-string">&quot;)&quot;</span> + officeNumber);<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOfficeAreaCode</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> officeAreaCode;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOfficeAreaCode</span><span class="hljs-params">(String arg)</span> &#123;<br>      officeAreaCode = arg;<br>  &#125;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOfficeNumber</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> officeNumber;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOfficeNumber</span><span class="hljs-params">(String arg)</span> &#123;<br>      officeNumber = arg;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//新提炼的类（以对象替换数据值）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TelephoneNumber</span> &#123;<br>  <span class="hljs-keyword">private</span> String areaCode;<br>  <span class="hljs-keyword">private</span> String number;<br><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getTelephnoeNumber</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;(&quot;</span> + getAreaCode() + <span class="hljs-string">&quot;)&quot;</span> + number);<br>  &#125;<br>  String <span class="hljs-title function_">getAreaCode</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> areaCode;<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAreaCode</span><span class="hljs-params">(String arg)</span> &#123;<br>      areaCode = arg;<br>  &#125;<br>  String <span class="hljs-title function_">getNumber</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">return</span> number;<br>  &#125;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumber</span><span class="hljs-params">(String arg)</span> &#123;<br>      number = arg;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-优先考虑泛型"><a href="#14-优先考虑泛型" class="headerlink" title="14.优先考虑泛型"></a>14.优先考虑泛型</h2><p>声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）类或者接口。泛型类和接口统称为泛型（generic type）。泛型从Java 5引入，提供了编译时类型安全检测机制。泛型的本质是参数化类型，通过一个参数来表示所操作的数据类型，并且可以限制这个参数的类型范围。泛型的好处就是编译期类型检测，避免类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比较三个值并返回最大值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt; T <span class="hljs-title function_">maximum</span><span class="hljs-params">(T x, T y, T z)</span> &#123;<br>  <span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> x;<br>  <span class="hljs-comment">// 假设x是初始最大值</span><br>  <span class="hljs-keyword">if</span> ( y.compareTo( max ) &gt; <span class="hljs-number">0</span> ) &#123;<br>    max = y; <span class="hljs-comment">//y 更大</span><br>  &#125;   <span class="hljs-keyword">if</span> ( z.compareTo( max ) &gt; <span class="hljs-number">0</span> ) &#123;<br>    max = z; <span class="hljs-comment">// 现在 z 更大</span><br>  &#125;   <span class="hljs-keyword">return</span> max; <span class="hljs-comment">// 返回最大对象</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">( String args[] )</span> &#123;<br>  System.out.printf( <span class="hljs-string">&quot;%d, %d 和 %d 中最大的数为 %d\n\n&quot;</span>,  <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, maximum( <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ));<br>  System.out.printf( <span class="hljs-string">&quot;%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n&quot;</span>,  <span class="hljs-number">6.6</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">7.7</span>,  maximum( <span class="hljs-number">6.6</span>, <span class="hljs-number">8.8</span>, <span class="hljs-number">7.7</span> ));<br>  System.out.printf( <span class="hljs-string">&quot;%s, %s 和 %s 中最大的数为 %s\n&quot;</span>,<span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, maximum( <span class="hljs-string">&quot;pear&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span> ) );<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="质量如何保证"><a href="#质量如何保证" class="headerlink" title="质量如何保证"></a>质量如何保证</h1><p>那么，对于老的代码或者新的代码，重构后，质量如何保证呢？</p><h2 id="1-测试驱动开发"><a href="#1-测试驱动开发" class="headerlink" title="1.测试驱动开发"></a>1.测试驱动开发</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plain">测试驱动开发（TDD）要求以测试作为开发过程的中心，要求在编写任何代码之前，<br>首先编写用于产码行为的测试，而编写的代码又要以使测试通过为目标。<br>TDD要求测试可以完全自动化地运行，并在对代码重构前后必须运行测试。<br></code></pre></td></tr></table></figure><p>TDD的最终目标是整洁可用的代码（clean code that works）。大多数的开发者大部分时间无法得到整洁可用的代码。办法是分而治之。首先解决目标中的“可用”问题，然后再解决“代码的整洁”问题。这与体系结构驱动（architecture-driven）的开发相反。</p><p>采用TDD另一个好处就是让我们拥有一套伴随代码产生的详尽的自动化测试集。将来无论出于任何原因（需求、重构、性能改进）需要对代码进行维护时，在这套测试集的驱动下工作，我们代码将会一直是健壮的。</p><h2 id="2-TDD的开发周期"><a href="#2-TDD的开发周期" class="headerlink" title="2.TDD的开发周期"></a>2.TDD的开发周期</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686548772-4f07230ea98c4d7113eb1ba444191518.png" alt="file"><br>添加一个测试 -&gt; 运行所有测试并检查测试结果 -&gt; 编写代码以通过测试 -&gt; 运行所有测试且全部通过 -&gt; 重构代码，以消除重复设计，优化设计结构</p><h2 id="3-两个基本原则"><a href="#3-两个基本原则" class="headerlink" title="3.两个基本原则"></a>3.两个基本原则</h2><ul><li>仅在测试失败时才编写代码并且只编写刚好使测试通过的代码</li><li>编写下一个测试之前消除现有的重复设计，优化设计结构<br>关注点分离是这两条规则隐含的另一个非常重要的原则。其表达的含义指在编码阶段先达到代码“可用”的目标，在重构阶段再追求“整洁”目标，每次只关注一件事！</li></ul><h2 id="4-分层测试"><a href="#4-分层测试" class="headerlink" title="4.分层测试"></a>4.分层测试</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686548772-55c86cf61f26d86d8e0c990b2c4e8a52.png" alt="file"></p>]]></content>
    
    
    <categories>
      
      <category>CodeAesthetic</category>
      
      <category>代码重构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeAesthetic</tag>
      
      <tag>代码重构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消灭if-else (模板+策略+工厂)</title>
    <link href="/2023/06/12/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B6%88%E7%81%ADif-else-%E6%A8%A1%E6%9D%BF-%E7%AD%96%E7%95%A5-%E5%B7%A5%E5%8E%82/"/>
    <url>/2023/06/12/CodeAesthetic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B6%88%E7%81%ADif-else-%E6%A8%A1%E6%9D%BF-%E7%AD%96%E7%95%A5-%E5%B7%A5%E5%8E%82/</url>
    
    <content type="html"><![CDATA[<h2 id="涉及知识点："><a href="#涉及知识点：" class="headerlink" title="涉及知识点："></a>涉及知识点：</h2><ol><li><p>枚举+枚举配置抽象类</p></li><li><p>函数式接口</p></li><li><p>设计模式</p><ul><li><p>策略模式</p></li><li><p>模板方法</p></li><li><p>工厂模式</p></li><li><p>单例模式</p></li></ul></li></ol><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><ul><li>策略模式，定义抽象接口，不同的实现类实现不同的策略</li><li>模板方法，定义一个模板方法，把公共流程写在模板方法中，然后不同的子类按需实现模板方法流程中的方法</li><li>单例和工厂是按需</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 策略业务接口 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AwardStrategy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 奖励发放接口</span><br><span class="hljs-comment">     */</span><br>    Map&lt;String, Boolean&gt; <span class="hljs-title function_">awardStrategy</span><span class="hljs-params">(String userId)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取策略标识,即不同渠道的来源标识</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-title function_">getSource</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义奖励发放模板流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 定义奖励发放模板流程 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseAwardTemplate</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BaseAwardTemplate.class);<br><br>    <span class="hljs-comment">//奖励发放模板方法</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">awardTemplate</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.authentication(userId);<br>        <span class="hljs-built_in">this</span>.risk(userId);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.awardRecord(userId);<br>    &#125;<br><br>    <span class="hljs-comment">//身份验证</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">authentication</span><span class="hljs-params">(String userId)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 执行身份验证!&quot;</span>, userId);<br>    &#125;<br><br>    <span class="hljs-comment">//风控</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">risk</span><span class="hljs-params">(String userId)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 执行风控校验!&quot;</span>, userId);<br>    &#125;<br><br>    <span class="hljs-comment">//执行奖励发放</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Boolean <span class="hljs-title function_">awardRecord</span><span class="hljs-params">(String userId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现不同渠道的奖励业务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ToutiaoAwardStrategyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseAwardTemplate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AwardStrategy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 奖励发放接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">awardStrategy</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.awardTemplate(userId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;toutiao&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 具体的业务奖励发放实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Boolean <span class="hljs-title function_">awardRecord</span><span class="hljs-params">(String userId)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;头条渠道用户&#123;&#125;奖励50元红包!&quot;</span>, userId);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeChatAwardStrategyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseAwardTemplate</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AwardStrategy</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 奖励发放接口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">awardStrategy</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.awardTemplate(userId);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSource</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wx&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 具体的业务奖励发放实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Boolean <span class="hljs-title function_">awardRecord</span><span class="hljs-params">(String userId)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;微信渠道用户&#123;&#125;奖励100元红包!&quot;</span>, userId);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>定义工厂方法，对外统一暴露业务调用入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AwardStrategyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;String, AwardStrategy&gt; MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        Map&lt;String, AwardStrategy&gt; beanTypeMap = applicationContext.getBeansOfType(AwardStrategy.class);<br>        beanTypeMap.values().forEach(strategyObj -&gt; MAP.put(strategyObj.getSource(), strategyObj));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对外统一暴露的工厂方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">getAwardResult</span><span class="hljs-params">(String userId, String source)</span> &#123;<br>        <span class="hljs-type">AwardStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> MAP.get(source);<br>        <span class="hljs-keyword">if</span> (Objects.isNull(strategy)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;渠道异常!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> strategy.awardStrategy(userId);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 静态内部类创建单例工厂对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateFactorySingleton</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AwardStrategyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwardStrategyFactory</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AwardStrategyFactory <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> CreateFactorySingleton.factory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>业务入口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/activity&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivityController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/reward3&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reward3</span><span class="hljs-params">(String userId, String source)</span> &#123;<br>        AwardStrategyFactory.getInstance().getAwardResult(userId, source);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板模式和策略模式的区别"><a href="#模板模式和策略模式的区别" class="headerlink" title="模板模式和策略模式的区别"></a>模板模式和策略模式的区别</h2><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationAdd</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>      <span class="hljs-keyword">return</span> num1 + num2;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationSubtract</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>      <span class="hljs-keyword">return</span> num1 - num2;<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>   <span class="hljs-keyword">private</span> Strategy strategy;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Context</span><span class="hljs-params">(Strategy strategy)</span>&#123;<br>      <span class="hljs-built_in">this</span>.strategy = strategy;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">executeStrategy</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span>&#123;<br>      <span class="hljs-keyword">return</span> strategy.doOperation(num1, num2);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Game</span> &#123;<br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span>;<br>   <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">endPlay</span><span class="hljs-params">()</span>;<br><br>   <span class="hljs-comment">//template method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br><br>      <span class="hljs-comment">//initialize the game</span><br>      initialize();<br><br>      <span class="hljs-comment">//start game</span><br>      startPlay();<br><br>      <span class="hljs-comment">//end game</span><br>      endPlay();<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cricket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Game</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">endPlay</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Cricket Game Finished!&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Cricket Game Initialized! Start playing.&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Cricket Game Started. Enjoy the game!&quot;</span>);<br>   &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Football</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Game</span> &#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">endPlay</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Football Game Finished!&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Football Game Initialized! Start playing.&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">startPlay</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;Football Game Started. Enjoy the game!&quot;</span>);<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>从上面代码可以看出：</p><ul><li>策略模式通过has-a的组合方式去实现，在代码运行的时候根据传入参数来动态的确定策略</li><li>模板模式通过is-a的继承方式去实现，每一个子类都代表一种不同的模板实现</li></ul><p>所以策略和模板经常跟工厂一同出现：模板的抽象和子类决定实现流程，策略在运行的时候动态决定哪一个子目标，工厂用来生产</p><p>引自：<a href="https://mp.weixin.qq.com/s/qTmw1pHvzcMJPB6fbBHaZg">https://mp.weixin.qq.com/s/qTmw1pHvzcMJPB6fbBHaZg</a></p>]]></content>
    
    
    <categories>
      
      <category>CodeAesthetic</category>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CodeAesthetic</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAC应用、工具网站、插件大合集</title>
    <link href="/2023/06/07/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/MAC%E5%BA%94%E7%94%A8%E3%80%81%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E3%80%81%E6%8F%92%E4%BB%B6%E5%A4%A7%E5%90%88%E9%9B%86/"/>
    <url>/2023/06/07/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%B7%A5%E5%85%B7/MAC%E5%BA%94%E7%94%A8%E3%80%81%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E3%80%81%E6%8F%92%E4%BB%B6%E5%A4%A7%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>Homebrew</p></li><li><p>hapigo快速启动器 <a href="https://www.hapigo.com/">https://www.hapigo.com/</a></p></li><li><p>Scroll Reverser 鼠标和触摸板方向翻转</p></li><li><p>clashX 科学上网</p></li><li><p>iclip 粘贴板(hapigo也有，建议用hapigo)</p></li><li><p>sublime text 文本编辑器</p></li><li><p>typora markdown文本记录</p></li><li><p>raycast 工具站(功能更全的启动器，但是需要安装很多插件并且配置快捷键，做不到开箱即用)</p><ol><li><a href="https://www.raycast.com/">https://www.raycast.com/</a></li></ol></li><li><p>tile window(桌面平铺)</p><ol><li>yabai <a href="https://github.com/koekeishiya/yabai/wiki">https://github.com/koekeishiya/yabai/wiki</a> </li><li>Amethyst <a href="https://github.com/ianyh/Amethyst">https://github.com/ianyh/Amethyst</a></li></ol></li><li></li></ol><h2 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h2><ol><li><p><a href="https://chat.openai.com/">https://chat.openai.com/</a> chatpgt</p></li><li><p><a href="https://tool.lu/ip/">https://tool.lu/ip/</a> ip地址</p></li><li><p><a href="https://www.json.cn/">https://www.json.cn/</a> json序列化</p></li><li><p><a href="https://www.diffchecker.com/">https://www.diffchecker.com/</a> 文本diff</p></li><li><p><a href="https://clashios.com/">https://clashios.com/</a> clash 机场相关网站</p></li><li><p>电影&#x2F;电视剧 ： </p></li><li><ol><li><p>ACG盒子 <a href="https://www.miaoaaa.com/yingyinzhuanqu">https://www.miaoaaa.com/yingyinzhuanqu</a></p></li><li><ol><li><a href="https://www.acgbox.link/">https://www.acgbox.link/</a></li><li><a href="https://www.bttwo.net/">https://www.bttwo.net/</a></li><li><a href="https://gaze.run/">https://gaze.run/</a></li><li><a href="https://www.subaibaiys.com/">https://www.subaibaiys.com/</a></li></ol></li><li><p>厂长影视资源 <a href="https://czzyhd.com/">https://czzyhd.com</a></p></li></ol></li><li><p>电子书下载：zlibrary <a href="https://zlibrary-asia.se/">https://zlibrary-asia.se/</a></p></li></ol><h2 id="idea插件"><a href="#idea插件" class="headerlink" title="idea插件"></a>idea插件</h2><ol><li><strong>需要把idea的插件同步的远端git上</strong></li><li>arthas idea</li><li>CheckStyle</li><li>Free Mybatis Tool</li><li>GenerateAllSetter</li><li>GitToolBox</li><li>GrepConsolo</li><li>LeetCode Editor</li><li>MavenDependencyHelper</li><li>MavenHelper</li><li>MybatisX</li><li>One Dark Theme</li><li>Restful Box</li><li>RestfulTool</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他技能</tag>
      
      <tag>MAC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用sql命令整理</title>
    <link href="/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%B8%B8%E7%94%A8sql%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/"/>
    <url>/2023/06/07/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%B8%B8%E7%94%A8sql%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="1、通过mysql命令远程连接服务器数据库"><a href="#1、通过mysql命令远程连接服务器数据库" class="headerlink" title="1、通过mysql命令远程连接服务器数据库"></a>1、通过mysql命令远程连接服务器数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h cluster01.proxysql.staging.internal <span class="hljs-operator">-</span>P <span class="hljs-number">6032</span> <span class="hljs-operator">-</span>ugifshow_15753_v1_rw <span class="hljs-operator">-</span>pKv1UFr9HXwMEcG08pReS2YKgJD5WBZLi<br></code></pre></td></tr></table></figure><p><code>-u</code>用户名，直接写不跟空格</p><p><code>-p</code>密码，，直接写不跟空格</p><p><code>-P</code>端口号</p><h2 id="2、dump文件"><a href="#2、dump文件" class="headerlink" title="2、dump文件"></a>2、dump文件</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>h <span class="hljs-operator">&lt;</span>远程主机名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">-</span>P <span class="hljs-operator">&lt;</span>端口号<span class="hljs-operator">&gt;</span> <span class="hljs-operator">-</span>u <span class="hljs-operator">&lt;</span>用户名<span class="hljs-operator">&gt;</span> <span class="hljs-operator">-</span>p <span class="hljs-operator">&lt;</span>数据库名称<span class="hljs-operator">&gt;</span> permission_user <span class="hljs-operator">&gt;</span> <span class="hljs-operator">/</span>tmp<span class="hljs-operator">/</span>permission_user.sql<br></code></pre></td></tr></table></figure><ul><li><code>-h</code>或<code>--host</code>：指定MySQL服务器的主机名。</li><li><code>-P</code>或<code>--port</code>：指定MySQL服务器的端口号。</li><li><code>-u</code>或<code>--user</code>：指定连接MySQL服务器的用户名。</li><li><code>-p</code>或<code>--password</code>：提示用户输入连接MySQL服务器的密码。请注意，在使用该参数时不要在其后加空格。</li><li><code>--single-transaction</code>：在导出数据时使用单个事务，以确保一致性。</li><li><code>-d</code>或<code>--no-data</code>：只导出表的结构，而不包括数据。</li><li><code>-t</code>或<code>--no-create-info</code>：只导出数据，而不包括表的结构。</li><li><code>--where</code>：根据指定的条件导出满足条件的数据。</li><li><code>--skip-comments</code>：跳过生成导出文件中的注释。</li><li><code>--skip-triggers</code>：跳过导出表的触发器。</li><li><code>--skip-lock-tables</code>：在导出数据时不锁定表，允许其他会话访问表。</li><li><code>--result-file=&lt;文件路径&gt;</code>：将导出结果保存到指定的文件中。</li><li><code>--routines</code>：导出存储过程和函数。</li><li><code>--events</code>：导出事件（Event）。</li><li><code>--triggers</code>：导出触发器。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>h cluster05.proxysql.internal <span class="hljs-operator">-</span>P <span class="hljs-number">6032</span> <span class="hljs-operator">-</span>ugifshow_4816_v1_rw <span class="hljs-operator">-</span>pKv11gv7MIWwEJn3sPjirao60qhutYSD4 <span class="hljs-comment">--skip-lock-tables --databases gifshow --tables permission_product_role_team_config permission_role_team_relation -t &gt; /tmp/roles1.sql</span><br><br>mysqldump <span class="hljs-operator">-</span>h cluster05.proxysql.internal <span class="hljs-operator">-</span>P <span class="hljs-number">6032</span> <span class="hljs-operator">-</span>ugifshow_4816_v1_rw <span class="hljs-operator">-</span>pKv11gv7MIWwEJn3sPjirao60qhutYSD4 <span class="hljs-comment">--skip-lock-tables --databases gifshow --tables permission_role --where=&quot;permission_role.id in (select role_id from permission_role_team_relation)&quot; -t &gt; /tmp/roles2.sql</span><br></code></pre></td></tr></table></figure><h2 id="3、把dump文件导入到指定数据库"><a href="#3、把dump文件导入到指定数据库" class="headerlink" title="3、把dump文件导入到指定数据库"></a>3、把dump文件导入到指定数据库</h2><ol><li>通过mysql链接远程数据库</li><li>use &lt;dabatase&gt;; 进入指定数据库</li><li>source &#x2F;tmp&#x2F;local.sql 把本地的sql文件在当前数据库执行</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Java加入生成器(Generator)特性</title>
    <link href="/2023/06/07/java/java%E5%9F%BA%E7%A1%80/%E4%B8%BAJava%E5%8A%A0%E5%85%A5%E7%94%9F%E6%88%90%E5%99%A8-Generator-%E7%89%B9%E6%80%A7/"/>
    <url>/2023/06/07/java/java%E5%9F%BA%E7%A1%80/%E4%B8%BAJava%E5%8A%A0%E5%85%A5%E7%94%9F%E6%88%90%E5%99%A8-Generator-%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一种全新的设计模式，数学美感与工程实用价值兼备，且不限编程语言。本文将以Java为样例，从无到有实现出完整的流式API，引入生成器特性，并介绍诸多应用场景。</p><p>这篇文章不是工具推荐，也不是应用案例分享。其主题思想，是介绍<strong>一种全新的设计模式</strong>。它既拥有抽象的数学美感，仅仅从一个简单接口出发，就能推演出庞大的特性集合，引出许多全新概念。同时也有扎实的工程实用价值，由其实现的工具，性能均可显著超过同类的头部开源产品。</p><p>这一设计模式并非因Java而生，而是诞生于一个十分简陋的脚本语言。它对语言特性的要求非常之低，因而其价值对众多现代编程语言都是普适的。</p><h3 id="关于Stream"><a href="#关于Stream" class="headerlink" title="关于Stream"></a>关于Stream</h3><p>首先大概回顾下Java里传统的流式API。自Java8引入lambda表达式和Stream以来，Java的开发便捷性有了质的飞跃，Stream在复杂业务逻辑的处理上让人效率倍增，是每一位Java开发者都应该掌握的基础技能。但排除掉parallelStream也即并发流之外，它其实并不是一个好的设计。</p><p>第一，封装过重，实现过于复杂，源码极其难读。我能理解这或许是为了兼容并发流所做的妥协，但毕竟耦合太深，显得艰深晦涩。每一位初学者被源码吓到之后，想必都会产生流是一种十分高级且实现复杂的特性的印象。实际上并不是这样，<strong>流其实可以用非常简单的方式构建</strong>。</p><p>第二、API过于冗长。冗长体现在stream.collect这一部分，作为对比，Kotlin提供的toList&#x2F;toSet&#x2F;associate(toMap)等等丰富操作是可以直接作用在流上的。Java直到16才抠抠索索加进来一个Stream可以直接调用的toList，他们甚至不肯把toSet&#x2F;toMap一起加上。</p><p>第三、API功能简陋。对于链式操作，在最初的Java8里只有map&#x2F;filter&#x2F;skip&#x2F;limit&#x2F;peek&#x2F;distinct&#x2F;sorted这七个，Java9又加上了takeWhile&#x2F;dropWhile。然而在Kotlin中，除了这几个之外人还有许多额外的实用功能，</p><p>例如：</p><p>mapIndexed, mapNotNull, filterIndexed, filterNotNull, onEachIndexed, distinctBy, sortedBy, sortedWith, zip, zipWithNext等等，翻倍了不止。这些东西实现起来并不复杂，就是个顺手的事，但对于用户而言有和没有的体验差异可谓巨大。</p><p>在这篇文章里，我将提出一种全新的机制用于构建流。这个机制极其简单，任何能看懂lambda表达式(闭包)的同学都能亲手实现，<strong>任何支持闭包的编程语言都能利用该机制实现自己的流</strong>。也正是由于这个机制足够简单，所以开发者可以以相当低的成本撸出大量的实用API，使用体验甩开Stream两条街不是问题。</p><h3 id="关于生成器"><a href="#关于生成器" class="headerlink" title="关于生成器"></a>关于生成器</h3><p>生成器(Generator)[1]是许多现代编程语言里一个广受好评的重要特性，在Python&#x2F;Kotlin&#x2F;C#&#x2F;Javascript等等语言中均有直接支持。它的核心API就是一个yield关键字(或者方法)。有了生成器之后，无论是iterable&#x2F;iterator，还是一段乱七八糟的闭包，都可以直接映射为一个流。举个例子，假设你想实现一个下划线字符串转驼峰的方法，在Python里你可以利用生成器这么玩</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">underscore_to_camelcase</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">camelcase</span>():<br>        <span class="hljs-keyword">yield</span> <span class="hljs-built_in">str</span>.lower<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">yield</span> <span class="hljs-built_in">str</span>.capitalize<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(f(sub) <span class="hljs-keyword">for</span> sub, f <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(s.split(<span class="hljs-string">&#x27;_&#x27;</span>), camelcase()))<br></code></pre></td></tr></table></figure><p>这短短几行代码可以说处处体现出了Python生成器的巧妙。首先，camelcase方法里出现了yield关键字，解释器就会将其看作是一个生成器，这个生成器会首先提供一个lower函数，然后提供无数的capitalize函数。由于生成器的执行始终是lazy的，所以用while true的方式生成无限流是十分常见的手段，不会有性能或者内存上的浪费。其次，Python里的流是可以和list一起进行zip的，有限的list和无限的流zip到一起，list结束了流自然也会结束。这段代码中，末尾那行join()括号里的东西，Python称之为生成器推导(Generator Comprehension)[2]，其本质上依然是一个流，一个zip流被map之后的string流，最终通过join方法聚合为一个string。</p><p>以上代码里的操作， 在任何支持生成器的语言里都可以轻易完成，但是在Java里你恐怕连想都不敢想。Java有史以来，无论是历久弥新的Java8，还是最新的引入了Project Loom[3]的OpenJDK19，连协程都有了，依然没有直接支持生成器。</p><p>本质上，生成器的实现要依赖于continuation[4]的挂起和恢复，所谓continuation可以直观理解为程序执行到指定位置后的断点，协程就是指在这个函数的断点挂起后跳到另一个函数的某个断点继续执行，而不会阻塞线程，生成器亦如是。Python通过栈帧的保存与恢复实现函数重入以及生成器[5]，Kotlin在编译阶段利用CPS(Continuation Passing Style)[6]技术对字节码进行了变换，从而在JVM上模拟了协程[7]。其他的语言要么大体如此，要么有更直接的支持。</p><p>那么，有没有一种办法，可以在没有协程的Java里，实现或者至少模拟出一个yield关键字，从而动态且高性能地创建流呢。答案是，有。</p><h2 id="流式API"><a href="#流式API" class="headerlink" title="流式API"></a>流式API</h2><p>Java里的流叫Stream，Kotlin里的流叫Sequence。我实在想不出更好的名字了，想叫Flow又被用了，简单起见姑且叫Seq。</p><h3 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h3><p>首先给出Seq的接口定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Seq</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">consume</span><span class="hljs-params">(Consumer&lt;T&gt; consumer)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>它本质上就是一个consumer of consumer，其真实含义我后边会讲。这个接口看似抽象，实则非常常见，java.lang.Iterable天然自带了这个接口，那就是大家耳熟能详的forEach。利用方法推导，我们可以写出第一个Seq的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Seq&lt;Integer&gt; seq = list::forEach;<br></code></pre></td></tr></table></figure><p>可以看到，在这个例子里<strong>consume和forEach是完全等价的</strong>，事实上这个接口我最早就是用forEach命名的，几轮迭代之后才改成含义更准确的consume。</p><p>利用单方法接口在Java里会自动识别为FunctionalInteraface这一伟大特性，我们也可以用一个简单的lambda表达式来构造流，比如只有一个元素的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; Seq&lt;T&gt; <span class="hljs-title function_">unit</span><span class="hljs-params">(T t)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; c.accept(t);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法在数学上很重要（实操上其实用的不多），它定义了Seq这个泛型类型的单位元操作，即T -&gt; Seq&lt;T&gt;的映射。</p><h3 id="map与flatMap"><a href="#map与flatMap" class="headerlink" title="map与flatMap"></a>map与flatMap</h3><p><strong>map</strong></p><p>从forEach的直观角度出发，我们很容易写出map[8]，将类型为T的流，转换为类型为E的流，也即根据函数T -&gt; E得到Seq&lt;T&gt; -&gt; Seq&lt;E&gt;的映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;E&gt; Seq&lt;E&gt; <span class="hljs-title function_">map</span><span class="hljs-params">(Function&lt;T, E&gt; function)</span> &#123;<br>  <span class="hljs-keyword">return</span> c -&gt; consume(t -&gt; c.accept(function.apply(t)));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>flatMap</strong></p><p>同理，可以继续写出flatMap，即将每个元素展开为一个流之后再合并。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;E&gt; Seq&lt;E&gt; <span class="hljs-title function_">flatMap</span><span class="hljs-params">(Function&lt;T, Seq&lt;E&gt;&gt; function)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; consume(t -&gt; function.apply(t).consume(c));<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以自己在IDEA里写写这两个方法，结合智能提示，写起来其实非常方便。如果你觉得理解起来不太直观，就把Seq看作是List，把consume看作是forEach就好。</p><h3 id="filter与take-drop"><a href="#filter与take-drop" class="headerlink" title="filter与take&#x2F;drop"></a>filter与take&#x2F;drop</h3><p>map与flatMap提供了流的映射与组合能力，流还有几个核心能力：元素过滤与中断控制。</p><p><strong>filter</strong></p><p>过滤元素，实现起来也很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Seq&lt;T&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(Predicate&lt;T&gt; predicate)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; consume(t -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (predicate.test(t)) &#123;<br>            c.accept(t);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>take</strong></p><p>流的中断控制有很多场景，take是最常见的场景之一，即获取前n个元素，后面的不要——等价于Stream.limit。</p><p>由于Seq并不依赖iterator，所以必须通过异常实现中断。为此需要构建一个全局单例的专用异常，同时取消这个异常对调用栈的捕获，以减少性能开销（由于是全局单例，不取消也没关系）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StopException</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StopException</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Throwable <span class="hljs-title function_">fillInStackTrace</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以及相应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> StopException.INSTANCE;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumeTillStop</span><span class="hljs-params">(C consumer)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        consume(consumer);<br>    &#125; <span class="hljs-keyword">catch</span> (StopException ignore) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以实现take了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Seq&lt;T&gt; <span class="hljs-title function_">take</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; &#123;<br>        <span class="hljs-type">int</span>[] i = &#123;n&#125;;<br>        consumeTillStop(t -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (i[<span class="hljs-number">0</span>]-- &gt; <span class="hljs-number">0</span>) &#123;<br>                c.accept(t);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stop();<br>            &#125;<br>        &#125;);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>drop</strong></p><p>drop是与take对应的概念，丢弃前n个元素——等价于Stream.skip。它并不涉及流的中断控制，反而更像是filter的变种，一种带有状态的filter。观察它和上面take的实现细节，内部随着流的迭代，存在一个计数器在不断刷新状态，但这个计数器并不能为外界感知。这里其实已经能体现出流的干净特性，它哪怕携带了状态，也丝毫不会外露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Seq&lt;T&gt; <span class="hljs-title function_">drop</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; &#123;<br>        <span class="hljs-type">int</span>[] a = &#123;n - <span class="hljs-number">1</span>&#125;;<br>        consume(t -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] &lt; <span class="hljs-number">0</span>) &#123;<br>                c.accept(t);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a[<span class="hljs-number">0</span>]--;<br>            &#125;<br>        &#125;);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="onEach"><a href="#onEach" class="headerlink" title="onEach"></a>onEach</h3><p>对流的某个元素添加一个操作consumer，但是不执行流——对应Stream.peek。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> Seq&lt;T&gt; <span class="hljs-title function_">onEach</span><span class="hljs-params">(Consumer&lt;T&gt; consumer)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; consume(consumer.andThen(c));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>流与一个iterable元素两两聚合，然后转换为一个新的流——在Stream里没有对应，但在Python里有同名实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> &lt;E, R&gt; Seq&lt;R&gt; <span class="hljs-title function_">zip</span><span class="hljs-params">(Iterable&lt;E&gt; iterable, BiFunction&lt;T, E, R&gt; function)</span> &#123;<br>    <span class="hljs-keyword">return</span> c -&gt; &#123;<br>        Iterator&lt;E&gt; iterator = iterable.iterator();<br>        consumeTillStop(t -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (iterator.hasNext()) &#123;<br>                c.accept(function.apply(t, iterator.next()));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stop();<br>            &#125;<br>        &#125;);<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3><p>上面实现的几个方法都是流的链式API，它们将一个流映射为另一个流，但流本身依然是lazy或者说尚未真正执行的。真正执行这个流需要使用所谓终端操作，对流进行消费或者聚合。在Stream里，消费就是forEach，聚合就是Collector。对于Collector，其实也可以有更好的设计，这里就不展开了。不过为了示例，可以先简单快速实现一个join。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> String <span class="hljs-title function_">join</span><span class="hljs-params">(String sep)</span> &#123;<br>    <span class="hljs-type">StringJoiner</span> <span class="hljs-variable">joiner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringJoiner</span>(sep);<br>    consume(t -&gt; joiner.add(t.toString()));<br>    <span class="hljs-keyword">return</span> joiner.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>以及toList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> List&lt;T&gt; <span class="hljs-title function_">toList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;T&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    consume(list::add);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此为止，我们仅仅只用几十行代码，就实现出了一个五脏俱全的流式API。在大部分情况下，这些API已经能覆盖百分之八九十的使用场景。你完全可以依样画葫芦，在其他编程语言里照着玩一玩，比如Go(笑)。</p><h2 id="生成器的推导"><a href="#生成器的推导" class="headerlink" title="生成器的推导"></a>生成器的推导</h2><p>本文虽然从标题开始就在讲生成器，甚至毫不夸张的说生成器才是最核心的特性，但等到把几个核心的流式API写完了，依然没有解释生成器到底是咋回事——其实倒也不是我在卖关子，你只要仔细观察一下，生成器早在最开始讲到Iterable天生就是Seq的时候，就已经出现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Seq&lt;Integer&gt; seq = list::forEach;<br></code></pre></td></tr></table></figure><p>没看出来？那把这个方法推导改写为普通lambda函数，有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Seq&lt;Integer&gt; seq = c -&gt; list.forEach(c);<br></code></pre></td></tr></table></figure><p>再进一步，把这个forEach替换为更传统的for循环，有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Seq&lt;Integer&gt; seq = c -&gt; &#123;<br>    for (Integer i : list) &#123;<br>        c.accept(i);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于已知这个list就是[1, 2, 3]，所以以上代码可以进一步等价写为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">Seq&lt;Integer&gt; seq = c -&gt; &#123;<br>    c.accept(1);<br>    c.accept(2);<br>    c.accept(3);<br>&#125;;<br></code></pre></td></tr></table></figure><p>是不是有点眼熟？不妨看看Python里类似的东西长啥样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plain">def seq():<br>    yield 1<br>    yield 2<br>    yield 3<br></code></pre></td></tr></table></figure><p>二者相对比，形式几乎可以说一模一样——这其实就已经是生成器了，这段代码里的accept就扮演了yield的角色，consume这个接口之所以取这个名字，含义就是指它是一个消费操作，所有的终端操作都是基于这个消费操作实现的。功能上看，它完全等价于Iterable的forEach，之所以又不直接叫forEach，是因为<strong>它的元素并不是本身自带的，而是通过闭包内的代码块临时生成的</strong>。</p><p>这种生成器，并非传统意义上利用continuation挂起的生成器，而是利用闭包来捕获代码块里临时生成的元素，哪怕没有挂起，也能高度模拟传统生成器的用法和特性。其实上文所有链式API的实现，本质上也都是生成器，只不过生成的元素来自于原始的流罢了。</p><p>有了生成器，我们就可以把前文提到的下划线转驼峰的操作用Java也依样画葫芦写出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">underscoreToCamel</span><span class="hljs-params">(String str)</span> &#123;<br>    <span class="hljs-comment">// Java没有首字母大写方法，随便现写一个</span><br>    UnaryOperator&lt;String&gt; capitalize = s -&gt; s.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>).toUpperCase() + s.substring(<span class="hljs-number">1</span>).toLowerCase();<br>     <span class="hljs-comment">// 利用生成器构造一个方法的流</span><br>    Seq&lt;UnaryOperator&lt;String&gt;&gt; seq = c -&gt; &#123;<br>        <span class="hljs-comment">// yield第一个小写函数</span><br>        c.accept(String::toLowerCase);<br>        <span class="hljs-comment">// 这里IDEA会告警，提示死循环风险，无视即可</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 按需yield首字母大写函数</span><br>            c.accept(capitalize);<br>        &#125;<br>    &#125;;<br>    List&lt;String&gt; split = Arrays.asList(str.split(<span class="hljs-string">&quot;_&quot;</span>));<br>    <span class="hljs-comment">// 这里的zip和join都在上文给出了实现</span><br>    <span class="hljs-keyword">return</span> seq.zip(split, (f, sub) -&gt; f.apply(sub)).join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>大家可以把这几段代码拷下来跑一跑，看它是不是真的实现了其目标功能。</p><p><strong>生成器的本质</strong></p><p>虽然已经推导出了生成器，但似乎还是有点摸不着头脑，这中间到底发生了什么，死循环是咋跳出的，怎么就能生成元素了。为了进一步解释，这里再举一个大家熟悉的例子。</p><h3 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h3><p>生产者与消费者的关系不止出现在多线程或者协程语境下，在单线程里也有一些经典场景。比如A和B两名同学合作一个项目，分别开发两个模块：A负责产出数据，B负责使用数据。A不关心B怎么处理数据，可能要先过滤一些，进行聚合后再做计算，也可能是写到某个本地或者远程的存储；B自然也不关心A的数据是怎么来的。这里边唯一的问题在于，数据条数实在是太多了，内存一次性放不下。在这种情况下，传统的做法是让A提供一个带回调函数consumer的接口，B在调用A的时候传入一个具体的consumer。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">produce</span><span class="hljs-params">(Consumer&lt;String&gt; callback)</span> &#123;<br>    <span class="hljs-comment">// do something that produce strings</span><br>    <span class="hljs-comment">// then use the callback consumer to eat them</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种基于回调函数的交互方式实在是过于经典了，原本没啥可多说的。但是在已经有了生成器之后，我们不妨胆子放大一点稍微做一下改造：仔细观察上面这个produce接口，它输入一个consumer，返回void——咦，所以它其实也是一个Seq嘛！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">Seq&lt;String&gt; producer = this::produce;<br></code></pre></td></tr></table></figure><p>接下来，我们只需要稍微调整下代码，就能对这个原本基于回调函数的接口进行一次升级，将它变成一个生成器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">public Seq&lt;String&gt; produce() &#123;<br>    return c -&gt; &#123;<br>        // still do something that produce strings<br>        // then use the callback consumer to eat them<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于这一层抽象，作为生产者的A和作为消费者的B就真正做到完全的、彻底的解耦了。A只需要把数据生产过程放到生成器的闭包里，期间涉及到的所有副作用，例如IO操作等，都被这个闭包完全隔离了。B则直接拿到一个干干净净的流，他不需要关心流的内部细节，当然想关心也关心不了，他只用专注于自己想做的事情即可。</p><p>更重要的是，A和B虽然在操作逻辑上完全解耦，互相不可见，<strong>但在CPU调度时间上它们却是彼此交错的</strong>，B甚至还能直接阻塞、中断A的生产流程——可以说没有协程，胜似协程。</p><p>至此，我们终于成功发现了<strong>Seq作为生成器的真正本质：consumer of callback</strong>。明明是一个回调函数的消费者，摇身一变就成了生产者，实在是有点奇妙。不过仔细一想倒也合理：能够满足消费者需求(callback)的家伙，不管这需求有多么奇怪，可不就是生产者么。</p><p>容易发现，基于callback机制的生成器，其调用开销完全就只有生成器闭包内部那堆代码块的执行开销，加上一点点微不足道的闭包创建开销。在诸多涉及到流式计算与控制的业务场景里，这将带来极为显著的内存与性能优势。后面我会给出展现其性能优势的具体场景实例。</p><p>另外，观察这段改造代码，会发现produce输出的东西，根本就还是个函数，没有任何数据被真正执行和产出。这就是生成器作为一个匿名接口的天生优势：<strong>惰性计算</strong>——消费者看似得到了整个流，实际那只是一张爱的号码牌，可以涂写，可以废弃，但只有在拿着货真价实的callback去兑换的那一刻，才会真正的执行流。</p><blockquote><p>生成器的本质，正是人类本质的反面：鸽子克星——没有任何人可以鸽它</p></blockquote><p>引自：</p><p><a href="https://mp.weixin.qq.com/s/v-HMKBWxtz1iakxFL09PDw">一种新的流：为Java加入生成器(Generator)特性</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库锁</title>
    <link href="/2023/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <url>/2023/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-32492148fccd82b903b680ef3732e749.png" alt="图片"></p><h2 id="1-为什么需要加锁"><a href="#1-为什么需要加锁" class="headerlink" title="1. 为什么需要加锁"></a>1. 为什么需要加锁</h2><blockquote><p>在日常生活中，如果你心情不好想静静，不想被比别人打扰，你就可以把自己关进房间里，并且反锁。这就是生活中的<strong>加锁</strong>。</p></blockquote><p>同理，对于MySQL数据库来说的话，一般的对象都是一个事务一个事务来说的。所以，如果一个事务内，一个SQL正在更新某条记录，我们肯定不想它被别的事务影响到嘛？因此，数据库设计大叔，给该行数据加上锁(行锁)。</p><blockquote><p>专业一点的说法: 如果有多个并发请求存取数据，在数据就可能会产生多个事务同时操作同一行数据。如果并发操作不加控制，不加锁的话，就可能写入了不正确的数据，或者导致读取了不正确的数据，破坏了数据的一致性。因此需要考虑加锁。</p></blockquote><h2 id="2-InnoDB有哪些锁？"><a href="#2-InnoDB有哪些锁？" class="headerlink" title="2. InnoDB有哪些锁？"></a>2. InnoDB有哪些锁？</h2><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-058986c18b10e8bdfd629401a5110246.png" alt="图片"></p><h3 id="2-1-共享-排他锁"><a href="#2-1-共享-排他锁" class="headerlink" title="2.1 共享&#x2F;排他锁"></a>2.1 共享&#x2F;排他锁</h3><p>InnoDB呢实现了两种标准的<strong>行级锁</strong>：共享锁（简称S锁）、排他锁（简称X锁）。</p><ul><li><p>共享锁：简称为S锁，在事务要读取一条记录时，需要先获取该记录的S锁。</p></li><li><p>排他锁：简称X锁，在事务需要改动一条记录时，需要先获取该记录的X锁。</p></li></ul><p>如果事务<code>T1</code>持有行R的<code>S</code>锁，那么另一个事务<code>T2</code>请求访问这条记录时，会做如下处理：</p><ul><li><p>T2 请求<code>S</code>锁立即被允许，结果<code>T1和T2</code>都持有R行的<code>S</code>锁</p></li><li><p>T2 请求<code>X</code>锁不能被立即允许,此操作会阻塞</p></li></ul><p>如果<code>T1</code>持有行R的<code>X</code>锁，那么<code>T2</code>请求R的<code>X、S</code>锁都不能被立即允许，<code>T2</code>必须等待<code>T1</code>释放<code>X</code>锁才可以，因为<code>X</code>锁与任何的锁都不兼容。</p><p>S锁和X锁的兼容关系如下图表格：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-c07ede16b6be0f0f50fa643cc65b319f.png" alt="图片"></p><p><code>X</code>锁和<code>S</code>锁是对于行记录来说的话，因此可以称它们为行级锁或者行锁。我们认为行锁的粒度就比较细，其实一个事务也可以在表级别下加锁，对应的，我们称之为表锁。给表加的锁，也是可以分为<code>X</code>锁和<code>S</code>锁的哈。</p><p>如果一个事务给表已经加了<code>S</code>锁，则：</p><ul><li><p>别的事务可以继续获得该表的<code>S</code>锁，也可以获得该表中某些记录的<code>S</code>锁。</p></li><li><p>别的事务不可以继续获得该表的<code>X</code>锁，也不可以获得该表中某些记录的<code>X</code>锁。</p></li></ul><p>如果一个事务给表加了<code>X</code>锁，那么</p><ul><li><p>别的事务不可以获得该表的<code>S</code>锁，也不可以获得该表某些记录的<code>S</code>锁。</p></li><li><p>别的事务不可以获得该表的<code>X</code>锁，也不可以继续获得该表某些记录的<code>X</code>锁。</p></li></ul><h3 id="2-2-意向锁"><a href="#2-2-意向锁" class="headerlink" title="2.2 意向锁"></a>2.2 意向锁</h3><p>什么是意向锁呢？意向锁是<strong>一种不与行级锁冲突的表级锁</strong>。未来的某个时刻，事务可能要加共享或者排它锁时，先提前声明一个意向。注意一下，意向锁，是一个<strong>表级别的锁哈</strong>。</p><p><strong>为什么需要意向锁呢？</strong> 或者换个通俗的说法，为什么要加共享锁或排他锁时的时候，需要提前声明个意向锁呢呢？</p><blockquote><p>因为InnoDB是支持表锁和行锁共存的，如果一个事务A获取到某一行的排他锁，并未提交，这时候事务B请求获取同一个表的表共享锁。因为<strong>共享锁和排他锁是互斥的</strong>，因此事务B想对这个表加共享锁时，需要保证没有其他事务持有这个表的表排他锁，同时还要保<strong>证没有其他事务持有表中任意一行的排他锁</strong>。</p><p>然后问题来了，你要保证没有其他事务持有表中任意一行的排他锁的话，去遍历每一行？这样显然是一个效率很差的做法。<strong>为了解决这个问题，InnoDb的设计大叔提出了意向锁。</strong></p></blockquote><p><strong>意向锁是如何解决这个问题的呢？</strong>  我们来看下</p><p>意向锁分为两类：</p><ul><li><p>意向共享锁：简称<code>IS</code>锁，当事务准备在某些记录上加S锁时，需要现在表级别加一个<code>IS</code>锁。</p></li><li><p>意向排他锁：简称<code>IX</code>锁，当事务准备在某条记录上加上X锁时，需要现在表级别加一个<code>IX</code>锁。</p></li></ul><p>比如：</p><ul><li><p><code>select ... lock in share mode</code>，要给表设置<code>IS</code>锁;</p></li><li><p><code>select ... for update</code>，要给表设置<code>IX</code>锁;</p></li></ul><p>意向锁又是如何解决这个效率低的问题呢：</p><blockquote><p>如果一个事务A获取到某一行的排他锁，并未提交,这时候表上就有<code>意向排他锁</code>和这一行的<code>排他锁</code>。这时候事务B想要获取这个表的共享锁，此时因为检测到事务A持有了表的<code>意向排他锁</code>，因此事务A必然持有某些行的排他锁，也就是说事务B对表的加锁请求需要阻塞等待，不再需要去检测表的每一行数据是否存在排他锁啦。</p></blockquote><p>意向锁仅仅表明意向的锁，意向锁之间不会互斥，是可以并行的，整体兼容性如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-67680187d8a0954715cd73714f110da3.png" alt="图片"></p><h3 id="2-3-记录锁（Record-Lock）"><a href="#2-3-记录锁（Record-Lock）" class="headerlink" title="2.3 记录锁（Record Lock）"></a>2.3 记录锁（Record Lock）</h3><p>记录锁是最简单的行锁，仅仅锁住一行。如：<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE</code>，如果C1字段是主键或者是唯一索引的话，这个SQL会加一个记录锁（Record Lock）</p><p>记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。它会阻塞其他事务对这行记录的插入、更新、删除。</p><p>一般我们看死锁日志时，都是找关键词，比如<code>lock_mode X locks rec but not gap</code>），就表示一个X型的记录锁。记录锁的关键词就是<strong>rec but not gap</strong>。以下就是一个记录锁的日志：</p><p><code>RECORD LOCKS space id 58 page no 3 n bits 72 index `PRIMARY` of table `test`.`t`    trx id 10078 lock_mode X locks rec but not gap   Record lock, heap no 2 PHYSICAL RECORD: n_fields 3; compact format; info bits 0    0: len 4; hex 8000000a; asc     ;;    1: len 6; hex 00000000274f; asc     &#39;O;;    2: len 7; hex b60000019d0110; asc        ;;   </code></p><h3 id="2-4-间隙锁（Gap-Lock）"><a href="#2-4-间隙锁（Gap-Lock）" class="headerlink" title="2.4 间隙锁（Gap Lock）"></a>2.4 间隙锁（Gap Lock）</h3><p>为了解决幻读问题，InnoDB引入了间隙锁<code>(Gap Lock)</code>。间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。它锁住的是<strong>一个区间</strong>，而不仅仅是这个区间中的每一条数据。</p><p>比如<code>lock_mode X locks gap before rec</code>表示X型gap锁。以下就是一个间隙锁的日志：</p><p><code>RECORD LOCKS space id 177 page no 4 n bits 80 index idx_name of table `test2`.`account`    trx id 38049 lock_mode X locks gap before rec   Record lock, heap no 6 PHYSICAL RECORD: n_fields 2; compact format; info bits 0    0: len 3; hex 576569; asc Wei;;    1: len 4; hex 80000002; asc     ;;   </code></p><h3 id="2-5-临键锁-Next-Key-Lock"><a href="#2-5-临键锁-Next-Key-Lock" class="headerlink" title="2.5 临键锁(Next-Key Lock)"></a>2.5 临键锁(Next-Key Lock)</h3><p>Next-key锁是<strong>记录锁和间隙锁的组合</strong>，它指的是加在某条记录以及这条记录前面间隙上的锁。说得更具体一点就是:临键锁会封锁索引记录本身，以及索引记录之前的区间，即它的锁区间是前开后闭，比如<code>(5,10]</code>。</p><p>如果一个会话占有了索引记录R的共享&#x2F;排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p><blockquote><p>If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order.</p></blockquote><h3 id="2-6-插入意向锁"><a href="#2-6-插入意向锁" class="headerlink" title="2.6 插入意向锁"></a>2.6 插入意向锁</h3><p>插入意向锁,是插入一行记录操作之前设置的<strong>一种间隙锁</strong>，这个锁释放了一种插入方式的信号。它解决的问题：多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。</p><p>假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方因为插入行不冲突。以下就是一个插入意向锁的日志：</p><p><code>RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`   trx id 8731 lock_mode X locks gap before rec insert intention waiting   Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0    0: len 4; hex 80000066; asc    f;;    1: len 6; hex 000000002215; asc     &quot; ;;    2: len 7; hex 9000000172011c; asc     r  ;;...      </code></p><p>锁模式兼容矩阵（横向是已持有锁，纵向是正在请求的锁）：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-56abd3f23255a70823bafe379f43c5d1.png" alt="图片"></p><h3 id="2-7-自增锁"><a href="#2-7-自增锁" class="headerlink" title="2.7 自增锁"></a>2.7 自增锁</h3><p><strong>自增锁是一种特殊的表级别锁</strong>。它是专门针对<code>AUTO_INCREMENT</code>类型的列，对于这种列，如果表中新增数据时就会去持有自增锁。简言之，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。</p><p>官方文档是这么描述的：</p><blockquote><p>An AUTO-INC lock is a special table-level lock taken by transactions inserting into tables with AUTO_INCREMENT columns. In the simplest case, if one transaction is inserting values into the table, any other transactions must wait to do their own inserts into that table, so that rows inserted by the first transaction receive consecutive primary key values.</p></blockquote><p>假设有表：</p><p><code>mysql&gt; create table t0 (id int NOT NULL AUTO_INCREMENT,name varchar(16),primary key ( id));      mysql&gt; show variables like &#39;%innodb_autoinc_lock_mode%&#39;;   +--------------------------+-------+   | Variable_name            | Value |   +--------------------------+-------+   | innodb_autoinc_lock_mode | 1     |   +--------------------------+-------+   1 row in set, 1 warning (0.01 sec)   </code></p><p>设置事务A和B交替执行流程如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-51745fe5ad3a4b5b9bafbf62b72d2444.png" alt="图片"></p><p>通过上图我们可以看到，当我们在事务A中进行自增列的插入操作时，另外会话事务B也进行插入操作，这种情况下会发生2个奇怪的现象：</p><ul><li><p>事务A会话中的自增列好像直接增加了2个值。（如上图中步骤7、8）</p></li><li><p>事务B会话中的自增列直接从2开始增加的。（如上图步骤5、6）</p></li></ul><p>自增锁是一个表级别锁，那为什么会话A事务还没结束，事务B可以执行插入成功呢？不是应该锁表嘛？这是因为在参数<code>innodb_autoinc_lock_mode</code>上，这个参数设置为<code>1</code>的时候，相当于将这种<code>auto_inc lock</code>弱化为了一个更轻量级的互斥自增长机制去实现，官方称之为<code>mutex</code>。</p><p>innodb_autoinc_lock_mode还可以设置为0或者2，</p><ul><li><p><strong>0</strong>：表示传统锁模式，使用<code>表级AUTO_INC</code>锁。一个事务的<code>INSERT-LIKE</code>语句在语句执行结束后释放AUTO_INC表级锁，而不是在事务结束后释放。</p></li><li><p><strong>1</strong>: 连续锁模式,连续锁模式对于<code>Simple inserts</code>不会使用表级锁，而是使用一个轻量级锁来生成自增值，因为InnoDB可以提前直到插入多少行数据。自增值生成阶段使用轻量级互斥锁来生成所有的值，而不是一直加锁直到插入完成。对于<code>bulk inserts</code>类语句使用AUTO_INC表级锁直到语句完成。</p></li><li><p><strong>2</strong>:交错锁模式,所有的<code>INSERT-LIKE</code>语句都不使用表级锁，而是使用轻量级互斥锁。</p></li></ul><blockquote><ul><li><p><strong>INSERT-LIKE</strong>:指所有的插入语句，包括：INSERT、REPLACE、INSERT…SELECT、REPLACE…SELECT,LOAD DATA等。</p></li><li><p><strong>Simple inserts</strong>:指在插入前就能确定插入行数的语句，包括：INSERT、REPLACE，不包含INSERT…ON DUPLICATE KEY UPDATE这类语句。</p></li><li><p><strong>Bulk inserts</strong>: 指在插入钱不能确定行数的语句，包括：INSERT … SELECT&#x2F;REPLACE … SELECT&#x2F;LOAD DATA。</p></li></ul></blockquote><h2 id="3-什么是死锁？如何防止死锁？"><a href="#3-什么是死锁？如何防止死锁？" class="headerlink" title="3. 什么是死锁？如何防止死锁？"></a>3. 什么是死锁？如何防止死锁？</h2><p><strong>什么是死锁？</strong></p><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-b8786b28a7b725a279e6ed368cff6577.png" alt="图片"></p><p><strong>如何防止死锁？</strong></p><ul><li><p>尽量约定固定的顺序访问表，因为交叉访问更容易造成事务等待回路。</p></li><li><p>尽量避免大事务，建议拆成多个小事务。因为大事务占用的锁资源越多，越容易出现死锁。</p></li><li><p>降低数据库隔离级别，比如RR降低为RC，因为RR隔离级别，存在GAP锁，死锁概率大很多。</p></li><li><p>死锁与索引是密不可分的，合理优化你的索引，死锁概率降低。</p></li><li><p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p></li></ul><h2 id="4-数据库的乐观锁和悲观锁"><a href="#4-数据库的乐观锁和悲观锁" class="headerlink" title="4.数据库的乐观锁和悲观锁"></a>4.数据库的乐观锁和悲观锁</h2><p><strong>悲观锁：</strong></p><blockquote><p>悲观锁她专一且缺乏安全感了，她的心只属于当前事务，每时每刻都担心着它 心爱的数据可能被别的事务修改，所以一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。<code>select…for update</code>就是<strong>MySQL悲观锁</strong>的应用。</p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-d2c5a2f2968ad5c1e5f9b4f246dc19ad.png" alt="图片"></p><p><strong>乐观锁：</strong></p><blockquote><p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会通过version版本号&#x2F;时间戳判断记录是否被更改过，一般配合CAS算法实现。</p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046776-3b3ea79ee40fa48120d18007caaaf21b.png" alt="图片"></p><p>大家可以看下这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487996&idx=1&sn=cafae3423e5ffa903a0c0a94a355f981&source=41&scene=21#wechat_redirect">图文并茂的带你彻底理解悲观锁与乐观锁</a></p><h2 id="5-select-for-update加的是表锁还是行锁"><a href="#5-select-for-update加的是表锁还是行锁" class="headerlink" title="5. select for update加的是表锁还是行锁"></a>5. select for update加的是表锁还是行锁</h2><p>这道面试题，一般需要分两种数据库隔离级别（RR和RC），还需要分查询条件是唯一索引、主键、一般索引、无索引等几种情况分开讨论</p><p><strong>在RC隔离级别下</strong></p><ul><li><p>如果查询条件是唯一索引，会加<code>IX</code>意向排他锁（表级别的锁，不影响插入）、两把<code>X</code>排他锁（行锁，分别对应唯一索引，主键索引）</p></li><li><p>如果查询条件是主键，会加<code>IX</code>意向排他锁（表级别的锁，不影响插入）、一把对应主键的<code>X</code>排他锁（行锁，会锁住主键索引那一行）。</p></li><li><p>如果查询条件是普通索引，<strong>如果查询命中记录</strong>，会加<code>IX</code>意向排他锁（表锁）、两把<code>X</code>排他锁（行锁，分别对应普通索引的<code>X</code>锁，对应主键的<code>X</code>锁）;<strong>如果没有命中数据库表的记录</strong>，只加了一把<code>IX</code>意向排他锁（表锁，不影响插入）</p></li><li><p>如果查询条件是无索引，会加两把锁，IX意向排他锁（表锁）、一把X排他锁（行锁，对应主键的X锁）。</p></li></ul><blockquote><p>查询条件是无索引，为什么不锁表呢？MySQL会走聚簇(主键)索引进行全表扫描过滤。每条记录都会加上X锁。但是，为了效率考虑，MySQL在这方面进行了改进，在扫描过程中，若记录不满足过滤条件，会进行解锁操作。同时优化违背了2PL原则。</p></blockquote><p><strong>在RR隔离级别</strong></p><ul><li><p>如果查询条件是唯一索引，命中数据库表记录时，一共会加三把锁：一把IX意向排他锁 （表锁，不影响插入），一把对应主键的X排他锁（行锁），一把对应唯一索引的X排他锁 （行锁）。</p></li><li><p>如果查询条件是主键，会加<code>IX</code>意向排他锁（表级别的锁，不影响插入）、一把对应主键的<code>X</code>排他锁（行锁，会锁住主键索引那一行）。</p></li><li><p>如果查询条件是普通索引，命中查询记录的话，除了会加X锁（行锁），IX锁（表锁，不影响插入），还会加Gap 锁（间隙锁，会影响插入）。</p></li><li><p>如果查询条件是无索引，会加一个IX锁（表锁，不影响插入），每一行实际记录行的X锁，还有对应于supremum pseudo-record的虚拟全表行锁。这种场景，通俗点讲，其实就是锁表了。</p></li></ul><p>大家可以看下我之前写的这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247503596&idx=1&sn=f81da0f3321b383c9690ee028da54a62&chksm=cf2211c5f85598d382badfd868c178d9474811a822acff6866219b65c0e571a5e49b896f6ca5&token=1563979917&lang=zh_CN&scene=21#wechat_redirect">聊聊select for update到底加了什么锁</a></p><h2 id="6-如何使用数据库分布式锁"><a href="#6-如何使用数据库分布式锁" class="headerlink" title="6.如何使用数据库分布式锁"></a>6.如何使用数据库分布式锁</h2><p>一般可以使用<code>select ... for update</code>来实现数据库的分布式锁。它的优点是：简单，使用方便，不需要引入Redis、zookeeper等中间件。缺点是：不适合高并发的场景，db操作性能较差。</p><p>我之前这篇文章，有详细介绍数据库分布式锁的实现，大家可以看看哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247498595&idx=1&sn=4e5308930e151a609baa2df820e48a89&chksm=cf22244af855ad5c71822cb33e828ce652c6f34202096a9344922b86dcbc08076d7922acde5f&token=1563979917&lang=zh_CN&scene=21#wechat_redirect">面试必备：聊聊分布式锁的多种实现！</a></p><h2 id="7-表级锁和行级锁，页面锁有什么区别"><a href="#7-表级锁和行级锁，页面锁有什么区别" class="headerlink" title="7.表级锁和行级锁，页面锁有什么区别"></a>7.表级锁和行级锁，页面锁有什么区别</h2><p>不同的存储引擎：</p><ul><li><p>MyISAM存储引擎，它只支持<strong>表锁</strong>，并发写的时候，性能差。</p></li><li><p>InnoDB存储引擎，即支持表锁，也支持行锁，默认为<strong>行级锁</strong>。</p></li><li><p>BDB 存储引擎，它支持<strong>表锁和页锁</strong>。</p></li></ul><p><strong>表级锁和行级锁的区别</strong>：</p><ul><li><p>表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</p></li><li><p>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高，行级锁能大大减少数据库操作的冲突</p></li><li><p>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul><h2 id="8-Mysql一条SQL是如何加锁的？"><a href="#8-Mysql一条SQL是如何加锁的？" class="headerlink" title="8. Mysql一条SQL是如何加锁的？"></a>8. Mysql一条SQL是如何加锁的？</h2><p>一条SQL加锁，可以分9种情况进行：</p><ul><li><p>组合一：id 列是主键，RC 隔离级别</p></li><li><p>组合二：id 列是二级唯一索引，RC 隔离级别</p></li><li><p>组合三：id 列是二级非唯一索引，RC 隔离级别</p></li><li><p>组合四：id 列上没有索引，RC 隔离级别</p></li><li><p>组合五：id 列是主键，RR 隔离级别</p></li><li><p>组合六：id 列是二级唯一索引，RR 隔离级别</p></li><li><p>组合七：id 列是二级非唯一索引，RR 隔离级别</p></li><li><p>组合八：id 列上没有索引，RR 隔离级别</p></li><li><p>组合九：Serializable 隔离级别</p></li></ul><p>可以看我这篇文章，第3小节有详细讲到哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1990623072&lang=zh_CN&scene=21#wechat_redirect">两万字详解！InnoDB 锁专题！</a></p><h2 id="9-并发情况下，如何做到安全的修改同一行数据"><a href="#9-并发情况下，如何做到安全的修改同一行数据" class="headerlink" title="9. 并发情况下，如何做到安全的修改同一行数据"></a>9. 并发情况下，如何做到安全的修改同一行数据</h2><p>要安全的修改同一行数据，就要保证一个线程在修改时其它线程无法更新这行 记录。其实一般有悲观锁和乐观锁两种思想，</p><p><strong>悲观锁思想</strong>就是，当前线程要进来修改数据时，别的线程都得拒之门外~ 比如， 可以使用 <code>select…for update ~</code>，</p><p><code>select * from User where name=‘jay’ for update   </code></p><p>以上这条 sql 语句会锁定了<code>User</code>表中所有符合检索条件（name&#x3D;‘jay’）的记 录。本次事务提交之前，别的线程都无法修改这些记录。</p><p>还可以使用<strong>乐观锁思想</strong>：</p><blockquote><p>所谓乐观锁思想，就是有线程过来，先放过去修改，如果看到别的线程没修改过， 就可以修改成功，如果别的线程修改过，就修改失败或者重试。实现方式：乐 观锁一般会使用版本号机制或 CAS 算法实现。可以看一下我这篇文章，主要是思路哈~ <a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487937&idx=1&sn=206a37bf6d6a7aa1d05674c479ed7a72&chksm=cf21cee8f85647fe7a082049a41c0f640f54976d2cdf4302b24c5517ca42b854eb84b13ece10&token=1712314640&lang=zh_CN&scene=21#wechat_redirect">CAS 乐观锁解决并发问题的一次实践</a></p></blockquote><p>当然，回答这个问题的时候呢，你可以提到<strong>分布式锁</strong>。分布式锁有这三种实现方式：</p><ul><li><p>数据库分布式锁</p></li><li><p>Redis分布式锁</p></li><li><p>Zookeeper分布式锁</p></li></ul><p>大家可以看我这篇文章哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247498595&idx=1&sn=4e5308930e151a609baa2df820e48a89&chksm=cf22244af855ad5c71822cb33e828ce652c6f34202096a9344922b86dcbc08076d7922acde5f&token=1563979917&lang=zh_CN&scene=21#wechat_redirect">面试必备：聊聊分布式锁的多种实现！</a></p><h2 id="10-RR隔离级别下的加锁规则是怎么样的？"><a href="#10-RR隔离级别下的加锁规则是怎么样的？" class="headerlink" title="10. RR隔离级别下的加锁规则是怎么样的？"></a>10. RR隔离级别下的加锁规则是怎么样的？</h2><p>其实，极客时间丁奇的<strong>MySQL45讲</strong>有讲到，RR隔离级别，是如何加锁的。大家有兴趣可以去订购看下哈，非常不错的课程。</p><p>首先MySQL的版本，是<code>5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13</code>。加锁规则一共包括：两个原则、两个优化和一个bug。</p><ul><li><p>原则1：加锁的基本单位都是<code>next-key lock</code>。next-key lock（临键锁）是前开后闭区间。</p></li><li><p>原则2：查找过程中访问到的对象才会加锁。</p></li><li><p>优化1：索引上的等值查询，给唯一索引加锁的时候，<code>next-key lock</code>退化为行锁<code>（Record lock）</code>。</p></li><li><p>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，<code>next-key lock</code>退化为间隙锁<code>（Gap lock）</code>。</p></li><li><p>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</p></li></ul><p>大家可以看我这篇文章，第4小节有详细讲到哈：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1990623072&lang=zh_CN&scene=21#wechat_redirect">两万字详解！InnoDB 锁专题！</a></p><h2 id="11-InnoDB-中行级锁时如何实现的？InnoDB三种行锁的算法"><a href="#11-InnoDB-中行级锁时如何实现的？InnoDB三种行锁的算法" class="headerlink" title="11. InnoDB 中行级锁时如何实现的？InnoDB三种行锁的算法"></a>11. InnoDB 中行级锁时如何实现的？InnoDB三种行锁的算法</h2><p>MySQL上的行级锁是通过给索引上的<strong>索引项加锁</strong>来实现，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。同时，当两条不同行的记录使用了相同的索引键时，也是会发生锁冲突的。</p><p>比如这条SQL：</p><p><code>select * from t where id = 666 for update;复制代码   for update</code> </p><p>可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将实行表锁。</p><p><strong>InnoDB</strong>行锁的3种算法：</p><ul><li><p>Record Lock：单个索引记录上的锁，</p></li><li><p>Gap Lock ：间隙锁，锁定一个范围，但不包含记录本身</p></li><li><p>Next-Key Lock：它等于<code>Gap Lock + Record Lock</code>，锁定一个范围，并且锁定记录本身。</p></li></ul><p>如果查询条件的是唯一索引，或者主键时，<code>Next-Key Lock</code>会降为<code>Record Lock</code>。如果是普通索引，将对下一个键值加上<code>gap lock</code>，其实就是对下一个键值的范围为加锁。<code>gap lock</code>间隙锁，就是为了解决幻读问题而设计出来的。</p><p>间隙锁是RR隔离级别的，如果你想关闭间隙锁，你可以修改隔离级别。也可以修改这个数据库参数<code>innodb_locks_unsafe_for_binlog</code>为<code>1</code>.</p><h2 id="12-MySQL-遇到过死锁问题吗，你是如何解决的？"><a href="#12-MySQL-遇到过死锁问题吗，你是如何解决的？" class="headerlink" title="12. MySQL 遇到过死锁问题吗，你是如何解决的？"></a>12. MySQL 遇到过死锁问题吗，你是如何解决的？</h2><p>我排查死锁的一般步骤是酱紫的：</p><ul><li><p>查看死锁日志<code>show engine innodb status</code>;</p></li><li><p>找出死锁<code>Sql</code></p></li><li><p>分析<code>sql</code>加锁情况</p></li><li><p>模拟死锁案发</p></li><li><p>分析死锁日志</p></li><li><p>分析死锁结果</p></li></ul><p>可以看我这两篇文章哈：</p><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247487979&idx=1&sn=588c83d77a8851f3b3c18cd68ed9c454&chksm=cf21cec2f85647d4a77cc239ae9a4cfd31bb8832be3d98540a08ea8b4a1f46b38cf736210a02&token=1495321435&lang=zh_CN&scene=21#wechat_redirect">手把手教你分析Mysql死锁问题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&mid=2247499275&idx=1&sn=ca72f48a290e4fd2a2ded6ef6fd045be&chksm=cf222122f855a8347b911352cebdd722b17ea45733b91ff169353c0805d9f31cea5261ef01b9&token=1712314640&lang=zh_CN&scene=21#wechat_redirect">两万字详解！InnoDB锁专题！</a></p></li></ul><p>引自：</p><p><a href="https://mp.weixin.qq.com/s/VEU5p85aTvyBKf2XP5QTSg">数据库锁的12连问</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实际分析Mysql死锁问题</title>
    <link href="/2023/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E9%99%85%E5%88%86%E6%9E%90Mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    <url>/2023/06/06/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E5%AE%9E%E9%99%85%E5%88%86%E6%9E%90Mysql%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p> <strong>2023.03.06阅读思考</strong></p></blockquote><ol><li>临键锁&#x3D;行锁(记录锁)+间隙锁</li><li>间隙锁用来解决幻读</li><li>Update语句会在非唯一索引的name加上左区间的间隙锁，右区间的间隙锁，如果未定位到则元素则锁全索引</li><li>可以看到两个事务 update 不存在的记录，先后获得<code>间隙锁( gap 锁)</code>，gap 锁之间是兼容的所以在update环节不会阻塞。两者都持有 gap 锁，然后去竞争插入<code>意向锁</code>。当存在其他会话持有 gap 锁的时候，当前会话申请不了插入意向锁，导致死锁。</li><li>插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，即事务A需要插入意向锁(E,W)</li><li>意向锁包括两种类型：意向共享锁（Intention Shared Lock，简称IS锁）和意向排他锁（Intention Exclusive Lock，简称IX锁）。这些锁不直接作用在数据记录上，而是作用在表级别或表的区间级别上。意向锁不是用来直接保护数据记录的，而是用来表明事务对表或区间的意向操作。实际的数据记录级别的锁由排他锁或共享锁来实现。</li><li>插入意向锁是一种特殊的意向锁，用于在B+树索引的插入操作中防止冲突。当一个事务要插入新的记录到索引中时，会请求插入意向锁，表明自己有意向在该索引的某个位置插入记录。</li></ol><blockquote><p><strong>2023.06.06阅读思考</strong></p></blockquote><ol><li>意向锁作用于全表或者索引区间，所以可以提高【查询、插入、更新】的并发度，因为意向锁作用于局部，只要并发事务不是操作统一区间，就可以不冲突的执行操作，从而提升执行效率</li></ol><h1 id="实际分析Mysql死锁问题"><a href="#实际分析Mysql死锁问题" class="headerlink" title="实际分析Mysql死锁问题"></a>实际分析Mysql死锁问题</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发生死锁了，如何排查和解决呢？本文将跟你一起探讨这个问题</p><ul><li>准备好数据环境</li><li>模拟死锁案发</li><li>分析死锁日志</li><li>分析死锁结果</li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>数据库隔离级别：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">mysql&gt; select @@tx_isolation;</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| @@tx_isolation  |</span><br><span class="hljs-section">+-----------------+</span><br><span class="hljs-section">| REPEATABLE-READ |</span><br><span class="hljs-section">+-----------------+</span><br>1 row in set, 1 warning (0.00 sec)<br></code></pre></td></tr></table></figure><p>自动提交关闭：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">mysql&gt; set autocommit=0;<br>Query OK, 0 rows affected (0.00 sec)<br><br><span class="hljs-section">mysql&gt; select @@autocommit;</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">| @@autocommit |</span><br><span class="hljs-section">+--------------+</span><br><span class="hljs-section">|            0 |</span><br><span class="hljs-section">+--------------+</span><br>1 row in set (0.00 sec)<br></code></pre></td></tr></table></figure><p>表结构:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//id是自增主键，<span class="hljs-type">name</span>是非唯一索引，balance普通字段<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `account` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `<span class="hljs-type">name</span>` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `balance` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`),<br>  KEY `idx_name` (`<span class="hljs-type">name</span>`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE=InnoDB AUTO_INCREMENT=<span class="hljs-number">3</span> <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>表中的数据：<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-df0cce135c2c7c4ce3f973f51bd7108b.png"></p><h2 id="模拟并发"><a href="#模拟并发" class="headerlink" title="模拟并发"></a>模拟并发</h2><p>开启两个终端模拟事务并发情况，执行顺序以及实验现象如下：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-d3b9f66b0796ced8e6f30c481ea3bfba.png"></p><p>1）事务A执行更新操作，更新成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">update</span>  account  <span class="hljs-keyword">set</span> balance =<span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> =<span class="hljs-string">&#x27;Wei&#x27;</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>2）事务B执行更新操作，更新成功</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">update</span>  account  <span class="hljs-keyword">set</span> balance =<span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> =<span class="hljs-string">&#x27;Eason&#x27;</span>;<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-keyword">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>3）事务A执行插入操作，陷入阻塞~</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">mysql&gt; <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-243a36e80da97327394cc67fd1717509.png"><br>这时候可以用<code>select * from information_schema.innodb_locks;</code>查看锁情况：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-2ed8af075a01d143e20a6bd06e45ab85.png"></p><p>4）事务B执行插入操作，插入成功，同时事务A的插入由阻塞变为死锁error。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-keyword">null</span>,<span class="hljs-string">&#x27;Yan&#x27;</span>,<span class="hljs-number">100</span>);<br>Query OK, <span class="hljs-number">1</span> <span class="hljs-type">row</span> affected (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-707bbabad4528c3a040eb00105c1d690.png"></p><h2 id="锁介绍"><a href="#锁介绍" class="headerlink" title="锁介绍"></a>锁介绍</h2><p>在分析死锁日志前，先做一下锁介绍，哈哈~</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-e4893b73abd0aeaefdf4973b7a997ddd.png"><br>主要介绍一下兼容性以及锁模式类型的锁：</p><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><p>InnoDB 实现了标准的行级锁，包括两种：共享锁（简称 s 锁）、排它锁（简称 x 锁）。</p><ul><li>共享锁（S锁）：允许持锁事务读取一行。</li><li>排他锁（X锁）：允许持锁事务更新或者删除一行。</li></ul><p>如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：</p><ul><li>T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁</li><li>T2 请求 x 锁不能被立即允许</li></ul><p>如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为X锁与任何的锁都不兼容。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-ff00748a9d5d86f1d1a952bb80a370b8.png"></p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul><li>意向共享锁( IS 锁)：事务想要获得一张表中某几行的共享锁</li><li>意向排他锁( IX 锁)： 事务想要获得一张表中某几行的排他锁</li></ul><p>比如：事务1在表1上加了S锁后，事务2想要更改某行记录，需要添加IX锁，由于不兼容，所以需要等待S锁释放；如果事务1在表1上加了IS锁，事务2添加的IX锁与IS锁兼容，就可以操作，这就实现了更细粒度的加锁。</p><p>InnoDB存储引擎中锁的兼容性如下表：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-7bd2c49055ff44fc62bf5c15eb73a6f8.png"></p><h3 id="记录锁（Record-Locks）"><a href="#记录锁（Record-Locks）" class="headerlink" title="记录锁（Record Locks）"></a>记录锁（Record Locks）</h3><ul><li>记录锁是最简单的行锁，<strong>仅仅锁住一行</strong>。如：<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE</code></li><li>记录锁<strong>永远都是加在索引上</strong>的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。</li><li>会阻塞其他事务对其插入、更新、删除</li></ul><p>记录锁的事务数据（关键词：<code>lock_mode X locks rec but not gap</code>），记录如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">RECORD</span> LOCKS space id <span class="hljs-number">58</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> `<span class="hljs-keyword">PRIMARY</span>` <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `test`.`t` <br>trx id <span class="hljs-number">10078</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap<br><span class="hljs-type">Record</span> <span class="hljs-keyword">lock</span>, heap <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> PHYSICAL <span class="hljs-type">RECORD</span>: n_fields <span class="hljs-number">3</span>; compact <span class="hljs-keyword">format</span>; <span class="hljs-keyword">info</span> bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">8000000</span>a; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">00000000274</span>f; <span class="hljs-keyword">asc</span>     <span class="hljs-string">&#x27;O;;</span><br><span class="hljs-string"> 2: len 7; hex b60000019d0110; asc        ;;</span><br></code></pre></td></tr></table></figure><h3 id="间隙锁（Gap-Locks）"><a href="#间隙锁（Gap-Locks）" class="headerlink" title="间隙锁（Gap Locks）"></a>间隙锁（Gap Locks）</h3><ul><li>间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。</li><li>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。</li><li>间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以 gap x lock 和 gap s lock 有相同的作用。</li></ul><p>间隙锁的事务数据（关键词：<code>gap before rec</code>），记录如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">RECORD</span> LOCKS space id <span class="hljs-number">177</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">80</span> <span class="hljs-keyword">index</span> idx_name <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `test2`.`account` <br>trx id <span class="hljs-number">38049</span> lock_mode X locks gap <span class="hljs-keyword">before</span> rec<br><span class="hljs-type">Record</span> <span class="hljs-keyword">lock</span>, heap <span class="hljs-keyword">no</span> <span class="hljs-number">6</span> PHYSICAL <span class="hljs-type">RECORD</span>: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; <span class="hljs-keyword">info</span> bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">3</span>; hex <span class="hljs-number">576569</span>; <span class="hljs-keyword">asc</span> Wei;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000002</span>; <span class="hljs-keyword">asc</span>     ;;<br></code></pre></td></tr></table></figure><h3 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h3><ul><li>Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。</li></ul><h3 id="插入意向锁（Insert-Intention）"><a href="#插入意向锁（Insert-Intention）" class="headerlink" title="插入意向锁（Insert Intention）"></a>插入意向锁（Insert Intention）</h3><ul><li>插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。</li><li>假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方因为插入行不冲突。</li></ul><p>事务数据类似于下面：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">RECORD</span> LOCKS space id <span class="hljs-number">31</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> n bits <span class="hljs-number">72</span> <span class="hljs-keyword">index</span> `<span class="hljs-keyword">PRIMARY</span>` <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `test`.`child`<br>trx id <span class="hljs-number">8731</span> lock_mode X locks gap <span class="hljs-keyword">before</span> rec <span class="hljs-keyword">insert</span> intention waiting<br><span class="hljs-type">Record</span> <span class="hljs-keyword">lock</span>, heap <span class="hljs-keyword">no</span> <span class="hljs-number">3</span> PHYSICAL <span class="hljs-type">RECORD</span>: n_fields <span class="hljs-number">3</span>; compact <span class="hljs-keyword">format</span>; <span class="hljs-keyword">info</span> bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000066</span>; <span class="hljs-keyword">asc</span>    f;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000002215</span>; <span class="hljs-keyword">asc</span>     &quot; ;;<br> 2: len 7; hex 9000000172011c; asc     r  ;;...<br></code></pre></td></tr></table></figure><p>锁模式兼容矩阵（横向是已持有锁，纵向是正在请求的锁）：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-c9383497bef39f1b21067397b71256f8.png"></p><h2 id="如何读懂死锁日志？"><a href="#如何读懂死锁日志？" class="headerlink" title="如何读懂死锁日志？"></a>如何读懂死锁日志？</h2><h3 id="show-engine-innodb-status"><a href="#show-engine-innodb-status" class="headerlink" title="show engine innodb status"></a>show engine innodb status</h3><p>可以用<code>show engine innodb status</code>，查看最近一次死锁日志哈~，执行后，死锁日志如下：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">11</span> <span class="hljs-number">00</span>:<span class="hljs-number">35</span>:<span class="hljs-number">55</span> <span class="hljs-number">0x243c</span><br>*** (<span class="hljs-number">1</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">38048</span>, ACTIVE <span class="hljs-number">92</span> sec inserting<br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br>LOCK WAIT <span class="hljs-number">4</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">4</span> row lock(s), undo <span class="hljs-keyword">log</span> entries <span class="hljs-number">2</span><br>MySQL thread id <span class="hljs-number">53</span>, OS thread handle <span class="hljs-number">2300</span>, query id <span class="hljs-number">2362</span> localhost ::<span class="hljs-number">1</span> root update<br>insert into account <span class="hljs-keyword">values</span>(null,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-number">100</span>)<br>*** (<span class="hljs-number">1</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">177</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">80</span> <span class="hljs-keyword">index</span> idx_name of table <span class="hljs-string">`test2`</span>.<span class="hljs-string">`account`</span> <br>trx id <span class="hljs-number">38048</span> lock_mode X locks gap before rec insert intention waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">6</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">3</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">576569</span>; asc Wei;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc     ;;<br><br>*** (<span class="hljs-number">2</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">38049</span>, ACTIVE <span class="hljs-number">72</span> sec inserting, thread declared inside InnoDB <span class="hljs-number">5000</span><br>mysql tables in <span class="hljs-keyword">use</span> <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br><span class="hljs-number">5</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">4</span> row lock(s), undo <span class="hljs-keyword">log</span> entries <span class="hljs-number">2</span><br>MySQL thread id <span class="hljs-number">52</span>, OS thread handle <span class="hljs-number">9276</span>, query id <span class="hljs-number">2363</span> localhost ::<span class="hljs-number">1</span> root update<br>insert into account  <span class="hljs-keyword">values</span>(null,<span class="hljs-string">&#x27;Yan&#x27;</span>,<span class="hljs-number">100</span>)<br>*** (<span class="hljs-number">2</span>) HOLDS THE LOCK(S):<br>RECORD LOCKS space id <span class="hljs-number">177</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">80</span> <span class="hljs-keyword">index</span> idx_name of table <span class="hljs-string">`test2`</span>.<span class="hljs-string">`account`</span> <br>trx id <span class="hljs-number">38049</span> lock_mode X locks gap before rec<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">6</span> PHYSICAL RECORD: n_fields <span class="hljs-number">2</span>; compact <span class="hljs-keyword">format</span>; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">3</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">576569</span>; asc Wei;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">4</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">80000002</span>; asc     ;;<br><br>*** (<span class="hljs-number">2</span>) WAITING FOR THIS LOCK TO BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">177</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">4</span> n bits <span class="hljs-number">80</span> <span class="hljs-keyword">index</span> idx_name of table <span class="hljs-string">`test2`</span>.<span class="hljs-string">`account`</span> <br>trx id <span class="hljs-number">38049</span> lock_mode X insert intention waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">1</span> PHYSICAL RECORD: n_fields <span class="hljs-number">1</span>; compact <span class="hljs-keyword">format</span>; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">8</span>; <span class="hljs-keyword">hex</span> <span class="hljs-number">73757072656</span>d756d; asc supremum;;<br><br>*** WE ROLL BACK TRANSACTION (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>我们如何分析以上死锁日志呢？</p><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>1）找到关键词TRANSACTION，事务38048</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-4dae27de842182dfeafa6e76cc22cb96.png"></p><p>2）查看正在执行的SQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>3）正在等待锁释放(WAITING FOR THIS LOCK TO BE GRANTED)，插入意向排他锁（lock_mode X locks gap before rec insert intention waiting），普通索引（idx_name），物理记录(PHYSICAL RECORD)，间隙区间（未知，Wei）;</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-f2cc17b44601986ea82de3c26e5d0acf.png"></p><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>1）找到关键词TRANSACTION，事务38049</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-db2edb8fb21d156846144e2e2b3ab9a8.png"><br>2）查看正在执行的SQL</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account  <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Yan&#x27;</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>3）持有锁(HOLDS THE LOCK)，间隙锁(lock_mode X locks gap before rec)，普通索引(index idx_name)，物理记录(physical record)，区间（未知，Wei）;<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-c6512be767d066710d21b2f83cc3b47c.png"></p><p>4）正在等待锁释放(waiting for this lock to be granted)，插入意向锁(lock_mode X insert intention waiting)，普通索引上(index idx_name)，物理记录(physical record)，间隙区间（未知，+∞）;</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-39d5a1dfd9dfcb61a719857f5d8d3ec7.png"></p><p>5）事务1回滚(we roll back transaction 1)；</p><h3 id="查看日志结果"><a href="#查看日志结果" class="headerlink" title="查看日志结果"></a>查看日志结果</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-89f487e8afb134787c92deb9da89aca9.png"><br>查看日志可得：</p><ul><li>事务A正在等待的插入意向排他锁（事务A即日志的事务1，根据insert语句来对号入座的哈），正在事务B的怀里~</li><li>事务B持有间隙锁，正在等待插入意向排它锁</li></ul><p>这里面，有些朋友可能有<strong>疑惑</strong>，</p><ul><li>事务A持有什么锁呢？日志根本看不出来。它又想拿什么样的插入意向排他锁呢？</li><li>事务B拿了具体什么的间隙锁呢？它为什么也要拿插入意向锁？</li><li>死锁的死循环是怎么形成的？目前日志看不出死循环构成呢？</li></ul><p>我们接下来一小节详细分析一波，一个一个问题来~</p><h2 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a>死锁分析</h2><h3 id="死锁死循环四要素"><a href="#死锁死循环四要素" class="headerlink" title="死锁死循环四要素"></a>死锁死循环四要素</h3><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-1c8d44b4d1ad990e99cbc036d3c72044.png"></p><ul><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ul><h3 id="事务A持有什么锁呢？它又想拿什么样的插入意向排他锁呢？"><a href="#事务A持有什么锁呢？它又想拿什么样的插入意向排他锁呢？" class="headerlink" title="事务A持有什么锁呢？它又想拿什么样的插入意向排他锁呢？"></a>事务A持有什么锁呢？它又想拿什么样的插入意向排他锁呢？</h3><p>为了方便记录，例子用W表示Wei，J表示Jay，E表示Eason哈~</p><h4 id="我们先来分析事务A中update语句的加锁情况"><a href="#我们先来分析事务A中update语句的加锁情况" class="headerlink" title="我们先来分析事务A中update语句的加锁情况~"></a>我们先来分析事务A中update语句的加锁情况~</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span>  account  <span class="hljs-keyword">set</span> balance =<span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> =<span class="hljs-string">&#x27;Wei&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>间隙锁：</strong></p><ul><li>Update语句会在非唯一索引的name加上左区间的间隙锁，右区间的间隙锁(因为目前表中只有name&#x3D;’Wei’的一条记录，所以没有中间的间隙锁~)，即（E,W) 和（W，+∞）</li><li>为什么存在间隙锁？因为这是RR的数据库隔离级别，用来解决幻读问题用的~</li></ul><p><strong>记录锁</strong></p><ul><li>因为name是索引，所以该update语句肯定会加上W的记录锁</li></ul><p><strong>Next-Key锁</strong></p><ul><li>Next-Key锁&#x3D;记录锁+间隙锁，所以该update语句就有了（E，W]的 Next-Key锁</li></ul><p><strong>综上所述，事务A执行完update更新语句，会持有锁：</strong></p><ul><li>Next-key Lock：（E，W]</li><li>Gap Lock ：（W，+∞）</li></ul><h4 id="我们再来分析一波事务A中insert语句的加锁情况"><a href="#我们再来分析一波事务A中insert语句的加锁情况" class="headerlink" title="我们再来分析一波事务A中insert语句的加锁情况"></a>我们再来分析一波事务A中insert语句的加锁情况</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Jay&#x27;</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><strong>间隙锁：</strong></p><ul><li>因为Jay(J在E和W之间)，所以需要请求加(E,W)的间隙锁</li></ul><p><strong>插入意向锁（Insert Intention）</strong></p><ul><li>插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，即事务A需要插入意向锁(E,W)</li></ul><p><strong>因此</strong>，事务A的update语句和insert语句执行完，它是持有了 <strong>（E，W]的 Next-Key锁</strong>，<strong>（W，+∞）的Gap锁</strong>，想拿到 <strong>(E,W)的插入意向排它锁</strong>，等待的锁跟死锁日志是对上的，哈哈~</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-69d338f5131acb787dc42666eb98f810.png"></p><h3 id="事务B拥有了什么间隙锁？它为什么也要拿插入意向锁？"><a href="#事务B拥有了什么间隙锁？它为什么也要拿插入意向锁？" class="headerlink" title="事务B拥有了什么间隙锁？它为什么也要拿插入意向锁？"></a>事务B拥有了什么间隙锁？它为什么也要拿插入意向锁？</h3><h4 id="同理，我们再来分析一波事务B，update语句的加锁分析："><a href="#同理，我们再来分析一波事务B，update语句的加锁分析：" class="headerlink" title="同理，我们再来分析一波事务B，update语句的加锁分析："></a>同理，我们再来分析一波事务B，update语句的加锁分析：</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">update</span>  account  <span class="hljs-keyword">set</span> balance =<span class="hljs-number">1000</span> <span class="hljs-keyword">where</span> <span class="hljs-type">name</span> =<span class="hljs-string">&#x27;Eason&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>间隙锁：</strong></p><ul><li>Update语句会在非唯一索引的name加上左区间的间隙锁，右区间的间隙锁(因为目前表中只有name&#x3D;’Eason’的一条记录，所以没有中间的间隙锁~)，即（-∞，E）和（E，W）</li></ul><p><strong>记录锁</strong></p><ul><li>因为name是索引，所以该update语句肯定会加上E的记录锁</li></ul><p><strong>Next-Key锁</strong></p><ul><li>Next-Key锁&#x3D;记录锁+间隙锁，所以该Update语句就有了（-∞，E]的 Next-Key锁</li></ul><p><strong>综上所述，事务B执行完update更新语句，会持有锁：</strong></p><ul><li>Next-key Lock：（-∞，E]</li><li>Gap Lock ：（E，W）</li></ul><h4 id="我们再来分析一波B中insert语句的加锁情况"><a href="#我们再来分析一波B中insert语句的加锁情况" class="headerlink" title="我们再来分析一波B中insert语句的加锁情况"></a>我们再来分析一波B中insert语句的加锁情况</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account  <span class="hljs-keyword">values</span>(<span class="hljs-literal">null</span>,<span class="hljs-string">&#x27;Yan&#x27;</span>,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p><strong>间隙锁：</strong></p><ul><li>因为Yan(Y在W之后)，所以需要请求加(W,+∞)的间隙锁</li></ul><p><strong>插入意向锁（Insert Intention）</strong></p><ul><li>插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，即事务A需要插入意向锁(W,+∞)</li></ul><p><strong>所以</strong>，事务B的update语句和insert语句执行完，它是持有了 <strong>（-∞，E]的 Next-Key锁</strong>，<strong>（E，W）的Gap锁</strong>，想拿到 <strong>(W,+∞)的间隙锁，即插入意向排它锁</strong>，加锁情况跟死锁日志也是对上的~</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-a3dd2f86d5068e8b77899fed9b18fc28.png"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-554c0b6afcb4b4891076b1dea7a08dcc.png"></p><h3 id="死锁真相还原"><a href="#死锁真相还原" class="headerlink" title="死锁真相还原"></a>死锁真相还原</h3><p>接下来呢，让我们一起还原死锁真相吧<del>哈哈</del><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1686046013-5a63063f01400056003d3e343abbac69.png"></p><ul><li>事务A执行完Update Wei的语句，持有（E，W]的Next-key Lock，（W，+∞）的Gap Lock ，插入成功~</li><li>事务B执行完Update Eason语句，持有（-∞，E]的 Next-Key Lock，（E，W）的Gap Lock，插入成功~</li><li>事务A执行Insert Jay的语句时，因为需要（E，W）的插入意向锁，但是（E，W）在事务B怀里，所以它陷入心塞~</li><li>事务B执行Insert Yan的语句时，因为需要(W,+∞) 的插入意向锁，但是(W,+∞) 在事务A怀里，所以它也陷入心塞。</li><li>事务A持有（W，+∞）的Gap Lock，在等待（E，W）的插入意向锁，事务B持有（E，W）的Gap锁，在等待(W,+∞) 的插入意向锁，所以形成了死锁的闭环<del>（Gap锁与插入意向锁会冲突的，可以看回锁介绍的锁模式兼容矩阵哈</del>）</li><li>事务A,B形成了死锁闭环后，因为Innodb的底层机制，它会让其中一个事务让出资源，另外的事务执行成功，这就是为什么你最后看到事务B插入成功了，但是事务A的插入显示了Deadlock found ~</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，遇到死锁问题，我们应该怎么分析呢？</p><ul><li>模拟死锁场景</li><li>show engine innodb status;查看死锁日志</li><li>找出死锁SQL</li><li>SQL加锁分析，<a href="https://link.segmentfault.com/?enc=hhnA+SSHBaKevE6H7HUisg==.tz1vDxsx0BsCxfyEb75BhdzUtESXL4B4E/xpOg6Vt67o57tOnf7JWZ4Lidp4gykk7oeblhu/3gaNLF81EITHJA==">这个可以去官网看哈</a></li><li>分析死锁日志（持有什么锁，等待什么锁）</li><li>熟悉锁模式兼容矩阵，InnoDB存储引擎中锁的兼容性矩阵。</li></ul><p>参考文章：</p><ol><li><a href="https://segmentfault.com/a/1190000037510033">手把手教你分析Mysql死锁问题</a></li><li><a href="https://z.itpub.net/article/detail/7B944ED17C0084CF672A47D6E938B750">阿里二面：怎么解决MySQL死锁问题的？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>arthas使用指南</title>
    <link href="/2023/06/01/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/arthas%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/06/01/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/arthas%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="arthas使用指南"><a href="#arthas使用指南" class="headerlink" title="arthas使用指南"></a>arthas使用指南</h1><h2 id="零、原理简介"><a href="#零、原理简介" class="headerlink" title="零、原理简介"></a><strong>零、原理简介</strong></h2><p>arthas &#x3D; Instrumentation + java agent + attach api + ASM</p><p>官方开源代码仓库：<a href="https://github.com/alibaba/arthas">https://github.com/alibaba/arthas</a></p><p>Arthas-MVEL：<a href="https://github.com/XhinLiang/arthas-mvel">https://github.com/XhinLiang/arthas-mvel</a></p><h3 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a><strong>Instrumentation</strong></h3><p>Instrumentation 是 Java 提供的一个来自 JVM 的接口，该接口提供了一系列查看和操作 Java 类定义的方法，例如修改类的字节码、向 classLoader 的 classpath 下加入 jar 文件等。使得开发者可以通过 Java 语言来操作和监控 JVM 内部的一些状态，进而实现 Java 程序的监控分析，甚至实现一些特殊功能（如 JVM 版本的 AOP、热部署等）。</p><h3 id="Java-agent"><a href="#Java-agent" class="headerlink" title="Java agent"></a><strong>Java agent</strong></h3><p>Java agent 是一种特殊的Java程序（Jar文件），它是 Instrumentation 的客户端。与普通 Java 程序通过 main 方法启动不同，agent 并不是一个可以单独启动的程序，而必须依附在一个 Java 应用程序上，通过 Instrumentation API 与 JVM 交互。</p><p>Java agent 与 Instrumentation 二者需要在一起使用。</p><h3 id="attach-api"><a href="#attach-api" class="headerlink" title="attach api"></a><strong>attach api</strong></h3><p>Java agent 可以在 JVM 启动后再加载，而这是通过 attach api 实现的。attach api 不仅仅是为了实现动态加载 agent，attach api 其实是跨 JVM 进程通讯的工具，能够将某种指令从一个 JVM 进程发送给另一个 JVM 进程。</p><p>加载 agent 只是 attach api 发送的各种指令中的一种， 诸如 jstack 打印线程栈、jps 列出 Java 进程、jmap 做内存 dump 等功能，都属于 attach api 可以发送的指令。</p><h3 id="ASM-字节码操作和分析框架"><a href="#ASM-字节码操作和分析框架" class="headerlink" title="ASM 字节码操作和分析框架"></a><strong>ASM 字节码操作和分析框架</strong></h3><p>arthas 通过 ASM 这个 Java 字节码操作和分析框架来对目标类的字节码进行修改。在字节码增强的过程中，arthas 会在目标类的方法入口和出口处插入特定的字节码，用于收集方法的调用次数、响应时间等性能指标。同时，arthas 可以通过修改字节码来实现条件断点、异常捕获等调试功能。</p><p><strong>总而言之，arthas 首先利用 attach api 将自己作为 Java agent 附加到目标 JVM 进程中。然后，arthas 通过 Java Instrumentati<strong><strong>on 获取目标进程的类和对象等运</strong></strong>行时信息，并借助 ASM 对目标类的字节码进行动态修改。最后，arthas 与目标 JVM 进程进行进程间通信，接收用户的命令并返回诊断结果</strong></p><h3 id="Karthas"><a href="#Karthas" class="headerlink" title="Karthas"></a><strong>Karthas</strong></h3><ol><li><strong>mvel 支持</strong></li></ol><p>arthas 动态表达式的引擎采用的是 ognl，ognl 的语法不太直观，为了方便用户的使用，karthas 增加了对 mvel 语法的支持，<strong>支持 Spring Bean 的自动加载</strong>，因此可以类似 python 等交互式语言一样，直接简单地交互执行当前 arthas 注入的 Java 进程的任意方法。具体的使用见 3.9 节。</p><ol><li><strong>web console 协作</strong></li></ol><p>arthas本身是一个命令行工具，因此使用的主要场景主要是单个开发人员独自 debug 线上问题。但在实际应用场景中，往往需要多个开发人员共同 debug 同一个现场，这时候如果能把 arthas 的现场通过 web url 分享出来，就会使得这种场景的处理更加方便。</p><p>karthas 在这个方面针对 arthas 原生的 tunnel-server 进行了增强，使得 web console 能够穿透快手的 access proxy 环境，同时申请资源对 tunnel-server 在快手的环境进行了集群化部署，让快手用户能够开箱可用。</p><h2 id="一、进入方式"><a href="#一、进入方式" class="headerlink" title="一、进入方式"></a><strong>一、进入方式</strong></h2><p>流水线配置时，设置使用 kbox：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-e4b2ae7b265aac5019b29223fce84c88.png"></p><p>之后打开容器 webssh，使用 jps  找到 java 进程的 pid，使用命令 <strong>&#x2F;opt&#x2F;kbox&#x2F;latest&#x2F;karthas&#x2F;kas.sh pid</strong> 得到 Karthas 的 url 链接，进入即可到达 Karthas 界面</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-71a23aeca37f716527573bd56733b527.png"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-25a3e17233a880ce7a5c283fb0901bfa.png"></p><h2 id="二、辅助工具"><a href="#二、辅助工具" class="headerlink" title="二、辅助工具"></a><strong>二、辅助工具</strong></h2><p>因 Karthas 部分命令形式较为复杂，推荐安装 idea 插件 arthas idea：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-34b7778b58ec6a269991b525c1d48fc2.png"></p><p>安装后，右击想要观察的类字段、方法上，即可快捷生成相关命令</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-768197f87d9998eb5f8fb8edd54e70d2.png"></p><h2 id="三、常用命令及功能"><a href="#三、常用命令及功能" class="headerlink" title="三、常用命令及功能"></a><strong>三、常用命令及功能</strong></h2><h3 id="3-1-jad-命令——查看反编译代码"><a href="#3-1-jad-命令——查看反编译代码" class="headerlink" title="3.1 jad 命令——查看反编译代码"></a><strong>3.1 jad 命令——查看反编译代码</strong></h3><p>jad 命令后添加类全路径即可查看字节码反编译的 java 代码</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-35468342fec9541f3998881106b3c0a4.png"></p><h3 id="3-2-查看-kconf-取值"><a href="#3-2-查看-kconf-取值" class="headerlink" title="3.2 查看 kconf 取值"></a><strong>3.2 查看 kconf 取值</strong></h3><p>依靠 Karthas 的 MVEL，可以像交互式解释器那样，使用赋值语句获得 kconf 对象，之后直接调用 get() 即可，也可调用 defaultValue()、configKeyNameSpace()、configKey() 等获取更多信息</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl">[arthas@70]$ kconf = com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusStringListConfigKey.ocpcSplitCharList<br>@MerchantJanusStringListConfigKey[ocpcSplitCharList]<br>[arthas@70]$ kconf.get()<br>@ArrayList[<br>    @String[,],<br>    @String[%2c],<br>    @String[%2C],<br>]<br></code></pre></td></tr></table></figure><h3 id="3-3-watch-命令——监视方法调用"><a href="#3-3-watch-命令——监视方法调用" class="headerlink" title="3.3 watch 命令——监视方法调用"></a><strong>3.3 watch 命令——监视方法调用</strong></h3><p>使用 watch 命令监视方法调用，可查看调用时间、入参出参以及抛出的异常。</p><p><strong>参数说明:</strong></p><p>class-pattern: 类名表达式匹配</p><p>method-pattern: 方法名表达式匹配</p><p>express: 观察表达式，默认值：{params, target, returnObj}</p><p>condition-express: 条件表达式</p><p>[b]: 在函数调用之前观察</p><p>[e]: 在函数异常之后观察</p><p>[s]: 在函数返回之后观察</p><p>[f]: 在函数结束之后(正常返回和异常返回)观察</p><p>[E]: 开启正则表达式匹配，默认为通配符匹配</p><p>[x:]: 指定输出结果的属性遍历深度，默认为 1，最大值是 4</p><p>观察表达式与条件表达式均为一个 ognl 表达式，其围绕以下对象进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advice</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;  <span class="hljs-comment">// 本次调用类所在的类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazz;      <span class="hljs-comment">// 本次调用方法所在类的 Class 引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ArthasMethod method; <span class="hljs-comment">// 本次调用方法反射引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;       <span class="hljs-comment">// 本次调用类的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] params;     <span class="hljs-comment">// 本次调用参数列表，是一个数组，如果方法是无参方法则为空数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object returnObj;    <span class="hljs-comment">// 本次调用返回的对象。当且仅当 isReturn==true 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 void，则值为 null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Throwable throwExp;  <span class="hljs-comment">// 本次调用抛出的异常。当且仅当 isThrow==true 成立时有效，表明方法调用是以抛出异常的方式结束。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isBefore;    <span class="hljs-comment">// 标志：当前的通知节点有可能是在方法一开始就通知，此时 isBefore==true 成立，同时 isThrow==false 和 isReturn==false，因为在方法刚开始时，还无法确定方法调用将会如何结束。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isThrow;     <span class="hljs-comment">// 标志：当前的方法调用以抛异常的形式结束。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> isReturn;    <span class="hljs-comment">// 标志：当前的方法调用以正常返回的形式结束。</span><br>    <span class="hljs-comment">// getter/setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此默认会观察调用类的实例、入参列表以及返回值。</p><h4 id="观察正常返回的出入参"><a href="#观察正常返回的出入参" class="headerlink" title="观察正常返回的出入参"></a><strong>观察正常返回的出入参</strong></h4><p>下面的例子观察 KimServiceImpl#convertMsgRequest 方法的出入参，使用了参数 “-n 1” 表示只观察一次，“-x 3” 表示将出入参的属性仅展开三级。另外因入参被看作一个数组，所以其为 Object[] 类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plain">[arthas@71]$ watch com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.KimServiceImpl convertMsgRequest &#x27;&#123;params,returnObj&#125;&#x27;  -n 1  -x 3<br>Press Q or Ctrl+C to abort.<br>Affect(class count: 1 , method count: 1) cost in 309 ms, listenerId: 34<br>method=com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.KimServiceImpl.convertMsgRequest location=AtExit<br>ts=2023-05-04 19:58:09; [cost=0.050595ms] result=@ArrayList[<br>    @Object[][<br>        @KimRequest[<br>            appKey=@String[18eb1702-c0b9-4eea-9455-506daf42ce85],<br>            appSecret=@String[cde904cb-9169-4e9f-a32d-ce4a1200603a],<br>            groupId=null,<br>            userId=null,<br>            userName=@String[yanghao12],<br>            sendType=@Integer[0],<br>            param=@HashMap[isEmpty=false;size=1],<br>        ],<br>    ],<br>    @KimMsgRequest[<br>        username=@String[yanghao12],<br>        userId=null,<br>        groupId=null,<br>        msgType=null,<br>        markdown=null,<br>        text=null,<br>    ],<br>]<br>Command execution times exceed limit: 1, so command will exit. You can set it with -n option.<br></code></pre></td></tr></table></figure><h4 id="观察异常情况下的出入参及异常"><a href="#观察异常情况下的出入参及异常" class="headerlink" title="观察异常情况下的出入参及异常"></a><strong>观察异常情况下的出入参及异常</strong></h4><p>对 ChatServiceImpl#chatDomainConversation 方法构造了一个抛出异常的执行，然后 watch 其详细信息，调用后得到如下结果。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>watch com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chatDomainConversation <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span>  -n <span class="hljs-number">1</span>  -x <span class="hljs-number">3</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">264</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">35</span><br>method=com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span>.chatDomainConversation location=<span class="hljs-title class_">AtExceptionExit</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">04</span> <span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span>; [cost=<span class="hljs-number">1</span>.676912ms] result=<span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@Object</span>[][<br>        <span class="hljs-variable">@String</span>[yanghao12],<br>        null,<br>        <span class="hljs-variable">@String</span>[hello],<br>        <span class="hljs-variable">@String</span>[],<br>    ],<br>    null,<br>    com.kuaishou.kwaishop.merchant.answerize.center.common.exception.<span class="hljs-title class_">AnswerizeBaseException</span>: 目前没有对应领域存在<br>        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span>.chatDomainConversation(<span class="hljs-title class_">ChatServiceImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">139</span>)<br>        at java.base/jdk.internal.reflect.<span class="hljs-title class_">NativeMethodAccessorImpl</span>.invoke0(<span class="hljs-title class_">Native</span> <span class="hljs-title class_">Method</span>)<br>        at java.base/jdk.internal.reflect.<span class="hljs-title class_">NativeMethodAccessorImpl</span>.invoke(<span class="hljs-title class_">NativeMethodAccessorImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">62</span>)<br>        at java.base/jdk.internal.reflect.<span class="hljs-title class_">DelegatingMethodAccessorImpl</span>.invoke(<span class="hljs-title class_">DelegatingMethodAccessorImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">43</span>)<br>        at java.base/java.lang.reflect.<span class="hljs-title class_">Method</span>.invoke(<span class="hljs-title class_">Method</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">566</span>)<br>        ......<br>,<br>]<br><span class="hljs-title class_">Command</span> execution times exceed <span class="hljs-symbol">limit:</span> <span class="hljs-number">1</span>, so command will exit. <span class="hljs-title class_">You</span> can set it with -n option.<br></code></pre></td></tr></table></figure><h4 id="限定条件的-watch"><a href="#限定条件的-watch" class="headerlink" title="限定条件的 watch"></a><strong>限定条件的 watch</strong></h4><p>可使用条件表达式，例如想限定入参属性 userName 为 “test”，则可以使用如下语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">watch com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.KimServiceImpl convertMsgRequest &#x27;&#123;params,returnObj,throwExp&#125;&#x27; &#x27;params[0].getUserName().equals(&quot;test&quot;)&#x27; -x 3<br></code></pre></td></tr></table></figure><p>如想限定第一个参数，则可使用 params[0] 对第一个参数进行限定：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>watch com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span> <span class="hljs-string">&#x27;params[0].equals(&quot;yanghao12&quot;)&#x27;</span> -x <span class="hljs-number">3</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">252</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">50</span><br>method=com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span>.chat location=<span class="hljs-title class_">AtExit</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">04</span> <span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">37</span><span class="hljs-symbol">:</span><span class="hljs-number">03</span>; [cost=<span class="hljs-number">3167</span>.408299ms] result=<span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@Object</span>[][<br>        <span class="hljs-variable">@String</span>[yanghao12],<br>        <span class="hljs-variable">@String</span>[你是谁？],<br>        <span class="hljs-variable">@String</span>[],<br>    ],<br>    <span class="hljs-variable">@String</span>[我是快手公司商家增长团队研发的智能小助手，专门为用户提供帮助和答疑服务。如果您有任何关于快手平台的问题需要咨询，随时欢迎向我提问。],<br>    null,<br>]<br></code></pre></td></tr></table></figure><p>可采用 &amp;&amp;、||、^ 等逻辑操作符进行多个条件的连接，例如通过 &amp;&amp; 连接两个条件，其中 #cost 表示方法的耗时（ms）：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>watch com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span> <span class="hljs-string">&#x27;params[0].equals(&quot;yanghao12&quot;)&amp;&amp;#cost &gt; 3000&#x27;</span> -x <span class="hljs-number">3</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">257</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">55</span><br>method=com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span>.chat location=<span class="hljs-title class_">AtExit</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">04</span> <span class="hljs-number">20</span><span class="hljs-symbol">:</span><span class="hljs-number">42</span><span class="hljs-symbol">:</span><span class="hljs-number">27</span>; [cost=<span class="hljs-number">7961</span>.660798ms] result=<span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@Object</span>[][<br>        <span class="hljs-variable">@String</span>[yanghao12],<br>        <span class="hljs-variable">@String</span>[讲个鬼故事吧],<br>        <span class="hljs-variable">@String</span>[],<br>    ],<br>    <span class="hljs-variable">@String</span>[好的，以下是一个短小的鬼故事：\n\n有一个人在深夜走在路上，突然看到前方有一个女人，女人的脸被头发遮住了，只露出一双眼睛。那个人觉得很奇怪，但还是走了过去，当他走过女人身边时，女人突然转过头来，露出了一张恐怖的面孔，那个人吓得立刻逃跑了。\n\n据说这个女人是一个被杀害的鬼魂，她会在深夜出现在路上，引诱路人靠近，然后杀死他们。因此，人们在深夜出行时要特别小心，避免遇到这个可怕的鬼魂。],<br>    null,<br>]<br></code></pre></td></tr></table></figure><h4 id="监视-sql-语句"><a href="#监视-sql-语句" class="headerlink" title="监视 sql 语句"></a><strong>监视 sql 语句</strong></h4><p>若使用了 mybatis 或 mybatis-plus，可使用如下命令简单监视任意 sql 语句</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>watch org.apache.ibatis.mapping.<span class="hljs-title class_">BoundSql</span> getSql <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span> -x <span class="hljs-number">3</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">368</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">64</span><br>method=org.apache.ibatis.mapping.<span class="hljs-title class_">BoundSql</span>.getSql location=<span class="hljs-title class_">AtExit</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">10</span>; [cost=<span class="hljs-number">0</span>.055517ms] result=<span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@Object</span>[][isEmpty=<span class="hljs-literal">true</span>;size=<span class="hljs-number">0</span>],<br>    <span class="hljs-variable">@String</span>[<span class="hljs-variable constant_">SELECT</span>  id,user,messages,create_time,update_time  <span class="hljs-variable constant_">FROM</span> history_info \n \n <span class="hljs-variable constant_">WHERE</span> (user = <span class="hljs-string">?)</span> <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> create_time <span class="hljs-variable constant_">DESC</span> limit <span class="hljs-number">1</span>],<br>    null,<br>]<br>method=org.apache.ibatis.mapping.<span class="hljs-title class_">BoundSql</span>.getSql location=<span class="hljs-title class_">AtExit</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">10</span><span class="hljs-symbol">:</span><span class="hljs-number">49</span><span class="hljs-symbol">:</span><span class="hljs-number">12</span>; [cost=<span class="hljs-number">0</span>.014351ms] result=<span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@Object</span>[][isEmpty=<span class="hljs-literal">true</span>;size=<span class="hljs-number">0</span>],<br>    <span class="hljs-variable">@String</span>[<span class="hljs-variable constant_">UPDATE</span> history_info  <span class="hljs-variable constant_">SET</span> user=<span class="hljs-string">?,\n</span>messages=<span class="hljs-string">?,\n\n</span>update_time=?  \n \n <span class="hljs-variable constant_">WHERE</span> (user = <span class="hljs-string">?)</span>],<br>    null,<br>]<br></code></pre></td></tr></table></figure><h4 id="监视-http-请求"><a href="#监视-http-请求" class="headerlink" title="监视 http 请求"></a><strong>监视 http 请求</strong></h4><p>以下会跟踪耗时大于 100ms 的 http  请求的 url 及耗时情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">watch org.springframework.web.servlet.DispatcherServlet doService &#x27;&#123;params[0].getRequestURI()+&quot; &quot;+ #cost&#125;&#x27;  -n 5  -x 3 &#x27;#cost&gt;100&#x27;  -f<br></code></pre></td></tr></table></figure><p>可获取指定 header 信息，例如以下获取 trace-id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">watch org.springframework.web.servlet.DispatcherServlet doService &#x27;&#123;params[0].getRequestURI()+&quot;  header=&quot;+params[1].getHeaders(&quot;trace-id&quot;)&#125;&#x27;  -n 5  -x 3 -f<br></code></pre></td></tr></table></figure><h3 id="3-4-thread-命令"><a href="#3-4-thread-命令" class="headerlink" title="3.4 thread 命令"></a><strong>3.4 thread 命令</strong></h3><p><strong>参数说明</strong></p><p>id: 线程 id</p><p>[n:]: 指定 CPU 占比最高的前 N 个线程并打印堆栈</p><p>[b]: 找出当前阻塞其他线程的线程</p><p>[i <value>]: 指定 cpu 使用率统计的采样间隔，单位为毫秒，默认值为 200</p><p>[–all]: 显示所有匹配的线程</p><h4 id="排查CPU占比高的线程"><a href="#排查CPU占比高的线程" class="headerlink" title="排查CPU占比高的线程"></a><strong>排查CPU占比高的线程</strong></h4><p>使用 thread -n 命令，例如查询前 3 个最忙的线程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs markdown">[arthas@70]$ thread -n 3<br>&quot;consumer-holder-[<span class="hljs-string">commercialize_sync_topic</span>][<span class="hljs-symbol">c_commercialize_sync_group-lane-PRT.test</span>]-0&quot; Id=1110 cpuUsage=37.22% deltaTime=76ms time=11317ms RUNNABLE (in native)<br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.EPoll.wait(Native Method)</span><br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:120)</span><br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:124)</span><br><span class="hljs-code">......</span><br><span class="hljs-code"></span><br><br>&quot;consumer-holder-[<span class="hljs-string">kwaishop_ecologic_questionnaire_user_submit</span>][<span class="hljs-symbol">c_kwaishop_ecologic_questionnaire_user_submit_merchant_janus-lane-PRT.test</span>]-0#5&quot; Id=1141 cpuUsage=5.99% deltaTime=12ms time=19619ms RUNNABLE (in native)<br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.EPoll.wait(Native Method)</span><br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:120)</span><br><span class="hljs-code">    at java.base@11.0.14-internal/sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:124)</span><br><span class="hljs-code">......</span><br><span class="hljs-code"></span><br><br>&quot;arthas-command-execute&quot; Id=1851 cpuUsage=2.48% deltaTime=5ms time=107ms RUNNABLE<br><span class="hljs-code">    at java.management@11.0.14-internal/sun.management.ThreadImpl.dumpThreads0(Native Method)</span><br><span class="hljs-code">    at java.management@11.0.14-internal/sun.management.ThreadImpl.getThreadInfo(ThreadImpl.java:494)</span><br><span class="hljs-code">    at com.taobao.arthas.core.command.monitor200.ThreadCommand.processTopBusyThreads(ThreadCommand.java:206)</span><br><span class="hljs-code">......</span><br></code></pre></td></tr></table></figure><p>可以附加 -i 属性指定采样时间间隔，例如 thread -n 3 -i 1000 会统计近 1000 ms 内前三个最消耗 CPU 的线程。</p><h4 id="排查阻塞线程"><a href="#排查阻塞线程" class="headerlink" title="排查阻塞线程"></a><strong>排查阻塞线程</strong></h4><p>使用 thread -b 直接查询</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@70</span>]<span class="hljs-variable">$ </span>thread -b<br><span class="hljs-string">&quot;consumer-holder-[invite_call_back_topic][c_invite_call_back_group-lane-PRT.test]-0&quot;</span> <span class="hljs-title class_">Id</span>=<span class="hljs-number">1175</span> <span class="hljs-variable constant_">RUNNABLE</span><br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/sun.nio.ch.<span class="hljs-title class_">EPoll</span>.wait(<span class="hljs-title class_">Native</span> <span class="hljs-title class_">Method</span>)<br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/sun.nio.ch.<span class="hljs-title class_">EPollSelectorImpl</span>.doSelect(<span class="hljs-title class_">EPollSelectorImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">120</span>)<br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/sun.nio.ch.<span class="hljs-title class_">SelectorImpl</span>.lockAndDoSelect(<span class="hljs-title class_">SelectorImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">124</span>)<br>    -  locked sun.nio.ch.<span class="hljs-title class_">Util</span>$<span class="hljs-number">2</span><span class="hljs-variable">@3903b099</span><br>    -  locked sun.nio.ch.<span class="hljs-title class_">EPollSelectorImpl</span><span class="hljs-variable">@494f3bc9</span><br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/sun.nio.ch.<span class="hljs-title class_">SelectorImpl</span>.select(<span class="hljs-title class_">SelectorImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">136</span>)<br>    at org.apache.kafka.common.network.<span class="hljs-title class_">Selector</span>.select(<span class="hljs-title class_">Selector</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">645</span>)<br>    at org.apache.kafka.common.network.<span class="hljs-title class_">Selector</span>.poll(<span class="hljs-title class_">Selector</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">396</span>)<br>    at org.apache.kafka.clients.<span class="hljs-title class_">NetworkClient</span>.poll(<span class="hljs-title class_">NetworkClient</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">430</span>)<br>    at org.apache.kafka.clients.consumer.internals.<span class="hljs-title class_">ConsumerNetworkClient</span>.poll(<span class="hljs-title class_">ConsumerNetworkClient</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">226</span>)<br>    -  locked org.apache.kafka.clients.consumer.internals.<span class="hljs-title class_">ConsumerNetworkClient</span><span class="hljs-variable">@7ad2abea</span> &lt;---- but blocks <span class="hljs-number">1</span> other threads!<br>    at org.apache.kafka.clients.consumer.<span class="hljs-title class_">KafkaConsumer</span>.pollOnceWithCostInfo(<span class="hljs-title class_">KafkaConsumer</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">1256</span>)<br>    at org.apache.kafka.clients.consumer.<span class="hljs-title class_">KafkaConsumer</span>.pollWithCostInfo(<span class="hljs-title class_">KafkaConsumer</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">1095</span>)<br>    at org.apache.kafka.clients.consumer.<span class="hljs-title class_">KafkaConsumer</span>.pollWithCostInfo(<span class="hljs-title class_">KafkaConsumer</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">1130</span>)<br>    at com.kuaishou.framework.kafka.n.<span class="hljs-title class_">KafkaJavaConsumerHolder</span><span class="hljs-variable">$ConsumerHolder</span>.loopPollAndConsume(<span class="hljs-title class_">KafkaJavaConsumerHolder</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">1080</span>)<br>    at com.kuaishou.framework.kafka.n.<span class="hljs-title class_">KafkaJavaConsumerHolder</span><span class="hljs-variable">$ConsumerHolder</span>.<span class="hljs-built_in">lambda</span>$createAndExecuteConsumeTask<span class="hljs-variable">$7</span>(<span class="hljs-title class_">KafkaJavaConsumerHolder</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">920</span>)<br>    at com.kuaishou.framework.kafka.n.<span class="hljs-title class_">KafkaJavaConsumerHolder</span>$<span class="hljs-title class_">ConsumerHolder</span><span class="hljs-variable">$$</span><span class="hljs-title class_">Lambda</span><span class="hljs-variable">$1817</span>/<span class="hljs-number">0x00000008413f4c40</span>.run(<span class="hljs-title class_">Unknown</span> <span class="hljs-title class_">Source</span>)<br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/java.util.concurrent.<span class="hljs-title class_">ThreadPoolExecutor</span>.runWorker(<span class="hljs-title class_">ThreadPoolExecutor</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">1128</span>)<br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/java.util.concurrent.<span class="hljs-title class_">ThreadPoolExecutor</span><span class="hljs-variable">$Worker</span>.run(<span class="hljs-title class_">ThreadPoolExecutor</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">628</span>)<br>    at java.base<span class="hljs-variable">@11</span>.<span class="hljs-number">0.14</span>-internal/java.lang.<span class="hljs-title class_">Thread</span>.run(<span class="hljs-title class_">Thread</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">829</span>)<br><br>    <span class="hljs-title class_">Number</span> of locked synchronizers = <span class="hljs-number">1</span><br>    - java.util.concurrent.<span class="hljs-title class_">ThreadPoolExecutor</span>$<span class="hljs-title class_">Worker</span><span class="hljs-variable">@712</span>0dbac<br></code></pre></td></tr></table></figure><p>可看到当前消费者组线程 “consumer-holder-[invite_call_back_topic][c_invite_call_back_group-lane-PRT.test]-0” 锁定了对象 org.apache.kafka.clients.consumer.internals.ConsumerNetworkClient@7ad2abea，导致阻塞了另外一个线程。</p><h4 id="查询特定线程堆栈"><a href="#查询特定线程堆栈" class="headerlink" title="查询特定线程堆栈"></a><strong>查询特定线程堆栈</strong></h4><p>使用 thread id，查看特定 id 线程的堆栈信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs plain">[arthas@71]$ thread 221<br>&quot;http-nio-8080-exec-1&quot; Id=221 WAITING on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@36bdd6d8<br>    at java.base@11.0.14-internal/jdk.internal.misc.Unsafe.park(Native Method)<br>    -  waiting on java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject@36bdd6d8<br>    at java.base@11.0.14-internal/java.util.concurrent.locks.LockSupport.park(LockSupport.java:194)<br>    at java.base@11.0.14-internal/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2081)<br>    at java.base@11.0.14-internal/java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:433)<br>    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:108)<br>    at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:33)<br>    at java.base@11.0.14-internal/java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1054)<br>    at java.base@11.0.14-internal/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1114)<br>    at java.base@11.0.14-internal/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)<br>    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)<br>    at java.base@11.0.14-internal/java.lang.Thread.run(Thread.java:829)<br></code></pre></td></tr></table></figure><h4 id="查看所有线程"><a href="#查看所有线程" class="headerlink" title="查看所有线程"></a><strong>查看所有线程</strong></h4><p>使用 thread -all 显示所有匹配线程信息</p><h4 id="查看特定状态所有线程"><a href="#查看特定状态所有线程" class="headerlink" title="查看特定状态所有线程"></a><strong>查看特定状态所有线程</strong></h4><p>使用 thread –state xxx，例如：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-a5c2dd3c2a7225fbc52a3722dff9e526.png"></p><h3 id="3-5-trace-命令——查看方法调用链路和执行耗时"><a href="#3-5-trace-命令——查看方法调用链路和执行耗时" class="headerlink" title="3.5 trace 命令——查看方法调用链路和执行耗时"></a><strong>3.5 trace 命令——查看方法调用链路和执行耗时</strong></h3><p>trace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。</p><p><strong>参数说明</strong></p><p>class-pattern: 类名表达式匹配</p><p>method-pattern: 方法名表达式匹配</p><p>condition-express: 条件表达式</p><p>[E]: 开启正则表达式匹配，默认为通配符匹配</p><p>[n:]: 命令执行次数</p><p>#cost: 方法执行耗时</p><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a><strong>简单示例</strong></h4><p>一个简单的示例如下，可以观察到耗时的操作在 ChatService#chat 和 KimService#sendTextMessage 两个方法内。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>trace com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.<span class="hljs-title class_">ChatConsumeHandler</span> handler<br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">346</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">16</span><br><span class="hljs-string">`---ts=2023-05-04 14:16:36;thread_name=UNI_c_answerize_chat_topic_22;id=765;is_daemon=false;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@749ab7b4</span><br><span class="hljs-string">    `</span>---[<span class="hljs-number">1833</span>.242546ms] com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.<span class="hljs-title class_">ChatConsumeHandler</span><span class="hljs-symbol">:handler</span>()<br>        +---[<span class="hljs-number">0</span>.035623ms] kuaishou.kwaishop.merchant.invite.center.<span class="hljs-title class_">AnswerizeMsgDto</span><span class="hljs-variable">$AnswerizeFlowMsg</span><span class="hljs-symbol">:getUser</span>() <span class="hljs-comment">#37</span><br>        +---[<span class="hljs-number">0</span>.017509ms] kuaishou.kwaishop.merchant.invite.center.<span class="hljs-title class_">AnswerizeMsgDto</span><span class="hljs-variable">$AnswerizeFlowMsg</span><span class="hljs-symbol">:getExtra</span>() <span class="hljs-comment">#38</span><br>        +---[<span class="hljs-number">0</span>.120501ms] com.kuaishou.framework.util.<span class="hljs-title class_">ObjectMapperUtils</span><span class="hljs-symbol">:fromJson</span>() <span class="hljs-comment">#40</span><br>        +---[<span class="hljs-number">0</span>.039254ms] org.apache.commons.lang3.<span class="hljs-title class_">StringUtils</span><span class="hljs-symbol">:isEmpty</span>() <span class="hljs-comment">#44</span><br>        +---[<span class="hljs-number">1522</span>.793878ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.<span class="hljs-title class_">ChatService</span><span class="hljs-symbol">:chat</span>() <span class="hljs-comment">#47</span><br>        +---[<span class="hljs-number">0</span>.03056ms] com.kuaishou.kwaishop.merchant.answerize.center.common.util.<span class="hljs-title class_">KimOpenUtil</span><span class="hljs-symbol">:msgParamConvertor</span>() <span class="hljs-comment">#48</span><br>        +---[<span class="hljs-number">0</span>.059335ms] com.kuaishou.kwaishop.merchant.answerize.center.core.config.kconf.<span class="hljs-title class_">MerchantAnswerizeMapConfigKey</span><span class="hljs-symbol">:get</span>() <span class="hljs-comment">#51</span><br>        +---[<span class="hljs-number">0</span>.023643ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-symbol">:builder</span>() <span class="hljs-comment">#52</span><br>        +---[<span class="hljs-number">0</span>.021792ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:appKey</span>() <span class="hljs-comment">#53</span><br>        +---[<span class="hljs-number">0</span>.019118ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:appSecret</span>() <span class="hljs-comment">#54</span><br>        +---[<span class="hljs-number">0</span>.014695ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:param</span>() <span class="hljs-comment">#55</span><br>        +---[<span class="hljs-number">0</span>.017362ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:groupId</span>() <span class="hljs-comment">#56</span><br>        +---[<span class="hljs-number">0</span>.0151ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:userName</span>() <span class="hljs-comment">#57</span><br>        +---[<span class="hljs-number">0</span>.016715ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:sendType</span>() <span class="hljs-comment">#58</span><br>        +---[<span class="hljs-number">0</span>.027505ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:build</span>() <span class="hljs-comment">#59</span><br>        <span class="hljs-string">`---[309.269577ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.KimService:sendTextMessage() #61</span><br></code></pre></td></tr></table></figure><h4 id="多层-trace"><a href="#多层-trace" class="headerlink" title="多层 trace"></a><strong>多层 trace</strong></h4><p>可见 trace 命令只会 trace 匹配到的函数里的子调用，并不会向下 trace 多层。为了实现 trace  多层的效果，可以使用 -E 参数开启正则表达式匹配，从而用正则表达式匹配路径上的多个类和函数，一定程度上达到多层 trace 的效果，以下跟踪了handler() 方法中调用的 ChatService#chat 方法，以及 chat() 内部调用的 ChatServiceImpl#chatNormalConversation 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plain">[arthas@71]$ trace -E com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.ChatConsumeHandler|com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl handler|chat|chatNormalConversation<br>Press Q or Ctrl+C to abort.<br>Affect(class count: 2 , method count: 3) cost in 562 ms, listenerId: 18<br>`---ts=2023-05-04 14:34:05;thread_name=UNI_c_answerize_chat_topic_24;id=795;is_daemon=false;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@749ab7b4<br>    `---[1872.237546ms] com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.ChatConsumeHandler:handler()<br>        +---[0.01762ms] kuaishou.kwaishop.merchant.invite.center.AnswerizeMsgDto$AnswerizeFlowMsg:getUser() #37<br>        +---[0.00891ms] kuaishou.kwaishop.merchant.invite.center.AnswerizeMsgDto$AnswerizeFlowMsg:getExtra() #38<br>        +---[0.107442ms] com.kuaishou.framework.util.ObjectMapperUtils:fromJson() #40<br>        +---[0.040396ms] org.apache.commons.lang3.StringUtils:isEmpty() #44<br>        +---[1151.319768ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.ChatService:chat() #47<br>        |   `---[1151.257163ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl:chat()<br>        |       +---[12.101286ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.HistoryManageService:queryHistoryByUser() #50<br>        |       +---[0.032386ms] org.apache.commons.collections4.CollectionUtils:isEmpty() #51<br>        |       +---[0.025957ms] org.apache.commons.lang3.StringUtils:isEmpty() #58<br>        |       `---[1139.019001ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl:chatNormalConversation() #59<br>        |           `---[1138.955373ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl:chatNormalConversation()<br>        |               +---[0.024002ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO:builder() #117<br>        |               +---[0.019647ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO$Role:getName() #118<br>        |               +---[0.017317ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO$MessageDTOBuilder:role() #95<br>        |               +---[0.018757ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO$MessageDTOBuilder:content() #119<br>        |               +---[0.014803ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO$MessageDTOBuilder:build() #120<br>        |               +---[0.012072ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.ChatCompletionDTO$Model:getName() #123<br>        |               +---[2.446956ms] com.kuaishou.kwaishop.merchant.answerize.center.common.util.TikTokensUtil:tokens() #95<br>        |               +---[0.019998ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.ChatCompletionDTO$Model:getMaxToken() #124<br>        |               +---[1129.891215ms] com.kuaishou.kwaishop.merchant.answerize.center.client.client.OpenAIClient:chatCompletion() #127<br>        |               +---[0.028956ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.ChatCompletionResponseDTO:getChoices() #128<br>        |               +---[0.023938ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.ChatChoice:getMessageDTO() #95<br>        |               +---[6.006524ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.HistoryManageService:updateUserHistory() #131<br>        |               `---[0.017471ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO:getContent() #134<br>        +---[0.016075ms] com.kuaishou.kwaishop.merchant.answerize.center.common.util.KimOpenUtil:msgParamConvertor() #48<br>        +---[0.03273ms] com.kuaishou.kwaishop.merchant.answerize.center.core.config.kconf.MerchantAnswerizeMapConfigKey:get() #51<br>        +---[0.014531ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest:builder() #52<br>        +---[0.011929ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:appKey() #53<br>        +---[0.009899ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:appSecret() #54<br>        +---[0.012046ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:param() #55<br>        +---[0.009794ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:groupId() #56<br>        +---[0.009603ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:userName() #57<br>        +---[0.009825ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:sendType() #58<br>        +---[0.010477ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.KimRequest$KimRequestBuilder:build() #59<br>        `---[720.206435ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.KimService:sendTextMessage() #61<br></code></pre></td></tr></table></figure><h4 id="限制trace条件"><a href="#限制trace条件" class="headerlink" title="限制trace条件"></a><strong>限制trace条件</strong></h4><p>为了防止采集到大量结果，可以使用 -n 和 #cost 来进行采集结果数量的限定和耗时条件的限定，例如下面这个例子将只采集耗时大于 3000ms 的第一次调用，之后便会直接退出命令：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>trace com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.<span class="hljs-title class_">ChatConsumeHandler</span> handler -n <span class="hljs-number">1</span> <span class="hljs-string">&#x27;#cost &gt; 3000&#x27;</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">252</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">21</span><br><span class="hljs-string">`---ts=2023-05-04 14:47:23;thread_name=UNI_c_answerize_chat_topic_27;id=7ba;is_daemon=false;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@749ab7b4</span><br><span class="hljs-string">    `</span>---[<span class="hljs-number">6064</span>.372975ms] com.kuaishou.kwaishop.merchant.answerize.center.core.handler.consume.<span class="hljs-title class_">ChatConsumeHandler</span><span class="hljs-symbol">:handler</span>()<br>        +---[<span class="hljs-number">0</span>.020583ms] kuaishou.kwaishop.merchant.invite.center.<span class="hljs-title class_">AnswerizeMsgDto</span><span class="hljs-variable">$AnswerizeFlowMsg</span><span class="hljs-symbol">:getUser</span>() <span class="hljs-comment">#37</span><br>        +---[<span class="hljs-number">0</span>.012811ms] kuaishou.kwaishop.merchant.invite.center.<span class="hljs-title class_">AnswerizeMsgDto</span><span class="hljs-variable">$AnswerizeFlowMsg</span><span class="hljs-symbol">:getExtra</span>() <span class="hljs-comment">#38</span><br>        +---[<span class="hljs-number">0</span>.094053ms] com.kuaishou.framework.util.<span class="hljs-title class_">ObjectMapperUtils</span><span class="hljs-symbol">:fromJson</span>() <span class="hljs-comment">#40</span><br>        +---[<span class="hljs-number">0</span>.017264ms] org.apache.commons.lang3.<span class="hljs-title class_">StringUtils</span><span class="hljs-symbol">:isEmpty</span>() <span class="hljs-comment">#44</span><br>        +---[<span class="hljs-number">5727</span>.814648ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.<span class="hljs-title class_">ChatService</span><span class="hljs-symbol">:chat</span>() <span class="hljs-comment">#47</span><br>        +---[<span class="hljs-number">0</span>.016821ms] com.kuaishou.kwaishop.merchant.answerize.center.common.util.<span class="hljs-title class_">KimOpenUtil</span><span class="hljs-symbol">:msgParamConvertor</span>() <span class="hljs-comment">#48</span><br>        +---[<span class="hljs-number">0</span>.036667ms] com.kuaishou.kwaishop.merchant.answerize.center.core.config.kconf.<span class="hljs-title class_">MerchantAnswerizeMapConfigKey</span><span class="hljs-symbol">:get</span>() <span class="hljs-comment">#51</span><br>        +---[<span class="hljs-number">0</span>.037161ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-symbol">:builder</span>() <span class="hljs-comment">#52</span><br>        +---[<span class="hljs-number">0</span>.011403ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:appKey</span>() <span class="hljs-comment">#53</span><br>        +---[<span class="hljs-number">0</span>.01047ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:appSecret</span>() <span class="hljs-comment">#54</span><br>        +---[<span class="hljs-number">0</span>.016492ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:param</span>() <span class="hljs-comment">#55</span><br>        +---[<span class="hljs-number">0</span>.010732ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:groupId</span>() <span class="hljs-comment">#56</span><br>        +---[<span class="hljs-number">0</span>.007971ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:userName</span>() <span class="hljs-comment">#57</span><br>        +---[<span class="hljs-number">0</span>.010299ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:sendType</span>() <span class="hljs-comment">#58</span><br>        +---[<span class="hljs-number">0</span>.011872ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.kim.<span class="hljs-title class_">KimRequest</span><span class="hljs-variable">$KimRequestBuilder</span><span class="hljs-symbol">:build</span>() <span class="hljs-comment">#59</span><br>        <span class="hljs-string">`---[335.348733ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.KimService:sendTextMessage() #61</span><br><span class="hljs-string"></span><br><span class="hljs-string">Command execution times exceed limit: 1, so command will exit. You can set it with -n option.</span><br></code></pre></td></tr></table></figure><p>也可如前“watch”命令所示，使用更为复杂的条件语句进行条件限制。</p><h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a><strong>通配符匹配</strong></h4><p>trace 默认采用通配符匹配，下面的示例中，将会匹配 ChatServiceImpl 内 chat* 的方法，可见其进行了两层 trace</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>trace com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat* -n <span class="hljs-number">1</span> <span class="hljs-string">&#x27;#cost &gt; 3000&#x27;</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">3</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">305</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">22</span><br><span class="hljs-string">`---ts=2023-05-04 14:51:18;thread_name=UNI_c_answerize_chat_topic_29;id=7cf;is_daemon=false;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@749ab7b4</span><br><span class="hljs-string">    `</span>---[<span class="hljs-number">4986</span>.447081ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span><span class="hljs-symbol">:chat</span>()<br>        +---[<span class="hljs-number">6</span>.610857ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.<span class="hljs-title class_">HistoryManageService</span><span class="hljs-symbol">:queryHistoryByUser</span>() <span class="hljs-comment">#50</span><br>        +---[<span class="hljs-number">0</span>.00605ms] org.apache.commons.collections4.<span class="hljs-title class_">CollectionUtils</span><span class="hljs-symbol">:isEmpty</span>() <span class="hljs-comment">#51</span><br>        +---[<span class="hljs-number">0</span>.004414ms] org.apache.commons.lang3.<span class="hljs-title class_">StringUtils</span><span class="hljs-symbol">:isEmpty</span>() <span class="hljs-comment">#58</span><br>        <span class="hljs-string">`---[4979.744882ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl:chatNormalConversation() #59</span><br><span class="hljs-string">            `</span>---[<span class="hljs-number">4979</span>.709312ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span><span class="hljs-symbol">:chatNormalConversation</span>()<br>                +---[<span class="hljs-number">0</span>.007337ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">Message</span><span class="hljs-symbol">DTO:</span>builder() <span class="hljs-comment">#117</span><br>                +---[<span class="hljs-number">0</span>.005473ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">Message</span>DTO<span class="hljs-variable">$Role</span><span class="hljs-symbol">:getName</span>() <span class="hljs-comment">#118</span><br>                +---[<span class="hljs-number">0</span>.006898ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">Message</span>DTO<span class="hljs-variable">$MessageDTOBuilder</span><span class="hljs-symbol">:role</span>() <span class="hljs-comment">#95</span><br>                +---[<span class="hljs-number">0</span>.007451ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">Message</span>DTO<span class="hljs-variable">$MessageDTOBuilder</span><span class="hljs-symbol">:content</span>() <span class="hljs-comment">#119</span><br>                +---[<span class="hljs-number">0</span>.005921ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">Message</span>DTO<span class="hljs-variable">$MessageDTOBuilder</span><span class="hljs-symbol">:build</span>() <span class="hljs-comment">#120</span><br>                +---[<span class="hljs-number">0</span>.004486ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">ChatCompletion</span>DTO<span class="hljs-variable">$Model</span><span class="hljs-symbol">:getName</span>() <span class="hljs-comment">#123</span><br>                +---[<span class="hljs-number">2</span>.528856ms] com.kuaishou.kwaishop.merchant.answerize.center.common.util.<span class="hljs-title class_">TikTokensUtil</span><span class="hljs-symbol">:tokens</span>() <span class="hljs-comment">#95</span><br>                +---[<span class="hljs-number">0</span>.005295ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">ChatCompletion</span>DTO<span class="hljs-variable">$Model</span><span class="hljs-symbol">:getMaxToken</span>() <span class="hljs-comment">#124</span><br>                +---[<span class="hljs-number">4970</span>.527234ms] com.kuaishou.kwaishop.merchant.answerize.center.client.client.<span class="hljs-title class_">OpenAIClient</span><span class="hljs-symbol">:chatCompletion</span>() <span class="hljs-comment">#127</span><br>                +---[<span class="hljs-number">0</span>.0063ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">ChatCompletionResponse</span><span class="hljs-symbol">DTO:</span>getChoices() <span class="hljs-comment">#128</span><br>                +---[<span class="hljs-number">0</span>.006029ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">ChatChoice</span><span class="hljs-symbol">:getMessageDTO</span>() <span class="hljs-comment">#95</span><br>                +---[<span class="hljs-number">6</span>.438786ms] com.kuaishou.kwaishop.merchant.answerize.center.core.service.<span class="hljs-title class_">HistoryManageService</span><span class="hljs-symbol">:updateUserHistory</span>() <span class="hljs-comment">#131</span><br>                <span class="hljs-string">`---[0.00694ms] com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.MessageDTO:getContent() #134</span><br><span class="hljs-string"></span><br><span class="hljs-string">Command execution times exceed limit: 1, so command will exit. You can set it with -n option.</span><br></code></pre></td></tr></table></figure><p>默认 trace 会跳过 jdk 中的方法，如 toString() 等，使用 –skipJDKMethod false 关闭跳过。</p><h4 id="动态trace"><a href="#动态trace" class="headerlink" title="动态trace"></a>动态trace</h4><ol><li><p>打开终端 1，trace 上面 demo 里的<code>run</code>函数，可以看到打印出 <code>listenerId: 1</code></p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">[arthas@<span class="hljs-number">59161</span>]$ trace demo.MathGame run<br>Press Q <span class="hljs-keyword">or</span> Ctrl+C <span class="hljs-keyword">to</span> abort.<br>Affect(<span class="hljs-keyword">class</span> count: <span class="hljs-number">1</span> , <span class="hljs-keyword">method</span> <span class="hljs-title function_">count</span>: <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">112</span> ms, listenerId: <span class="hljs-number">1</span><br>`---ts=<span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">09</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">11</span><span class="hljs-punctuation">;</span>thread_name=main<span class="hljs-punctuation">;</span>id=<span class="hljs-number">1</span><span class="hljs-punctuation">;</span>is_daemon=<span class="hljs-keyword">false</span><span class="hljs-punctuation">;</span>priority=<span class="hljs-number">5</span><span class="hljs-punctuation">;</span>TCCL=sun.misc.Launcher$AppClassLoader@<span class="hljs-number">3</span>d4eac69<br>    `---[<span class="hljs-number">1.389634</span>ms] demo.MathGame:run()<br>        `---[<span class="hljs-number">0.123934</span>ms] demo.MathGame:primeFactors() <span class="hljs-string">#24</span> [throws Exception]<br><br>`---ts=<span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">09</span> <span class="hljs-number">16</span>:<span class="hljs-number">48</span>:<span class="hljs-number">12</span><span class="hljs-punctuation">;</span>thread_name=main<span class="hljs-punctuation">;</span>id=<span class="hljs-number">1</span><span class="hljs-punctuation">;</span>is_daemon=<span class="hljs-keyword">false</span><span class="hljs-punctuation">;</span>priority=<span class="hljs-number">5</span><span class="hljs-punctuation">;</span>TCCL=sun.misc.Launcher$AppClassLoader@<span class="hljs-number">3</span>d4eac69<br>    `---[<span class="hljs-number">3.716391</span>ms] demo.MathGame:run()<br>        +---[<span class="hljs-number">3.182813</span>ms] demo.MathGame:primeFactors() <span class="hljs-string">#24</span><br>        `---[<span class="hljs-number">0.167786</span>ms] demo.MathGame:print() <span class="hljs-string">#25</span><br><br></code></pre></td></tr></table></figure></li><li><p>现在想要深入子函数<code>primeFactors</code>，可以打开一个新终端 2，使用<code>telnet localhost 3658</code>连接上 arthas,再 trace <code>primeFactors</code>时，指定<code>listenerId</code>。这时终端 2 打印的结果，说明已经增强了一个函数：<code>Affect(class count: 1 , method count: 1)</code>，但不再打印更多的结果。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[arthas@59161]</span>$ trace demo.MathGame primeFactors --listenerId <span class="hljs-number">1</span><br>Press Q <span class="hljs-keyword">or</span> Ctrl+C to abort.<br>Affect(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count: <span class="hljs-symbol">1</span></span> , <span class="hljs-symbol">method</span> <span class="hljs-symbol">count: <span class="hljs-symbol">1</span></span>) <span class="hljs-symbol">cost</span> <span class="hljs-symbol">in</span> <span class="hljs-symbol">34</span> <span class="hljs-symbol">ms, <span class="hljs-symbol">listenerId</span>: <span class="hljs-symbol">1</span></span><br><br></code></pre></td></tr></table></figure></li><li><p>再查看终端 1，可以发现 trace 的结果增加了一层，打印了<code>primeFactors</code>函数里的内容：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">`<span class="hljs-params">---ts=2020-07-09</span> 16<span class="hljs-function">:49</span><span class="hljs-function">:29</span>;thread_name=main;id=1;is_daemon=<span class="hljs-literal">false</span>;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69<br>    `<span class="hljs-params">---</span>[0.492551ms] demo.MathGame<span class="hljs-function">:run</span><span class="hljs-params">()</span><br>        `<span class="hljs-params">---</span>[0.113929ms] demo.MathGame<span class="hljs-function">:primeFactors</span><span class="hljs-params">()</span> <span class="hljs-comment">#24 [throws Exception]</span><br>            `<span class="hljs-params">---</span>[0.061462ms] demo.MathGame<span class="hljs-function">:primeFactors</span><span class="hljs-params">()</span><br>                `<span class="hljs-params">---</span>[0.001018ms] throw<span class="hljs-function">:java.lang.IllegalArgumentException</span><span class="hljs-params">()</span> <span class="hljs-comment">#46</span><br><br>`<span class="hljs-params">---ts=2020-07-09</span> 16<span class="hljs-function">:49</span><span class="hljs-function">:30</span>;thread_name=main;id=1;is_daemon=<span class="hljs-literal">false</span>;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69<br>    `<span class="hljs-params">---</span>[0.409446ms] demo.MathGame<span class="hljs-function">:run</span><span class="hljs-params">()</span><br>        +<span class="hljs-params">---</span>[0.232606ms] demo.MathGame<span class="hljs-function">:primeFactors</span><span class="hljs-params">()</span> <span class="hljs-comment">#24</span><br>        |   `<span class="hljs-params">---</span>[0.1294ms] demo.MathGame<span class="hljs-function">:primeFactors</span><span class="hljs-params">()</span><br>        `<span class="hljs-params">---</span>[0.084025ms] demo.MathGame<span class="hljs-function">:print</span><span class="hljs-params">()</span> <span class="hljs-comment">#25</span><br><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-6-stack-命令——查看方法调用堆栈"><a href="#3-6-stack-命令——查看方法调用堆栈" class="headerlink" title="3.6 stack 命令——查看方法调用堆栈"></a><strong>3.6 stack 命令——查看方法调用堆栈</strong></h3><p>有时不仅仅想知道当前方法的情况，也想知道是谁调用了当前方法，此时可以查看方法的调用堆栈。</p><p>其使用方法和 watch 及 trace 类似，均可使用条件表达式进行有选择性的查看调用堆栈，参数说明为：</p><p><strong>参数说明</strong></p><p>class-pattern: 类名表达式匹配</p><p>method-pattern: 方法名表达式匹配</p><p>condition-express: 条件表达式</p><p>[E]: 开启正则表达式匹配，默认为通配符匹配</p><p>[n:]: 执行次数限制</p><p>一个简单的示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@70</span>]<span class="hljs-variable">$ </span>stack com.kuaishou.kwaishop.merchant.janus.center.core.service.impl.brand.<span class="hljs-title class_">ShopBrandInternalServiceImpl</span> getTradeMarks  -n <span class="hljs-number">1</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">654</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">3</span><br>ts=<span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">14</span><span class="hljs-symbol">:</span><span class="hljs-number">40</span><span class="hljs-symbol">:</span><span class="hljs-number">05</span>;thread_name=krpc-server-worker-<span class="hljs-number">25</span>;id=<span class="hljs-number">515</span>;is_daemon=<span class="hljs-literal">true</span>;priority=<span class="hljs-number">5</span>;<span class="hljs-variable constant_">TCCL</span>=org.springframework.boot.loader.<span class="hljs-title class_">LaunchedURLClassLoader</span><span class="hljs-variable">@6433a2</span><br>    <span class="hljs-variable">@com</span>.kuaishou.kwaishop.merchant.janus.center.core.service.impl.brand.<span class="hljs-title class_">ShopBrandInternalServiceImpl</span>.getTradeMarks()<br>        at com.kuaishou.kwaishop.merchant.janus.center.core.service.impl.brand.<span class="hljs-title class_">ShopBrandInternalServiceImpl</span>.getShopBrandBaseByBrandIds(<span class="hljs-title class_">ShopBrandInternalServiceImpl</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">854</span>)<br>        at com.kuaishou.kwaishop.merchant.janus.center.core.krpc.brand.<span class="hljs-title class_">ShopBrandKRpcService</span>.getShopBrandBaseByBrandIds(<span class="hljs-title class_">ShopBrandKRpcService</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">498</span>)<br>        at com.kuaishou.kwaishop.merchant.janus.center.core.krpc.brand.<span class="hljs-title class_">ShopBrandKRpcService</span><span class="hljs-variable">$$</span><span class="hljs-title class_">FastClassBySpring</span>CGLIB<span class="hljs-variable">$$</span>c4da3140.invoke(&lt;generated&gt;<span class="hljs-symbol">:-</span><span class="hljs-number">1</span>)<br>        at org.springframework.cglib.proxy.<span class="hljs-title class_">MethodProxy</span>.invoke(<span class="hljs-title class_">MethodProxy</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">218</span>)<br>        at org.springframework.aop.framework.<span class="hljs-title class_">CglibAopProxy</span><span class="hljs-variable">$CglibMethodInvocation</span>.invokeJoinpoint(<span class="hljs-title class_">CglibAopProxy</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">750</span>)<br>        at org.springframework.aop.framework.<span class="hljs-title class_">ReflectiveMethodInvocation</span>.proceed(<span class="hljs-title class_">ReflectiveMethodInvocation</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">163</span>)<br>        at org.springframework.aop.aspectj.<span class="hljs-title class_">MethodInvocationProceedingJoinPoint</span>.proceed(<span class="hljs-title class_">MethodInvocationProceedingJoinPoint</span>.<span class="hljs-symbol">java:</span><span class="hljs-number">88</span>)<br>  ......<br><span class="hljs-title class_">Command</span> execution times exceed <span class="hljs-symbol">limit:</span> <span class="hljs-number">1</span>, so command will exit. <span class="hljs-title class_">You</span> can set it with -n option.<br></code></pre></td></tr></table></figure><h3 id="3-7-monitor-命令——监控方法执行情况"><a href="#3-7-monitor-命令——监控方法执行情况" class="headerlink" title="3.7 monitor 命令——监控方法执行情况"></a><strong>3.7 monitor 命令——监控方法执行情况</strong></h3><p>这个命令可以实时监控方法的执行成功次数和执行失败率</p><p><strong>监控项说明</strong></p><p>timestamp: 时间戳</p><p>class: Java 类</p><p>method: 方法（构造方法、普通方法）</p><p>total: 调用次数</p><p>success: 成功次数</p><p>fail: 失败次数</p><p>avg-rt: 平均 RT</p><p>fail-rate: 失败率</p><p>使用 -c 10 限定统计周期为 10 秒，-n 2 表示只监控两个周期</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@70</span>]<span class="hljs-variable">$ </span>monitor com.kuaishou.kwaishop.merchant.janus.center.core.krpc.category.<span class="hljs-title class_">MerchantShopCategoryLimitKRpcService</span> isUserPassCategoryLimit  -n <span class="hljs-number">2</span>  -c <span class="hljs-number">10</span><br><span class="hljs-title class_">Press</span> Q <span class="hljs-keyword">or</span> <span class="hljs-title class_">Ctrl</span>+C to abort.<br><span class="hljs-title class_">Affect</span>(<span class="hljs-keyword">class</span> <span class="hljs-symbol">count:</span> <span class="hljs-number">2</span> , method <span class="hljs-symbol">count:</span> <span class="hljs-number">2</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">1182</span> ms, <span class="hljs-symbol">listenerId:</span> <span class="hljs-number">5</span><br> timestamp                    <span class="hljs-keyword">class</span>                                                      method                     total      success      fail        avg-rt(ms)      fail-rate<br>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br> <span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">15</span><span class="hljs-symbol">:</span><span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">54</span>          com.kuaishou.kwaishop.merchant.janus.center.core.krpc.cat  isUserPassCategoryLimit    <span class="hljs-number">4</span>          <span class="hljs-number">4</span>            <span class="hljs-number">0</span>           <span class="hljs-number">26.10</span>           <span class="hljs-number">0.00</span>%<br>                              egory.<span class="hljs-title class_">MerchantShopCategoryLimitKRpcService</span><br> <span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">15</span><span class="hljs-symbol">:</span><span class="hljs-number">21</span><span class="hljs-symbol">:</span><span class="hljs-number">54</span>          com.kuaishou.kwaishop.merchant.janus.center.core.krpc.cat  isUserPassCategoryLimit    <span class="hljs-number">4</span>          <span class="hljs-number">4</span>            <span class="hljs-number">0</span>           <span class="hljs-number">27.41</span>           <span class="hljs-number">0.00</span>%<br>                              egory.<span class="hljs-title class_">MerchantShopCategoryLimitKRpcService</span><span class="hljs-variable">$$</span><span class="hljs-title class_">EnhancerBySpr</span><br>                              ingCGLIB<span class="hljs-variable">$$</span>5395b8d6<br><br> timestamp                    <span class="hljs-keyword">class</span>                                                      method                     total      success      fail        avg-rt(ms)      fail-rate<br>-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br> <span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">15</span><span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span>          com.kuaishou.kwaishop.merchant.janus.center.core.krpc.cat  isUserPassCategoryLimit    <span class="hljs-number">2</span>          <span class="hljs-number">2</span>            <span class="hljs-number">0</span>           <span class="hljs-number">18.29</span>           <span class="hljs-number">0.00</span>%<br>                              egory.<span class="hljs-title class_">MerchantShopCategoryLimitKRpcService</span><br> <span class="hljs-number">2023</span>-<span class="hljs-number">05</span>-<span class="hljs-number">05</span> <span class="hljs-number">15</span><span class="hljs-symbol">:</span><span class="hljs-number">22</span><span class="hljs-symbol">:</span><span class="hljs-number">04</span>          com.kuaishou.kwaishop.merchant.janus.center.core.krpc.cat  isUserPassCategoryLimit    <span class="hljs-number">2</span>          <span class="hljs-number">2</span>            <span class="hljs-number">0</span>           <span class="hljs-number">18.65</span>           <span class="hljs-number">0.00</span>%<br>                              egory.<span class="hljs-title class_">MerchantShopCategoryLimitKRpcService</span><span class="hljs-variable">$$</span><span class="hljs-title class_">EnhancerBySpr</span><br>                              ingCGLIB<span class="hljs-variable">$$</span>5395b8d6<br></code></pre></td></tr></table></figure><h3 id="3-8-tt-命令——方法执行数据的时空隧道"><a href="#3-8-tt-命令——方法执行数据的时空隧道" class="headerlink" title="3.8 tt 命令——方法执行数据的时空隧道"></a><strong>3.8 tt 命令——方法执行数据的时空隧道</strong></h3><p>watch 和 trace 命令虽然很方便和灵活，但需要提前想清楚观察表达式，因为很多时候并不清楚问题在哪里，只能靠蛛丝马迹进行猜测。所以此时若能记录下当时方法调用的所有入参和返回值、抛出的异常等信息，会对整个问题的思考与判断非常有帮助。</p><p><strong>参数说明</strong></p><p>class-pattern: 类名表达式匹配</p><p>method-pattern: 方法名表达式匹配</p><p>condition-express: 条件表达式</p><p>[t]: 开启记录模式</p><p>[l]: 列出当前所有时间片记录</p><p>[s]: 对时间片记录进行搜索筛选</p><p>[i]: 对某一时间片查看详细调用信息</p><p>[p]: 重做调用，通常可配合 –replay-times 指定调用次数，通过 –replay-interval 指定多次调用间隔 (单位 ms, 默认 1000ms)</p><p>[w]: 观察时空隧道</p><p>[E]: 开启正则表达式匹配，默认为通配符匹配</p><p>[n:]: 执行次数限制</p><p>借用插件可以快捷生成命令：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-09ae7f17ef7d36924115febc791dca27.png"></p><p>下面是一个示例：</p><h4 id="采集信息"><a href="#采集信息" class="headerlink" title="采集信息"></a><strong>采集信息</strong></h4><p>下面采集了 ChatServiceImpl#chatNormalConversation 方法的 5 次调用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[arthas@71]$ </span><span class="language-bash">tt -t com.kuaishou.kwaishop.merchant.answerize.center.core.service.ChatService chat -n 5</span><br>Press Q or Ctrl+C to abort.<br>Affect(class count: 2 , method count: 1) cost in 436 ms, listenerId: 75<br> INDEX           TIMESTAMP                               COST(ms)           IS-RET          IS-EXP          OBJECT                CLASS                         METHOD<br>----------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br> 1011            2023-05-05 16:15:52                     1572.648716        true            false           0x7469e76f            ChatServiceImpl               chat<br> 1012            2023-05-05 16:16:20                     8623.702255        true            false           0x7469e76f            ChatServiceImpl               chat<br> 1013            2023-05-05 16:16:54                     3600.742563        true            false           0x7469e76f            ChatServiceImpl               chat<br> 1014            2023-05-05 16:18:53                     6.255935           false           true            0x7469e76f            ChatServiceImpl               chat<br> 1015            2023-05-05 16:19:08                     978.456102         true            false           0x7469e76f            ChatServiceImpl               chat<br>Command execution times exceed limit: 5, so command will exit. You can set it with -n option.<br></code></pre></td></tr></table></figure><p>其中 INDEX 为该时间片的唯一标识，IS-RET 为 true 表示该方法正常返回，IS-EXP 为 true 表示该方法抛出异常。</p><h4 id="查看时间片信息"><a href="#查看时间片信息" class="headerlink" title="查看时间片信息"></a><strong>查看时间片信息</strong></h4><p>查看上面非正常返回的一次调用的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[arthas@71]$ </span><span class="language-bash">tt -i 1014</span><br> INDEX            1014<br> GMT-CREATE       2023-05-05 16:18:53<br> COST(ms)         6.255935<br> OBJECT           0x7469e76f<br> CLASS            com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl<br> METHOD           chat<br> IS-RETURN        false<br> IS-EXCEPTION     true<br> PARAMETERS[0]    @String[yanghao12]<br> PARAMETERS[1]    @String[hello]<br> PARAMETERS[2]    @String[invite]<br> THROW-EXCEPTION  com.kuaishou.kwaishop.merchant.answerize.center.common.exception.AnswerizeBaseException: 目前没有对应领域存在<br>                        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chatDomainConversation(ChatServiceImpl.java:139)<br>                        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chat(ChatServiceImpl.java:61)<br>                        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>                        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>                        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>......<br></code></pre></td></tr></table></figure><p>使用 -w 对该时间片进行观察</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">[arthas@71]$ </span><span class="language-bash">tt -w <span class="hljs-string">&#x27;&#123;method.name,params,returnObj,throwExp&#125;&#x27;</span> -x 3 -i 1014</span><br>@ArrayList[<br>    @String[chat],<br>    @Object[][<br>        @String[yanghao12],<br>        @String[hello],<br>        @String[invite],<br>    ],<br>    null,<br>    com.kuaishou.kwaishop.merchant.answerize.center.common.exception.AnswerizeBaseException: 目前没有对应领域存在<br>        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chatDomainConversation(ChatServiceImpl.java:139)<br>        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chat(ChatServiceImpl.java:61)<br>        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>  ......<br>,<br>]<br>Affect(row-cnt:1) cost in 3 ms.<br></code></pre></td></tr></table></figure><h4 id="重新调用，返回现场"><a href="#重新调用，返回现场" class="headerlink" title="重新调用，返回现场"></a><strong>重新调用，返回现场</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plain">[arthas@71]$ tt -p -i 1014<br> RE-INDEX         1014<br> GMT-REPLAY       2023-05-05 16:25:24<br> OBJECT           0x7469e76f<br> CLASS            com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl<br> METHOD           chat<br> PARAMETERS[0]    @String[yanghao12]<br> PARAMETERS[1]    @String[hello]<br> PARAMETERS[2]    @String[invite]<br> IS-RETURN        false<br> IS-EXCEPTION     true<br> THROW-EXCEPTION  com.kuaishou.kwaishop.merchant.answerize.center.common.exception.AnswerizeBaseException: 目前没有对应领域存在<br>                        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chatDomainConversation(ChatServiceImpl.java:139)<br>                        at com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.ChatServiceImpl.chat(ChatServiceImpl.java:61)<br>                        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>                        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>                        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)<br>......<br></code></pre></td></tr></table></figure><h3 id="3-9-jvm-相关命令——查看当前-JVM-信息"><a href="#3-9-jvm-相关命令——查看当前-JVM-信息" class="headerlink" title="3.9 jvm  相关命令——查看当前 JVM 信息"></a><strong>3.9 jvm  相关命令——查看当前 JVM 信息</strong></h3><p><strong>dashboard——当前系统的实时数据面板，包含JVM线程、内存信息</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-98c85e18000df0c2162f651254229e40.png"></p><p><strong>jvm——查看当前 JVM 的信息</strong></p><p><strong>可以查看到JVM运行时信息、类加载器、垃圾收集、内存分布及占用、线程信息</strong></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-6b67276bafa40a45b648f408dad816f3.png"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-7db7e8b2409d1b83f7e7c504f6545db5.png"><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/1685359435-0279ae777c2b029ebcb016b21fa88e29.png"></p><p><strong>sc——查看JVM已加载的类信息（-d 查看详细信息，-f 查看 field）</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">[arthas@<span class="hljs-number">70</span>]$ sc com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.KconfSupplier<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.KconfSupplier<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantInviteJsonConfigKey<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusBooleanConfigKey<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusObjectConfigKey<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusStringListConfigKey<br>com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusTailNumberKey<br>Affect(row-cnt:<span class="hljs-number">6</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">143</span> ms.<br>  <br>[arthas@<span class="hljs-number">70</span>]$ sc -d com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusStringListConfigKey<br> <span class="hljs-keyword">class</span>-info        com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusStringListConfigKey<br> code-source       file:<span class="hljs-regexp">/home/web_server/kuaishou-runner/webapps/kwaishop-merchant-janus-center-core.jar!/BOOT-INF/classes!/</span><br> name              com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.MerchantJanusStringListConfigKey<br> isInterface       <span class="hljs-literal">false</span><br> isAnnotation      <span class="hljs-literal">false</span><br> isEnum            <span class="hljs-literal">true</span><br> isAnonymousClass  <span class="hljs-literal">false</span><br> isArray           <span class="hljs-literal">false</span><br> isLocalClass      <span class="hljs-literal">false</span><br> isMemberClass     <span class="hljs-literal">false</span><br> isPrimitive       <span class="hljs-literal">false</span><br> isSynthetic       <span class="hljs-literal">false</span><br> simple-name       MerchantJanusStringListConfigKey<br> modifier          final,public<br> annotation<br> interfaces        com.kuaishou.kwaishop.merchant.janus.center.core.config.kconf.KconfSupplier<br> super-<span class="hljs-keyword">class</span>       +-java.lang.Enum<br>                     +-java.lang.<span class="hljs-built_in">Object</span><br> <span class="hljs-keyword">class</span>-loader      +-org.springframework.boot.loader.LaunchedURLClassLoader@<span class="hljs-number">6433</span>a2<br>                     +-jdk.internal.loader.ClassLoaders$AppClassLoader@<span class="hljs-number">55054057</span><br>                       +-jdk.internal.loader.ClassLoaders$PlatformClassLoader@<span class="hljs-number">352e4</span>b6d<br> classLoaderHash   <span class="hljs-number">6433</span>a2<br><br>Affect(row-cnt:<span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">90</span> ms.<br></code></pre></td></tr></table></figure><p><strong>sm——查看已加载类的方法信息（可使用 sm -d 查看方法详细信息）</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>sm com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat<br>com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat(<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;)<span class="hljs-title class_">Ljava</span>/lang/<span class="hljs-title class_">String</span>;<br><span class="hljs-title class_">Affect</span>(row-<span class="hljs-symbol">cnt:</span><span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">28</span> ms.<br><br>[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>sm com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span> chat -d<br> declaring-<span class="hljs-keyword">class</span>  com.kuaishou.kwaishop.merchant.answerize.center.core.service.impl.<span class="hljs-title class_">ChatServiceImpl</span><br> method-name      chat<br> modifier         <span class="hljs-keyword">public</span><br> annotation<br> parameters       java.lang.<span class="hljs-title class_">String</span><br>                  java.lang.<span class="hljs-title class_">String</span><br>                  java.lang.<span class="hljs-title class_">String</span><br> <span class="hljs-keyword">return</span>           java.lang.<span class="hljs-title class_">String</span><br> exceptions<br> classLoaderHash  749ab7b4<br><br><span class="hljs-title class_">Affect</span>(row-<span class="hljs-symbol">cnt:</span><span class="hljs-number">1</span>) cost <span class="hljs-keyword">in</span> <span class="hljs-number">32</span> ms.<br></code></pre></td></tr></table></figure><p>mc——内存编译器，内存编译.java文件为.class文件</p><p>retransform——加载外部的.class文件，retransform到JVM里</p><p>redefine——加载外部的.class文件，redefine到JVM里</p><p>dump——dump 已加载类的 byte code 到特定目录</p><p>classloader——查看classloader的继承树，urls，类加载信息，使用classloader去getResource</p><p>sysprop——查看和修改JVM的系统属性</p><p>sysenv——查看JVM的环境变量</p><p>vmoption——查看和修改JVM里诊断相关的option</p><p>perfcounter——查看当前 JVM 的Perf Counter信息</p><p>logger——查看和修改logger</p><p><strong>getstatic——查看类的静态属性</strong></p><p>ognl——执行ognl表达式</p><p>mbean——查看 Mbean 的信息</p><p>heapdump——dump java heap, 类似jmap命令的heap dump功能</p><p>vmtool——从jvm里查询对象，执行forceGc</p><h3 id="3-9-手动调用方法"><a href="#3-9-手动调用方法" class="headerlink" title="3.9 手动调用方法"></a><strong>3.9 手动调用方法</strong></h3><p>Karthas  中集成了 MVEL，MVEL 是一种基于 Java 的表达式语言（expression language），本质上就是对 Java 反射的抽象。同时内部已写好函数并自动加载 bean：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">getBeanByName = def (name) &#123; com.kuaishou.framework.spring.<span class="hljs-title class_">BeanFactory</span>.getBean(name) &#125;<br></code></pre></td></tr></table></figure><h4 id="spring-bean-方法"><a href="#spring-bean-方法" class="headerlink" title="spring bean 方法"></a><strong>spring bean 方法</strong></h4><p>可通过以下的方式，来对 spring bean 进行直接方法调用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@70</span>]<span class="hljs-variable">$ </span><span class="hljs-title class_">ShopBrandService</span>.getByShop(<span class="hljs-number">5004175295</span>, <span class="hljs-number">0</span>)<br><span class="hljs-variable">@ArrayList</span>[<br>    <span class="hljs-variable">@ShopBrand</span>[<br>        shopId=<span class="hljs-variable">@Long</span>[<span class="hljs-number">5004175295</span>],<br>        brandId=<span class="hljs-variable">@Long</span>[<span class="hljs-number">15131</span>],<br>        authType=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">4</span>],<br>        brandType=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">2</span>],<br>        status=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">1</span>],<br>        validDate=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1704009221536</span>],<br>        upgradingFlag=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">0</span>],<br>        id=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1220270</span>],<br>        createTime=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1683193994173</span>],<br>        updateTime=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1683193994173</span>],<br>    ],<br>    <span class="hljs-variable">@ShopBrand</span>[<br>        shopId=<span class="hljs-variable">@Long</span>[<span class="hljs-number">5004175295</span>],<br>        brandId=<span class="hljs-variable">@Long</span>[<span class="hljs-number">346976</span>],<br>        authType=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">4</span>],<br>        brandType=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">2</span>],<br>        status=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">1</span>],<br>        validDate=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1704009352828</span>],<br>        upgradingFlag=<span class="hljs-variable">@Integer</span>[<span class="hljs-number">0</span>],<br>        id=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1220271</span>],<br>        createTime=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1683193994209</span>],<br>        updateTime=<span class="hljs-variable">@Long</span>[<span class="hljs-number">1683193994209</span>],<br>    ],<br>]<br></code></pre></td></tr></table></figure><h4 id="类静态方法"><a href="#类静态方法" class="headerlink" title="类静态方法"></a><strong>类静态方法</strong></h4><p>使用全类名+方法进行调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span><span class="hljs-title class_">GenerateIdUtil</span>.generateId()<br><span class="hljs-title class_">Failed</span> to get static, exception <span class="hljs-symbol">message:</span> [<span class="hljs-title class_">Error</span>: could <span class="hljs-keyword">not</span> <span class="hljs-symbol">access:</span> <span class="hljs-title class_">GenerateIdUtil</span>; <span class="hljs-keyword">in</span> <span class="hljs-symbol">class:</span> java.util.<span class="hljs-title class_">HashMap</span>]<br>[<span class="hljs-title class_">Near</span> : &#123;... <span class="hljs-title class_">GenerateIdUtil</span>.generateId() ....&#125;]<br>             ^<br>[<span class="hljs-title class_">Line</span>: <span class="hljs-number">1</span>, <span class="hljs-title class_">Column</span>: <span class="hljs-number">1</span>], please check <span class="hljs-variable">$HOME</span>/logs/arthas/arthas.log <span class="hljs-keyword">for</span> more details.<br>[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>com.kuaishou.kwaishop.merchant.answerize.center.common.util.<span class="hljs-title class_">GenerateIdUtil</span>.generateId()<br><span class="hljs-string">&quot;483040520382451800&quot;</span><br></code></pre></td></tr></table></figure><h4 id="非-spring-bean-的非静态方法"><a href="#非-spring-bean-的非静态方法" class="headerlink" title="非 spring bean 的非静态方法"></a><strong>非 spring bean 的非静态方法</strong></h4><p>构造对象后进行调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ruby">[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>chatCompletionDTO = new com.kuaishou.kwaishop.merchant.answerize.center.common.dto.chat.<span class="hljs-title class_">ChatCompletion</span>DTO()<br>&#123;&#125;<br>[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>chatCompletionDTO.tokens()<br><span class="hljs-number">0</span><br>[arthas<span class="hljs-variable">@71</span>]<span class="hljs-variable">$ </span>chatCompletionDTO.maxToken()<br><span class="hljs-number">4096</span><br></code></pre></td></tr></table></figure><h3 id="3-10-retransform动态加载指定类"><a href="#3-10-retransform动态加载指定类" class="headerlink" title="3.10 retransform动态加载指定类"></a>3.10 retransform动态加载指定类</h3><p>jad 反编译文件class -&gt; java</p><p>mc 在把java编译为class</p><p>retransform 把指定的class动态加载到jvm中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 将class文件反编译为java文件</span><br>jad --source-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java<br><br><span class="hljs-comment">## 查看当前的类加载器，spring项目通常是LaunchedURLClassLoader</span><br>classloader<br><br><span class="hljs-comment">## 根据指定的类加载器，编译java文件</span><br>mc --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader /tmp/BranchTeamService.java -d /tmp<br><br><span class="hljs-comment">## https://arthas.aliyun.com/doc/retransform.html</span><br>retransform /tmp/com/example/demo/arthas/user/UserController.class<br></code></pre></td></tr></table></figure><p>需要注意jad不保证完成成果反编译class <a href="https://github.com/alibaba/arthas/issues/1158">https://github.com/alibaba/arthas/issues/1158</a></p><p>第一个更加推荐使用本地的java文件修改并上传到服务上（yum install lrzsz  安装sz和rz）</p><p>然后通过mc在java文件编译为class文件</p><h3 id="3-11-异步后台执行，并把日志写入指定文件"><a href="#3-11-异步后台执行，并把日志写入指定文件" class="headerlink" title="3.11 异步后台执行，并把日志写入指定文件"></a>3.11 异步后台执行，并把日志写入指定文件</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">watch com<span class="hljs-selector-class">.kuaishou</span><span class="hljs-selector-class">.kdev</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.repo</span><span class="hljs-selector-class">.RepoCommitService</span> getCommitsPage <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span>  -n <span class="hljs-number">5</span>  -x <span class="hljs-number">3</span> <span class="hljs-string">&#x27;throwExp != null&#x27;</span> &gt; /tmp/log<span class="hljs-selector-class">.txt</span> &amp;<br></code></pre></td></tr></table></figure><ul><li><code>throwExp != null</code>发生异常才记录</li><li><code>&gt;</code> 写入文件</li><li><code>&amp;</code> 后台异步执行</li></ul><p>这个时候使用quit命令 退出arthas控制台，让arthas 服务继续运行（stop 会停止arthas 服务）,等一段时间之后就可以来查看这个文件是否有异常信息进行相关的bug诊断。</p><h3 id="3-12-获取类的静态属性"><a href="#3-12-获取类的静态属性" class="headerlink" title="3.12 获取类的静态属性"></a>3.12 获取类的静态属性</h3><p>1、通过getstatic</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">getstatic com<span class="hljs-selector-class">.kuaishou</span><span class="hljs-selector-class">.kdev</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.RepoService</span> X_NEXT_PAGE -x <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>2、通过ognl</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ognl <span class="hljs-attr">--classLoaderClass</span> org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.loader</span><span class="hljs-selector-class">.LaunchedURLClassLoader</span> -x <span class="hljs-number">3</span> <span class="hljs-string">&#x27;@com.kuaishou.kdev.common.service.RepoService@X_NEXT_PAGE&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="3-13-使用tt获取spring-context上下文-获取spring-bean"><a href="#3-13-使用tt获取spring-context上下文-获取spring-bean" class="headerlink" title="3.13 使用tt获取spring context上下文(获取spring bean)"></a>3.13 使用tt获取spring context上下文(获取spring bean)</h3><p><strong>1、原理</strong></p><ul><li>SpringMVC 的请求会通过 <code>RequestMappingHandlerAdapter</code> 执行 <code>invokeHandlerMethod</code> 到达目标接口上进行处理</li><li>而在 <code>RequestMappingHandlerAdapter</code> 类中有 getApplicationContext（）</li></ul><p><strong>2、执行过程</strong></p><ul><li>arthas 执行 tt,任意执行一次 web 请求，tt 即可捕获</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod<br></code></pre></td></tr></table></figure><ul><li>根据目标的索引，执行自定义 OGNL 表达式即可</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tt -i 1000 -w &#x27;target.getApplicationContext().getBean(&quot;targetBean&quot;).targetMethod()&#x27;<br></code></pre></td></tr></table></figure><p><strong>3、一个可执行的命令demo</strong></p><ul><li>方法定义<code>public UserDetailVO getSingleUserDetail(String userName)&#123;&#125;</code></li><li>类定义 <code>public class PermissionUserServiceImpl extends ServiceImpl&lt;PermissionUserMapper, PermissionUser&gt;     implements IPermissionUserService</code></li><li>tt执行命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 固定命令</span></span><br>tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 根据不同的bean和method而改变</span></span><br>tt -i 1109 -w &#x27;target.getApplicationContext().getBean(&quot;permissionUserServiceImpl&quot;).getSingleUserDetail(&quot;xieshijie&quot;)&#x27;<br></code></pre></td></tr></table></figure><ul><li>注意事项<ul><li>getBean的参数，需要根据类名来获取，把首字母小写</li><li>方法有参数需要指定具体指，如果是字符串，则需要用双引号</li></ul></li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://arthas.aliyun.com/doc/commands.html">arthas官方文档</a></p><p><a href="https://www.yuque.com/arthas-idea-plugin/help">arthas idea plugin 使用文档</a></p><p><a href="https://github.com/alibaba/arthas/issues?q=label:user-case">arthas的一些高级使用用法</a></p><p><a href="https://github.com/alibaba/arthas/issues/482">Arthas实践–获取到Spring Context</a></p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
      <category>问题定位</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题定位</tag>
      
      <tag>arthas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI大模型的仰望星空和脚踏实地</title>
    <link href="/2023/04/13/AIGC/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%B0%E6%9C%9B%E6%98%9F%E7%A9%BA%E5%92%8C%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/"/>
    <url>/2023/04/13/AIGC/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%B0%E6%9C%9B%E6%98%9F%E7%A9%BA%E5%92%8C%E8%84%9A%E8%B8%8F%E5%AE%9E%E5%9C%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>AI正在以天为周期进化，给人前所未有的压迫感，AI读心术？数字生命？AI大模型正在以其无与伦比的效率颠覆我们的生活。比尔盖茨表示：这就像当年我第一次见到图形界面操作系统。黄仁勋在发布会上强调，我们正在经历又一个Iphone Moment</p></blockquote><p>ChatGPT在今年1月推出，也就是推出仅两个月后。活跃活跃用户就达到了1个亿，成为了历史上增长最快的消费应用，排名第二TikTok用了13个月才达到1个亿</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out.png"></p><p>这两个月世界变化巨大，而变化来自于AI。</p><p>3.15号，Open AI发布了GPT 4，也就是新版本的AI大模型，这就像第一次图形界面或iPhone第一次发布，带给了互联网无与伦比的冲击。</p><h1 id="OpenAI掀起的狂潮"><a href="#OpenAI掀起的狂潮" class="headerlink" title="OpenAI掀起的狂潮"></a><strong>OpenAI掀起的狂潮</strong></h1><hr><h2 id="3-16号-微软发布Copilot"><a href="#3-16号-微软发布Copilot" class="headerlink" title="3.16号 微软发布Copilot"></a><strong>3.16号 微软发布Copilot</strong></h2><p>微软发布的office办公工具基于GPT大语言模型的，以后不管是在world Excel PPT还是邮件系统，都会多出来一个对话框，也就是一个人工智能助手，他可以帮你改文章做PPT查询数据。</p><ul><li>比如当你在用Excel查公司数据的时候，你可以跟他直接说，请把过去一年公司增长的原因找出来，他就会把关键增长部门的数据划重点，提示你。</li><li>如果你错过了一个重要的会议，可以根据会议记录问他，会议主要讨论了啥呀，各方面都有什么观点啊，最后有什么问题没有被解决啊</li><li>当然也可以用word文档直接生成PPT</li></ul><p>相当于让每个人，都拥有了一个高校毕业的秘书</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231439425.png"></p><p>﻿</p><h2 id="3-16号-Midjourney-V5发布"><a href="#3-16号-Midjourney-V5发布" class="headerlink" title="3.16号 Midjourney V5发布"></a><strong>3.16号 Midjourney V5发布</strong></h2><p>midjourney是AI图片生成工具，基本上解决了之前AI画不好手指的问题，整体产出的图片不像之前的版本那么天马行空，但却更接近真实场景，很多时候让人难辨真假</p><p><a href="https://www.midjourney.com/showcase/recent">https://www.midjourney.com/showcase/recent/</a></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231438924.png"><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231437002.png"></p><h2 id="3-16号-百度发布文心一言"><a href="#3-16号-百度发布文心一言" class="headerlink" title="3.16号 百度发布文心一言"></a><strong>3.16号 百度发布文心一言</strong></h2><p>百度的大语言模型文心一言3.16号发布公测，成为第一个发布大模型语言模型的国内互联网大厂</p><h2 id="3-21号-英伟达年度开发者大会"><a href="#3-21号-英伟达年度开发者大会" class="headerlink" title="3.21号 英伟达年度开发者大会"></a><strong>3.21号 英伟达年度开发者大会</strong></h2><p>在大会上，黄仁勋做了演讲，通篇没有一处提到游戏显卡，而是在软件部分，发布了100多个基于英伟达特用GPU和扩大架构的加速计算工具</p><p>包括流体力学仿真数据库处理、光刻机眼膜设计和AI等，更新了工业园宇宙Omniverse，在硬件部分发布了4款AI推理芯片，整体上把AI的运算效率提升了一个档次，还发布了三个基于AI大模型的云服务，分别面向文本处理、图片处理和生物医药的研究</p><p>核心思想就是：All In AI</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231441505.png"></p><h2 id="3-21号-Google-Bard聊天机器人公测"><a href="#3-21号-Google-Bard聊天机器人公测" class="headerlink" title="3.21号 Google Bard聊天机器人公测"></a><strong>3.21号 Google Bard聊天机器人公测</strong></h2><p>GPT-4发布一周后，谷歌聊天机器人Bard开放测试</p><p>高情商：跟搜索保持距离，搜索的补充体验</p><p>低情商：依托答辩</p><h2 id="3-23号-Github发布copilot-x"><a href="#3-23号-Github发布copilot-x" class="headerlink" title="3.23号 Github发布copilot x"></a><strong>3.23号 Github发布copilot x</strong></h2><p>随着 OpenAI 的 GPT-4 模型的发布，GitHub 紧接着就发布了新版本的 GitHub Copilot X。Copilot X 的 AI 模型采用的是最新 OpenAI GPT-4，毕竟 GitHub 是微软的亲儿子。</p><p>GitHub Copilot X 致力于改进开发者体验，将提供聊天和语音界面，支持拉取请求，回答文档问题，并通过 GPT-4 实现更个性化的开发者体验。使用 GitHub Copilot X，它可以解释代码的用途，还可以在遇到 bugs 时让 Copilot X 尝试去修复它，甚至还可以顺带生成单元测试。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231432007.png"></p><h2 id="3-23号-Runway发布Gen-2"><a href="#3-23号-Runway发布Gen-2" class="headerlink" title="3.23号 Runway发布Gen 2"></a><strong>3.23号 Runway发布Gen 2</strong></h2><p>不同于上个版本Gen 1，需要输入文字加图像才能生成视频，Gen 2只要输入文本就能生成视频</p><p><a href="https://research.runwayml.com/gen2">https://research.runwayml.com/gen2</a></p><h2 id="3-25号-Open-AI推出ChatGPT插件能力"><a href="#3-25号-Open-AI推出ChatGPT插件能力" class="headerlink" title="3.25号 Open AI推出ChatGPT插件能力"></a><strong>3.25号 Open AI推出ChatGPT插件能力</strong></h2><p>该能力可以把你的网站或者app跟Chatgbt连上。</p><p>起到作用类似于比如说你你把美团跟chatgbt连上，然后用户就可以给AI助理下指示，周末我要带女朋友去大理玩，然后他就会根据美团上的商家数据和用户评论数据，过几秒钟就帮你把行程酒店机票餐厅全都安排了，然后你跟他说太贵了，然后他就会给你整体根据优惠然后再安排一遍</p><p>这就开始想象chatgpt应用的无限场景，更大的改变是有可能以后大家就不上美团了，也不再应用商城下美团APP了，而是直接在chatgpt里面用美团或者别的什么生活服务APP了，直接重购了互联网流量入口。</p><p>AI正在以天为周期进化，给人前所未有的压迫感，对此比尔盖茨和英伟达老板黄仁勋的表态是最有代表性的</p><blockquote><p><strong>比尔盖茨表示：这就像当年我第一次见到图形界面操作系统</strong></p></blockquote><blockquote><p><strong>黄仁勋在发布会上三次强调：我们正在经历又一个iPhone Moment</strong></p></blockquote><p>比尔盖茨靠着抄MAC图形界面操作系统操的够快以及设计出了快速扩张的商业模式，率领微软登上巅峰成为世界首富。黄仁勋因为错过了iPhone带来的移动互联网革命，他的公司股价从2007年高峰的接近10美元一度掉到接近1美元。所以我相信这两个人对他们口中的那个时刻一定是印象深刻的</p><blockquote><p><strong>而此次此刻恰如彼时彼刻！</strong></p></blockquote><h1 id="仰望星空"><a href="#仰望星空" class="headerlink" title="仰望星空"></a><strong>仰望星空</strong></h1><hr><h2 id="AI大模型的底层逻辑"><a href="#AI大模型的底层逻辑" class="headerlink" title="AI大模型的底层逻辑"></a><strong>AI大模型的底层逻辑</strong></h2><blockquote><p><strong>这是一张末代皇后婉容的照片，AI模型上色之后就成了这样</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231434777.png"></p><blockquote><p><strong>同时他还可以有很多别的配色</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231443032.png"></p><blockquote><p><strong>那么AI是怎么完成黑白照片的上色的呢？</strong></p></blockquote><p>如果让我这个人类去给这张照片上色的话，我能想到两种方法</p><p><strong>方法1：</strong>我先去调查婉容这件衣服的材质，甚至尝试去找到这件衣服的本体，在结合史料上拍张照片的时间地点、当天的天气光照，确定一种最有可能的颜色给它涂上去，这种方法叫做分析推理方法。</p><p><strong>方法2：</strong>我随便找个看着不那么突兀的颜色，就给他涂上去，所有的背景事物照此操作，最后出来的照片像那么回事就行，因为我看过很多女人穿着类似衣服的彩色照片，这种方法我们姑且称之为套模板</p><blockquote><p><strong>AI并不擅长分析推理，但他非常擅长套模板</strong></p></blockquote><p>然后总结成模板到处套，特别是在最近这一轮大模型革命之后，AI变得非常非常擅长总结模板到处套，这既体现为他无与伦比的效率，也体现为他无人可及的能力。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231443658.png"></p><h2 id="无与伦比的效率"><a href="#无与伦比的效率" class="headerlink" title="无与伦比的效率"></a><strong>无与伦比的效率</strong></h2><p>AI大模型很难承担真正的原创性工作，也就是说他无法替代去形成目标决心底层的策略，但他能比任何人都更高效的完成<strong>扩展翻译总结查找</strong></p><p>这里的扩<strong>展翻译总结查找</strong>，都是广义上的说法</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231440524.png"></p><p>于是基于广义扩展翻译总结查找，围绕AI大模型就产生了大量的应用</p><ul><li>比如说文字转图片的<strong>midjourney、stable diffusion、dall·e 2</strong></li><li>文字转PPT的<strong>Tommy、copilot</strong></li><li>文字转视频的<strong>Runway</strong></li><li>文字转网站代码的<strong>copilot x</strong></li><li>等等等等</li></ul><p>现在美国的互联网新产品发布平台<strong>Product Hunt</strong>，上面已经有一半以上的新发应用是基于AI，帮你解决各种各样的小问题的：比如说在繁杂的Excel数据当中找出关键的增长指标就是查找，这些本来需要投入几小时甚至几天去完成的工作，现在AI能在几秒钟之内帮你完成</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231440149.png"></p><p>在用AI完成基础的工作之后，数据会保存在数据库里，而不是人类的脑子里，也就是提取和传输的限制条件是内存和限宽，而不是人类的发声习惯，信息在组织内部上传下达平级沟通的效率也急剧加速</p><p>就比如在管理软件领域的大数据分析，现在的大型连锁商店，都会收集大量经营数据来分析，但是当运营人员真的提出要看某些数据的时候，首先数据涉及到敏感的商业机密不能让你随便看，然后你的电脑也跑不了那么大的数据库，这时候就需要专业的工程师去帮你调取特定的数据，会根据先来后到轻重缓急，给调取数据的需求排个序，你会进入到排队队列，真正拿到数据的时候可能是2个月以后了，而AI大模型能把这个时间缩短到几秒钟。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231444145.png"></p><p>实际上我们日常的工作当中，只有非常非常少的一部分是严格意义上的原创，而有大量的信息搜索总结翻译扩展，大量的沟通上传下达，当AI充分介入之后，这些流程将会不复存在，大集团公司老板和国家领导人将可以直接获取最基层的信息，而绝大多数产品的开发周期都会缩短到一天之内，上午形成想法晚上网站上线，甚至配合日益成熟的3D打印技术，上午形成想法晚上零件入库，这就是AI大模型能给我们带来无与伦比的效率。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231447074.png"></p><h2 id="AI读心术"><a href="#AI读心术" class="headerlink" title="AI读心术"></a><strong>AI读心术</strong></h2><blockquote><p><strong>更激动人心的是AI创造了新的可能性</strong></p></blockquote><p>有一种医疗诊断技术叫做FMRI（功能性磁共振成像）可以观测记录到大脑血流的微小变化，大脑在工作的时候，比如说看一张图片，必然会导致各部分的神经元产生不同的对能量氧气的需求，进而导致血流量的微小变化，而这个数据是可以通过FMRI记录下来的</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231447977.png"></p><blockquote><p><strong>那有没有可能，这种血流的微小变化数据跟我们现在看到的图像存在对应的关系呢？</strong></p></blockquote><p>肯定是有可能的，但是人能看得出来我信你个鬼，因为这里这个对应的模板模型太复杂了，完全超出了人脑的理解能力，而一个日本大阪大学的团队用stable diffusion AI模型，利用FMRI的数据画出了这样的图像</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231443228.png"></p><blockquote><p><strong>患者看到的原图是这样的</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231455610.png"></p><blockquote><p><strong>对比图（左侧stable diffusion绘制，右侧人眼观测）</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231446948.png"></p><blockquote><p><strong>这是AI画出来的</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231445848.png"></p><blockquote><p><strong>这是患者看到的</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231500270.png"></p><blockquote><p><strong>对比图（左侧stable diffusion绘制，右侧人眼观测）</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231449349.png"></p><blockquote><p><strong>这是AI画出来的</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231448790.png"></p><blockquote><p><strong>这是患者看到的</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231449089.png"></p><blockquote><p><strong>对比图（左侧stable diffusion绘制，右侧人眼观测）</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231454307.png"></p><blockquote><p><strong>这为我们展现了一种实现非侵入式脑机接口的可能性，人类可以通过意念进行沟通交流。后面在瘫痪患者的治疗，在义肢轮椅等领域会有巨大的应用前景！</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231449670.png"></p><blockquote><p><strong>而如果说的科幻一点这就是在字面意义上实现了读心术啊，短短11页的论文实现了读心术！是不是很大胆！</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231452927.png"></p><h2 id="数字生命"><a href="#数字生命" class="headerlink" title="数字生命"></a><strong>数字生命</strong></h2><p>更大胆的是</p><blockquote><p><strong>像这样我们知道两件事，两组数据之间的关联，而人脑不知道如何对上的情况，在人类社会比比皆是</strong></p></blockquote><p>马丁路德金曾说我梦想有一天，我的四个孩子，将在一个不以他们的肤色，而是以他们的品格优劣来评价他们的国度里生活</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231455265.png"></p><blockquote><p><strong>什么叫做一个人的品格呢？</strong></p></blockquote><p>这曾经是一个非常抽象的概念，体现为一个人的所有行为举止的集合。</p><p>而人的行为举止这个数据，其实是可以记录的，对于一个心智成熟的成年人来说，他在网络上未来的行为可以认为是过去行为的一种延续，于是只需要提取你在网络上的所有足迹：看过什么、发过什么、做过什么</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231455417.png"></p><p>把这些数据做一个记录，然后让AI大模型去学习这组数据就可以生成一个数字化的你，这个你可以替你去发评论发弹幕、发文章、私信、表白甚至可以替你花钱网购</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231456151.png"></p><blockquote><p><strong>这就是一个人的品格，他被AI破解了，我们看到的新闻内容的点点滴滴，而这个点点滴滴跟真实感之间的关联，本来应该是抽象的，而现在已经被AI破解了，以后再也没有眼见为实了</strong></p></blockquote><p>这些案例看起来可能会感觉有点疯狂可怕，你这么感觉就对了，我也有这样的感受，自200万年前以来人类一直是已知世界智能最高的存在，我们早已对此习以为常</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231455855.png"></p><p>我思故我在，体现了人类的独特性，而如今一种新的智能正在破解我们所有抽象的概念，破解人类的独特性。</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231500617.png"></p><blockquote><p><strong>人类进化到现在的智慧水平用了200万年，AI大模型需要多久？</strong></p></blockquote><h1 id="脚踏实地"><a href="#脚踏实地" class="headerlink" title="脚踏实地"></a><strong>脚踏实地</strong></h1><hr><blockquote><p><strong>当然，倒也不需要过度恐慌，也不用对AI大模型的产品畏之如虎，我很认同一句话：AI不会淘汰你，但是第一批使用AI工具的人会淘汰你！</strong></p></blockquote><p><strong>结合我最近使用的两个工具，抛砖引玉，让我们一起步入这个新的时代！</strong></p><h2 id="stable-diffusion-生成个性图片"><a href="#stable-diffusion-生成个性图片" class="headerlink" title="stable diffusion 生成个性图片"></a><strong>stable diffusion 生成个性图片</strong></h2><p>先上一个我自己生成的效果(就是在我的Mac上用CPU生成的)</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231504422.png"></p><p>官网：<a href="https://stablediffusionweb.com/">https://stablediffusionweb.com/</a></p><p>官网提供的在线上能力比较弱鸡，而且很多参数不能调节，使用次数还有限制，不推荐</p><p>推荐一个Github上的一个大神：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui">https://github.com/AUTOMATIC1111/stable-diffusion-webui</a></p><p>这个是本地搭建一个stable diffusion模型，自由度非常高，配合<a href="https://civitai.com/">https://civitai.com/</a> 这个网站，基本可以定制化生产任意图片</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231507997.png"></p><p>我在这里简要说一下我的搭建过程，以供参考</p><p>1、Mac的安装参考：<a href="https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon">https://github.com/AUTOMATIC1111/stable-diffusion-webui/wiki/Installation-on-Apple-Silicon</a></p><p>安装3.10版本的Python（其他版本都有些问题） 拉取仓库 运行.&#x2F;webui.sh 然后就会自动下载各种依赖和默认的模型，命令行出现下面的日志就代表成功了</p><p>2、在<a href="https://civitai.com/%E6%89%BE%E4%B8%80%E4%B8%AA%E5%90%88%E9%80%82%E7%9A%84%E6%A8%A1%E5%9E%8B%E5%B9%B6%E4%B8%8B%E8%BD%BD">https://civitai.com/找一个合适的模型并下载</a></p><p>3、下载完成之后，把checkpoint拖入下面这个文件夹，然后重启服务</p><p>然后就能在模型列表找到你刚刚下载的模型了</p><p>4、填写参数，需要注意5个参数</p><ul><li><p>checkpoint&#x2F;模型，我选择的是国风3模型<a href="https://civitai.com/models/10415/3-guofeng3?modelVersionId=17414">https://civitai.com/models/10415/3-guofeng3?modelVersionId=17414</a> </p></li><li><p>正向词和负向词 </p></li><li><p>Sampling </p></li><li><p>step </p></li><li><p>CFG scale </p></li><li><p>Seed (这个我理解就是一个框架，比如说描述词有【站立】，但是站立还有很多种正面站还是侧面站，这个seed就是用规范一个大概的范围，-1是随机)</p></li></ul><p>参数我放这里，大家自取哈</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">## checkpoint</span><br><span class="hljs-keyword">https</span>://civitai.com/models/<span class="hljs-number">10415</span>/<span class="hljs-number">3</span>-guofeng3?modelVersionId=<span class="hljs-number">17414</span><br><br><span class="hljs-comment">## 正向词</span><br>best quality, masterpiece, highres, <span class="hljs-number">1</span>girl,china dress,hair ornament,necklace, jewelry,Beautiful face,upon_body, tyndall effect,photorealistic, dark studio, rim lighting, <span class="hljs-literal">two</span> tone lighting,(high <span class="hljs-keyword">detailed</span> skin:<span class="hljs-number">1.2</span>), <span class="hljs-number">8</span>k uhd, dslr, soft lighting, high quality, volumetric lighting, candid, Photograph, high resolution, <span class="hljs-number">4</span>k, <span class="hljs-number">8</span>k, Bokeh<br><br><span class="hljs-comment">## 负向词</span><br>(((simple background))),monochrome ,lowres, bad anatomy, bad hands, <span class="hljs-keyword">text</span>, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, <span class="hljs-keyword">normal</span> quality, jpeg artifacts, signature, watermark, username, blurry, lowres, bad anatomy, bad hands, <span class="hljs-keyword">text</span>, error, extra digit, fewer digits, cropped, worst quality, low quality, <span class="hljs-keyword">normal</span> quality, jpeg artifacts, signature, watermark, username, blurry, ugly,pregnant,vore,duplicate,morbid,mut ilated,tran nsexual, hermaphrodite,<span class="hljs-keyword">long</span> neck,mutated hands,poorly drawn hands,poorly drawn face,mutation,deformed,blurry,bad anatomy,bad proportions,malformed limbs,extra limbs,cloned face,disfigured,gross proportions, (((missing arms))),(((missing legs))), (((extra arms))),(((extra legs))),pubic hair, plump,bad legs,error legs,username,blurry,bad feet<br><br><span class="hljs-comment">## Sampling step</span><br><span class="hljs-number">30</span><br><br><span class="hljs-comment">## CFG scale</span><br><span class="hljs-number">7</span><br><br><span class="hljs-comment">## Seed</span><br><span class="hljs-number">2467180841</span><br></code></pre></td></tr></table></figure><p>5、生成图片</p><p>填写完参数就可以点击右上的Generate，命令行可以看进度，差不多3分钟就可以生成</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231501992.png"></p><p>6、提升分辨率</p><p>先拿到图片</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231505695.png"></p><p>选择Extra，并把刚刚生成的图片放入，并设置Upscaler1和Upscaler2均为R-ESRGAN 4X + Anime6B</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231513171.png"></p><p>放下修复之后的对比图</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231507486.png"></p><p>注意事项</p><ul><li>Mac基本没有GPU所以这个生产过程基本都是用CPU去模拟的，生成过程CPU会飙升，请大家在非工作时间操作，否则造成电脑卡死概不负责哈</li><li>明明参数配置一样，就是跟模型的不一样，这个是正常的，因为这个有多重因素干扰，不同的显卡甚至效果也不一样，显卡越好生产的效果越好，模型网站的图片基本都是顶级显卡跑出来的</li></ul><h2 id="ChatGPT-辅助编程"><a href="#ChatGPT-辅助编程" class="headerlink" title="ChatGPT 辅助编程"></a><strong>ChatGPT 辅助编程</strong></h2><blockquote><p><strong>背景：</strong></p></blockquote><p>平时会编写博客，并且会把这个博客上传到github上，然后自己买一个域名挂到github上。</p><p>我平时编写的博客会有一些图片来辅助说明的，写完之后如果我把图片和文字全部都上传到博客网站，后期图片很多时就会导致网站加载特别慢</p><p>所以想把图片存储在一个公共的对象存储平台（腾讯云的cos服务），这样只要上传一个公共访问链接即可，极大的减少存储空间。</p><blockquote><p><strong>需求：</strong></p></blockquote><p>每次写完博客都要手动上传图片，然后把得到的链接在复制到本地的markdown文件中，如果一篇文章的图片特别多，这简直就是灾难！所以我想</p><ol><li><p>给一个文件路径，自动把markdown文件中本地的图片上传到腾讯云的cos平台，并获取公共链接</p></li><li><p>把本地的文章的链接自动替换为公共链接</p></li></ol><blockquote><p><strong>调研和设计</strong></p></blockquote><p>腾讯云cos服务是提供这样的接口的，但是接口需要鉴权，所以我把上诉的需求拆解为三部分</p><ul><li>生成鉴权sign_key</li><li>调用腾讯云的接口上传图片，并获取链接</li><li>输入markdown文件，找到本地图片链接，上传并替换为公共链接</li></ul><h3 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a><strong>错误示范</strong></h3><blockquote><p><strong>我阅读腾讯云的cos文档，需要提供签名，一共需要八个步骤才能生成</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231504053.png"><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231505048.png"></p><blockquote><p><strong>我把这八个过程每一个过程都复制给chatgpt，让他帮我写</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231505441.png"><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231505934.png"><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231506839.png"></p><blockquote><p><strong>后面太多我就不演示了，我直接说总结：</strong></p></blockquote><ul><li>在这个过程中给我的代码基本都是可以运行的，我只需要微调一下就可以用，报错直接扔给他也基本都可以解决</li><li>但是整个过程还是需要我理解每一步，并且把这八个步骤进行汇总和调整</li><li><strong>比Google搜索要好用一点，但是还没有那么好用，总感觉差点意思</strong></li></ul><h3 id="正确示范"><a href="#正确示范" class="headerlink" title="正确示范"></a><strong>正确示范</strong></h3><blockquote><p><strong>生成上面的签名之后，我就让他去写上传接口</strong></p></blockquote><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231507083.png"><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231508211.png"></p><p>仔细阅读一下上面的第二张图片，我要求<strong>【<strong><strong>把其中的url的uri替换为文件名</strong></strong>】</strong>，然后它给我代码并解释这是做什么，它说这是上传到<strong>【腾讯云的cos服务】</strong>，要知道我在这之前是完全没有提到过<strong>【腾讯云】、【cos服务】</strong>等字眼的，也就是它只依赖我提供的host<strong>【</strong><a href="http://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/"><strong>coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com</strong></a><strong>】</strong>这个域名，就判断出我这是腾讯云的cos服务，这就有点厉害了，更厉害的是，当然要求他写一个测试用例：</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231507360.png"></p><blockquote><p><strong>它直接把我之前费力八个步骤生成的签名直接生成了！这太离谱了！</strong></p></blockquote><ul><li><strong>我以为：</strong>chatgpt不知道腾讯云cos签名的生成过程，然后我阅读文档，把八个步骤重组并依次喂给chatgpt，让他帮我写</li><li><strong>实际上：</strong>chatgpt不仅知道腾讯云cos，在我要求他上传时，就自动把官方推荐的生成签名的方式给我生成了！</li></ul><blockquote><p><strong>这意味着以后大部分网络开源的内容，你甚至不用阅读啃文档，你只要知道一个概念，剩下的就交给他就可以！</strong></p></blockquote><p>后面的上传和替换markdown的内容我就不截图，后面对于chatgpt就非常简单了，最后附上完整的代码(95%是chatgpt写的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding=utf-8</span><br><span class="hljs-keyword">import</span> hmac<br><span class="hljs-keyword">import</span> hashlib<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-comment"># 定义 SecretKey 和 KeyTime</span><br><span class="hljs-comment"># 替换为自己的key和id</span><br>secret_key = <span class="hljs-string">&quot;xieshijie_key&quot;</span><br>key_time = <span class="hljs-string">&quot;1680947045;2980950645&quot;</span><br>secret_id = <span class="hljs-string">&quot;xieshijie_id&quot;</span><br>http_method = <span class="hljs-string">&#x27;put&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_url_param_list</span>():<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_header_list</span>():<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_sign_key_val</span>(<span class="hljs-params">uri_pathname</span>):<span class="hljs-comment"># 生成 SignKey</span><br>    sign_key = hmac.new(<br>        secret_key.encode(),<br>        key_time.encode(),<br>        hashlib.sha1<br>    ).hexdigest()<br><br>    <span class="hljs-comment"># 生成 HttpString</span><br>    http_string = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;http_method.lower()&#125;</span>\n<span class="hljs-subst">&#123;uri_pathname&#125;</span>\n&quot;</span><br><br>    http_string += <span class="hljs-string">&quot;\n&quot;</span><br><br>    http_string += <span class="hljs-string">&quot;\n&quot;</span><br><br>    <span class="hljs-comment"># 生成 StringToSign</span><br>    string_to_sign = <span class="hljs-string">f&quot;sha1\n<span class="hljs-subst">&#123;key_time&#125;</span>\n<span class="hljs-subst">&#123;hashlib.sha1(http_string.encode()).hexdigest()&#125;</span>\n&quot;</span><br><br>    <span class="hljs-comment"># 生成 Signature</span><br>    signature = hmac.new(<br>        sign_key.encode(),<br>        string_to_sign.encode(),<br>        hashlib.sha1<br>    ).hexdigest()<br><br>    <span class="hljs-comment"># 生成签名</span><br>    sign_key_val = <span class="hljs-string">f&quot;q-sign-algorithm=sha1&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-ak=<span class="hljs-subst">&#123;secret_id&#125;</span>&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-sign-time=<span class="hljs-subst">&#123;key_time&#125;</span>&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-key-time=<span class="hljs-subst">&#123;key_time&#125;</span>&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-header-list=<span class="hljs-subst">&#123;generate_header_list()&#125;</span>&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-url-param-list=<span class="hljs-subst">&#123;generate_url_param_list()&#125;</span>&quot;</span> \<br>                   <span class="hljs-string">f&quot;&amp;q-signature=<span class="hljs-subst">&#123;signature&#125;</span>&quot;</span><br><br>    <span class="hljs-keyword">return</span> sign_key_val<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_file_name</span>(<span class="hljs-params">file_path</span>):<span class="hljs-comment"># 获取文件名return file_path.split(&#x27;/&#x27;)[-1]</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">put_request</span>(<span class="hljs-params">file_path, sign_key</span>):<span class="hljs-comment"># 设置请求头</span><br>    headers = &#123;<br>        <span class="hljs-string">&#x27;host&#x27;</span>: <span class="hljs-string">&#x27;coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com&#x27;</span>,<br>        <span class="hljs-string">&#x27;Authorization&#x27;</span>: sign_key<br>    &#125;<br><br>    <span class="hljs-comment"># 设置请求体with open(file_path, &#x27;rb&#x27;) as f:</span><br>        data = f.read()<br><br>    uri = generate_file_name(file_path)<br><br>    <span class="hljs-comment"># 发送 PUT 请求</span><br>    url = <span class="hljs-string">f&#x27;https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/<span class="hljs-subst">&#123;uri&#125;</span>&#x27;</span><br>    response = requests.put(url, headers=headers, data=data)<br><br>    <span class="hljs-comment"># 判断响应状态码并返回结果if response.status_code == 200:</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;本地图片上传成功&#x27;</span>)<br>        <span class="hljs-keyword">return</span> url<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;本地图片上传失败&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;fail&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">replace_local_image_links</span>(<span class="hljs-params">file_path</span>):﻿<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    读取Markdown文件，提取其中的本地图片链接并替换为基于图片名称计算的新链接。</span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        file_path (str): Markdown文件路径。</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><span class="hljs-comment"># 判断文件是否是Markdown格式if not file_path.endswith(&#x27;.md&#x27;):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该文件不是Markdown格式。&#x27;</span>)<br>        <span class="hljs-keyword">return</span><br><br>    <span class="hljs-comment"># 读取Markdown文件内容with open(file_path, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br>        content = f.read()<br><br>    <span class="hljs-comment"># 匹配所有本地图片链接  匹配形式为：![...](...)</span><br>    regex = <span class="hljs-string">r&quot;!\[\S+\]\((\S+)\)&quot;</span><br>    matches = re.findall(regex, content)<br><br>    <span class="hljs-comment"># 替换本地图片链接为新链接for match in matches:# 判断链接是否是本地路径if not match.startswith(&#x27;http&#x27;):# 获取图片名称和路径if os.path.isabs(match):</span><br>                image_name = os.path.basename(<span class="hljs-keyword">match</span>)<br>                image_path = <span class="hljs-keyword">match</span><br>            <span class="hljs-keyword">else</span>:<br>                image_name = os.path.basename(<span class="hljs-keyword">match</span>)<br>                image_path = os.path.abspath(os.path.join(os.path.dirname(file_path), <span class="hljs-keyword">match</span>))<br>            sign_key = generate_sign_key_val(<span class="hljs-string">&#x27;/&#x27;</span> + image_name)<br>            <span class="hljs-comment"># 上传图片到COS并计算新链接</span><br>            new_link = put_request(image_path, sign_key)<br>            <span class="hljs-comment"># 替换Markdown文件中的链接</span><br>            content = content.replace(<span class="hljs-keyword">match</span>, new_link)<br><br>    <span class="hljs-comment"># 将替换后的Markdown内容写回文件with open(file_path, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br>        f.write(content)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;本地图片链接替换完成。&#x27;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 测试替换</span><br>    replace_local_image_links(<span class="hljs-string">&quot;/Users/xieshijie/Desktop/test.md&quot;</span>)<br></code></pre></td></tr></table></figure><p>我用了差不多半天的时间完成这件事，大部分时间是阅读腾讯云的cos服务文档和分步骤生成签名的过程，<strong>如果正确使用实际我觉得可以缩短到1个小时！</strong></p><p>然后，我果断充了一个GPT-4</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/out-20230411231508344.png"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ChatGPT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>ChatGPT</tag>
      
      <tag>stable diffusion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注册ChatGPT保姆级攻略(长期有效~)</title>
    <link href="/2023/04/12/AIGC/%E6%B3%A8%E5%86%8Cchatgpt%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5-%E9%95%BF%E6%9C%9F%E6%9C%89%E6%95%88/"/>
    <url>/2023/04/12/AIGC/%E6%B3%A8%E5%86%8Cchatgpt%E4%BF%9D%E5%A7%86%E7%BA%A7%E6%94%BB%E7%95%A5-%E9%95%BF%E6%9C%9F%E6%9C%89%E6%95%88/</url>
    
    <content type="html"><![CDATA[<p><strong>总结：</strong></p><ol><li>科学上网的条件：<a href="https://sockboom.shop/auth/register?affid=677419">sockboom</a><ol><li>先注册登录</li><li>购买套餐</li><li>安装clashx</li><li>配置上网</li></ol></li><li>接码平台：<a href="https://sms-activate.org/">sms</a><ol><li>先注册登录</li><li>点击右上角的余额，下拉点击充值</li><li>选择支付宝账号充值，PS：这个最低充值2美元，最开始没有最低额度的，因为chatgpt爆火，大量国人涌入，导致平台抬高了充值的价格，而且支付金额低于10美元时，佣金为3% + 0.03美元,要是有其他充值方式也可以不用选择这个</li><li>我充值了10美元，付款之后直接到账</li><li>点击左侧的服务列表中的openai服务，选中</li></ol></li><li>注册google账号</li><li>注册chatgpt，成功！</li></ol><p>注意事项</p><ul><li>科学上网的节点不要选择香港，最好选美国或者日本</li></ul><h2 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h2><p>科学上网平台还是建议选择大一点的平台，买贵一点的套餐，太便宜的那种机场ip被大量人使用，openai就会直接把这个ip拉黑，即便注册成功了后续登录也会被限制</p><p>我使用的平台<a href="https://sockboom.shop/auth/register?affid=677419">sockboom</a>, 点击<a href="https://sockboom.shop/auth/register?affid=677419">这里</a>跳转到sockbook平台</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401100825926.png" alt="sockboom平台"></p><p>定期有一些活动，每天登录一次可以免费领流量</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401100850330.png" alt="签到流量"></p><p>节点列表，这个各个平台基本差不多，都是一些常见的</p><ol><li>美国</li><li>俄罗斯</li><li>日本</li><li>香港</li><li>新加坡</li><li>土耳其</li><li>韩国</li><li>马来西亚</li><li>等等</li></ol><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401101451773.png" alt="节点列表"></p><p>套餐列表</p><p>PS:我开了VIP(可以多选一些节点)，买了一年的套餐，一共花了￥80</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401101253727.png" alt="套餐"></p><p>使用非常简单，按照平台的提示即可</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401101947437.png" alt="使用说明"></p><p>我使用的是mac，点击到mac选项，先下载clashx并安装，</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230402105358425.png" alt="mac的使用说明"></p><p>然后点击一键导入clashx配置，更新完成之后，点击添加</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230402105452140.png" alt="clash x配置"></p><p>选择美国&#x2F;日本的接口(需要注意，选节点不要选香港，香港已经被openai划入黑名单了)，并设置全局代理即可科学上网</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230402122144417.png" alt="选择节点"></p><p>输入<a href="https://tool.lu/ip/%EF%BC%8C%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%8B%E5%BD%93%E5%89%8D%E7%9A%84ip">https://tool.lu/ip/，验证一下当前的ip</a></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230402123313498.png" alt="ip验证"></p><h2 id="接码平台"><a href="#接码平台" class="headerlink" title="接码平台"></a>接码平台</h2><p><a href="https://sms-activate.org/">https://sms-activate.org/</a></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401101817546.png" alt="sms-active"></p><p>使用：</p><ol><li>先注册登录</li><li>点击右上角的余额，下拉点击充值</li><li>选择支付宝账号充值<ol><li>PS：这个最低充值2美元，最开始没有最低额度的，因为chatgpt爆火，大量国人涌入，导致平台抬高了充值的价格，而且支付金额低于10美元时，佣金为3% + 0.03美元,要是有其他充值方式也可以不用选择这个</li></ol></li><li>我充值了10美元，付款之后直接到账</li><li>点击左侧的服务列表中的openai服务，选中</li></ol><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401102422546.png" alt="充值"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401103201659.png" alt="支付宝付账"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401103224631.png" alt="余额到账"></p><p>选择openai服务</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401103329973.png" alt="openai服务"></p><p>看一下价格，选一个价格低的。</p><p>一个国家有两个价格，前一个是批发价，后一个是零售价，选后面数字低的</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401103354931.png" alt="服务计费"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401103524271.png" alt="chatgpt注册界面"></p><p>目前直接使用邮箱的方式基本已经走不通了</p><p>提示</p><ul><li>Signup is currently unavailable, please try again later.</li><li>Signup is temporarily unavailable, please check back in an hour.</li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401104628175.png" alt="邮箱注册失败"></p><h2 id="注册Google账号"><a href="#注册Google账号" class="headerlink" title="注册Google账号"></a>注册Google账号</h2><p>目前依然有效的方式，Google账号</p><p>打开一个新的无痕窗口<img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401105204540.png" alt="打开无痕窗口"></p><p>访问：<a href="https://accounts.google.com/%EF%BC%8C">https://accounts.google.com/，</a> <a href="https://accounts.google.com/">点击这里直达</a></p><p>语言选择English</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401105334977.png" alt="google account"></p><p>点击创建个人账号</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401105524521.png" alt="personal"></p><p>填写自己的账号密码</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401105936622.png" alt="填写个人信息"></p><p>确认你的手机号</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110402177.png" alt="手机号"></p><p>去刚刚注册的sms接码平台购买一个最便宜的Google服务虚拟号</p><p>我选的是印度尼西亚</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110333516.png" alt="界面平台购买虚拟号"></p><p>把接码平台的号码粘帖进去并点击next</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110549793.png" alt="复制虚拟号"></p><p>如果出现：This phone number cannot be used for verification.</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110637406.png" alt="此号码不行"></p><p>去接码平台在重新选一个，先把当前激活的×掉，这样刚刚的费用就会推给你(如果20分钟之内没收到短信也会退给你，还是蛮良心的)</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110730672.png" alt="重新购买，先取消之前的"></p><p>我又重新选了一个巴西的账号，就成功验证了</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110856271.png" alt="新的手机号"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110922420.png" alt="刷新得到验证码"></p><p>验证码通过之后，填写自己的相关信息，生日和性别</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401110957528.png" alt="信息填写"></p><p>skip</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111058674.png" alt="skip"></p><p>aggre政策</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111141359.png" alt="aggre政策"></p><p>google账号申请完成！</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111220408.png" alt="Google账号"></p><h2 id="注册ChatGPT"><a href="#注册ChatGPT" class="headerlink" title="注册ChatGPT"></a>注册ChatGPT</h2><p>重新登录<a href="https://chat.openai.com/">https://chat.openai.com/</a></p><p>选择continue as google</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111313316.png" alt="continue as google"></p><p>选择你刚刚注册的google邮箱</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111354046.png" alt="选择邮箱"></p><p>成功进入手机号验证环节！</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111431485.png" alt="验证通过"></p><p>再次到接码平台，选择openai服务，购买一个虚拟账号</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111517641.png" alt="解码平台购买openai虚拟号"></p><p>填写手机号并点击NO，然后点击send code via sms</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111716571.png" alt="via sms"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111808206.png" alt="验证码"></p><p>填写验证码</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111747815.png" alt="填写验证码"></p><p>chatgpt申请成功！</p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111904599.png" alt="success"></p><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/image-20230401111928871.png" alt="第一个问题"></p>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>ChatGPT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指offer-easy</title>
    <link href="/2023/03/16/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer-easy/"/>
    <url>/2023/03/16/%E5%88%B7%E9%A2%98/%E5%89%91%E6%8C%87offer-easy/</url>
    
    <content type="html"><![CDATA[<p>剑指offer 11</p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>给你一个可能存在 <strong>重复</strong> 元素值的数组 <code>numbers</code> ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的<strong>最小元素</strong>。例如，数组 <code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为 1。</p><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 旋转一次 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[3,4,5,1,2]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：numbers = <span class="hljs-string">[2,2,2,0,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>剑指offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>剑指offer</tag>
      
      <tag>easy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯专题</title>
    <link href="/2023/02/27/%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    <url>/2023/02/27/%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>总结：</p><ol><li><p>回溯其实是一种大而全的动规，把n-1的结果和第n个元素进行特殊的操作，即可得到结果</p></li><li><p>46的全排列，引入flag进行元素排除，他的算子方式通过for循环执行的，这种可以是无序的结果元素的顺序跟输入可能不一致</p></li><li><p>39的组合和，引入n进行天然的元素排除+算子，这种特点是有顺序，算子是选择当前或者不选，这种结果通过结果元素属性和输入是一致的</p></li><li><p>回溯算法总结</p><ol><li>递进式，这种题目不走回头路，只会选择当前及其后面的元素，所以不用循环，只需要考虑当前的元素选还是不选的问题。类似的题目77、78</li><li>遍历式，这种是可以走回头路的，是在for循环中，不断从头开始进行寻找，可以用一个布尔类型的数组来判断当前的元素是否被选中，类似的题目46、47、79</li><li>批量递进式，在递归时一次性地处理重复数，通常用于去重，类似题目40</li></ol></li><li><p>回溯去重算法总结</p><ol><li><p>回溯的去重算法</p><ol><li><p>保证重复元素，从左到右只选择第一次出现的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">i</span> &gt; <span class="hljs-number">0</span> &amp;&amp; nums<span class="hljs-selector-attr">[i - 1]</span> == nums<span class="hljs-selector-attr">[i]</span> &amp;&amp; !flags<span class="hljs-selector-attr">[i - 1]</span><br><br><span class="hljs-selector-attr">[1,2,2,2,3]</span><br>只会选择最左边出现的<span class="hljs-number">2</span>，以及以它打头的<span class="hljs-selector-attr">[2,2]</span>和<span class="hljs-selector-attr">[2,2,2]</span><br></code></pre></td></tr></table></figure></li><li><p>把重复的元素合并一起计算</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> most = Math.min(rest / freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>], freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">1</span>]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; ++i) &#123;<br>    <span class="hljs-keyword">sequence</span>.<span class="hljs-keyword">add</span>(freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>    dfs(pos + <span class="hljs-number">1</span>, rest - i * freq.<span class="hljs-keyword">get</span>(pos)[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= most; ++i) &#123;<br>    <span class="hljs-keyword">sequence</span>.remove(<span class="hljs-keyword">sequence</span>.size() - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>[1,2,2,3]</p><p>第一种方式，2,2并不要求放在一起，可以是2,1,2或者2,3,2这种，它只对打头的2做出要求，必须是最左边的</p><p>lt47这种写法，就允许不同的2分开。对于lt90这种写法就重复的2就是放在一起的，</p><p>第二种方式，2,2需要放在一起，它更像是作为一个整体，类似lt40</p><p>待验证，lt40和lt90，算法互通，lt90是找子集，lt40是求符合要求的组合，本质是找一种特殊的子集</p></li></ol></li><li><p>优化思路：通常是进行一定的剪枝，即根据特定的场景，不在进行递归而是直接返回，减少回溯的次数从而优化</p></li><li><p>时间复杂度通常都是(n * n!)</p></li><li><p>解题的核心就是找算子的种类，只要找到算子，然后在算子前面添加元素，在算子后面删除元素，问题解决！</p><ol><li>数组当前元素加或者不加</li><li>数组当前一部分元素加或者不加</li><li>方阵的四方方向</li></ol></li></ol><hr><p>LeetCode39 组合总和</p><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：candidates = [2,3,6,7], target = 7<br>输出：[[2,2,3],[7]]<br>解释：<br>2 和<span class="hljs-number"> 3 </span>可以形成一组候选，2 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。注意<span class="hljs-number"> 2 </span>可以使用多次。<br>7 也是一个候选，<span class="hljs-number"> 7 </span>=<span class="hljs-number"> 7 </span>。<br>仅有这两种组合。<br></code></pre></td></tr></table></figure><hr><p>LeetCode40 组合总和2z(nonono)</p><p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p><p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p><p><strong>注意：</strong>解集不能包含重复的组合。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: candidates = <span class="hljs-comment">[10,1,2,7,6,1,5]</span>, target = 8, 输出: <span class="hljs-comment">[ <span class="hljs-comment">[1,1,6]</span>, <span class="hljs-comment">[1,2,5]</span>, <span class="hljs-comment">[1,7]</span>, <span class="hljs-comment">[2,6]</span> ]</span><br><br>输入: candidates = <span class="hljs-comment">[2,5,2,1,2]</span>, target = 5, 输出: <span class="hljs-comment">[ <span class="hljs-comment">[1,2,2]</span>, <span class="hljs-comment">[5]</span> ]</span><br></code></pre></td></tr></table></figure><p>由于我们需要求出所有和为 <em>target</em> 的组合，并且每个数只能使用一次，因此我们可以使用递归 + 回溯的方法来解决这个问题：</p><ul><li>我们用 <em>dfs</em>(<em>pos</em>,<em>rest</em>) 表示递归的函数，其中 <em>pos</em> 表示我们当前递归到了数组 <em>candidates</em> 中的第 <em>pos</em> 个数，而 <em>rest</em> 表示我们还需要选择和为 <em>rest</em> 的数放入列表作为一个组合；</li><li>对于当前的第 <em>pos</em> 个数，我们有两种方法：选或者不选。如果我们选了这个数，那么我们调用 <em>dfs</em>(<em>pos</em>+1,<em>rest</em>−<em>candidates</em>[<em>pos</em>]) 进行递归，注意这里必须满足 <em>rest</em>≥<em>candidates</em>[<em>pos</em>]。如果我们不选这个数，那么我们调用 <em>dfs</em>(<em>pos</em>+1,<em>rest</em>) 进行递归；</li><li>在某次递归开始前，如果 <em>rest</em> 的值为 0，说明我们找到了一个和为 <em>target</em> 的组合，将其放入答案中。每次调用递归函数前，如果我们选了那个数，就需要将其放入列表的末尾，该列表中存储了我们选的所有数。在回溯时，如果我们选了那个数，就要将其从列表的末尾删除。</li></ul><p>上述算法就是一个标准的递归 + 回溯算法，但是它并不适用于本题。这是因为题目描述中规定了<strong>解集不能包含重复的组合</strong>，而上述的算法中并没有去除重复的组合。</p><blockquote><p>例如当 <em>candidates</em>&#x3D;[2,2]，<em>target</em>&#x3D;2 时，上述算法会将列表 [2] 放入答案两次。</p></blockquote><p>因此，我们需要改进上述算法，在求出组合的过程中就进行去重的操作。我们可以考虑<strong>将相同的数放在一起进行处理</strong>，也就是说，如果数 <em>x</em> 出现了 <em>y</em> 次，那么在递归时一次性地处理它们，即分别调用选择 0,1,⋯,<em>y</em> 次 <em>x</em> 的递归函数。这样我们就不会得到重复的组合。具体地：</p><ul><li><p>我们使用一个哈希映射（HashMap）统计数组 <em>candidates</em> 中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 <em>freq</em> 中，方便后续的递归使用。</p><ul><li>列表 <em>freq</em> 的长度即为数组 <em>candidates</em> 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。</li></ul></li><li><p>在递归时，对于当前的第 <em>pos</em> 个数，它的值为 <em>freq</em>[pos][0]，出现的次数为 <em>freq</em>[<em>pos</em>][1]，那么我们可以调用</p><p><em>dfs</em>(<em>pos</em>+1,<em>rest</em>−<em>i</em>×<em>freq</em>[<em>pos</em>][0])</p><p>即我们选择了这个数 <em>i</em> 次。这里 <em>i</em> 不能大于这个数出现的次数，并且 <em>i</em>×<em>freq</em>[<em>pos</em>][0] 也不能大于 <em>rest</em>。同时，我们需要将 <em>i</em> 个 <em>freq</em>[<em>pos</em>][0] 放入列表中。</p></li></ul><p>这样一来，我们就可以不重复地枚举所有的组合了。</p><p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 <em>freq</em> 根据数从小到大排序，这样我们在递归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 <em>dfs</em>(<em>pos</em>,<em>rest</em>) 时，如果 <em>freq</em>[<em>pos</em>][0] 已经大于 <em>rest</em>，那么后面还没有递归到的数也都大于 <em>rest</em>，这就说明不可能再选择若干个和为 <em>rest</em> 的数放入列表了。此时，我们就可以直接回溯。</p><hr><p>LeetCode46 全排列</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[0,1],[1,0]]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">1</span>]<br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode47 全排列2</p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：<br><span class="hljs-comment">[<span class="hljs-comment">[1,1,2]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[2,1,1]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1,2,3]</span>,<span class="hljs-comment">[1,3,2]</span>,<span class="hljs-comment">[2,1,3]</span>,<span class="hljs-comment">[2,3,1]</span>,<span class="hljs-comment">[3,1,2]</span>,<span class="hljs-comment">[3,2,1]</span>]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode77 组合</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：n = 4, k = 2<br>输出：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[3,4]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[2,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,2]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,4]</span>,</span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode78 子集</p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,2,3]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode79 单词搜索</p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="/assets/word2.jpg" alt="img"></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：board = [[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>],[<span class="hljs-string">&quot;S&quot;</span>,<span class="hljs-string">&quot;F&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;S&quot;</span>],[<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>]], word = <span class="hljs-string">&quot;ABCCED&quot;</span><br>输出：true<br></code></pre></td></tr></table></figure><p>LeetCode90 子集2</p><p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,2,2]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[]</span>,<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[1,2]</span>,<span class="hljs-comment">[1,2,2]</span>,<span class="hljs-comment">[2]</span>,<span class="hljs-comment">[2,2]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：nums = [<span class="hljs-number">0</span>]<br>输出：<span class="hljs-string">[[],[0]]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode131 分隔回文串</p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure><hr><p>LeetCode216 组合总和3</p><p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><p><strong>示例 1:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: k = <span class="hljs-number">3</span>, n = <span class="hljs-number">7</span><br>输出: <span class="hljs-string">[[1,2,4]]</span><br>解释:<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> = <span class="hljs-number">7</span><br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 +<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 6 </span>= 9<br>1 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 5 </span>= 9<br>2 +<span class="hljs-number"> 3 </span>+<span class="hljs-number"> 4 </span>= 9<br>没有其他符合的组合了。<br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: k = 4, n = 1</span><br><span class="hljs-section">输出: []</span><br><span class="hljs-section">解释: 不存在有效的组合。</span><br>在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。<br></code></pre></td></tr></table></figure><p>LeetCode131 分割回文子串</p><p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;aab&quot;</span><br>输出：[[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>],[<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>]]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;a&quot;</span><br>输出：<span class="hljs-string">[[&quot;a&quot;]]</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树medium专题</title>
    <link href="/2023/02/10/%E5%88%B7%E9%A2%98/%E6%A0%91medium%E4%B8%93%E9%A2%98/"/>
    <url>/2023/02/10/%E5%88%B7%E9%A2%98/%E6%A0%91medium%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode95-不同的搜索二叉树2-yes"><a href="#LeetCode95-不同的搜索二叉树2-yes" class="headerlink" title="LeetCode95 不同的搜索二叉树2 (yes)"></a>LeetCode95 不同的搜索二叉树2 (yes)</h2><h4 id="（1）题目："><a href="#（1）题目：" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">n</span> = <span class="hljs-number">3</span><br>输出：[[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">1</span>]]<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：n = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[[1]]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路："><a href="#（2）思路：" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>定义 <code>generate(start, end)</code> 函数表示当前值的集合为 [<em>start</em>,<em>end</em>]，返回序列 [<em>start</em>,<em>end</em>] 生成的所有可行的二叉搜索树。按照上文的思路，我们考虑枚举 [<em>start</em>,<em>end</em>] 中的值 <em>i</em> 为当前二叉搜索树的根，那么序列划分为了 [<em>start</em>,<em>i</em>−1] 和 [<em>i</em>+1,<em>end</em>] 两部分。我们递归调用这两部分，即 <code>generate(start, i - 1)</code> 和 <code>generate(i + 1, end)</code>，获得所有可行的左子树和可行的右子树，那么最后一步我们只要从可行左子树集合中选一棵，再从可行右子树集合中选一棵拼接到根节点上，并将生成的二叉搜索树放入答案数组即可。</p><h4 id="（3）代码："><a href="#（3）代码：" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n);<br>&#125;<br><br><br><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    List&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>        nodes.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> nodes;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>        List&lt;TreeNode&gt; lefts = generate(start, i - <span class="hljs-number">1</span>);<br>        List&lt;TreeNode&gt; rights = generate(i + <span class="hljs-number">1</span>, end);<br>        <span class="hljs-keyword">for</span> (TreeNode node : lefts) &#123;<br>            <span class="hljs-keyword">for</span> (TreeNode treeNode : rights) &#123;<br>                <span class="hljs-comment">// 生成root节点时，必须要在内层嵌套循环中生成，如果在外层会导致其引用被覆盖生成相同的子树</span><br>                <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(i);<br>                root.left = node.val == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : node;<br>                root.right = treeNode.val == <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : treeNode;<br>                nodes.add(root);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode96-不同的搜索二叉树-no"><a href="#LeetCode96-不同的搜索二叉树-no" class="headerlink" title="LeetCode96 不同的搜索二叉树 (no)"></a>LeetCode96 不同的搜索二叉树 (no)</h2><h4 id="（1）题目：-1"><a href="#（1）题目：-1" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">3</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-1"><a href="#（2）思路：-1" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>设定dp[n]数组定义：长度为n时存在多少个不同二叉树的种类</p><p>状态转义公式：dp[n] &#x3D; dp[i-1]*dp[n-i], 1&lt;&#x3D;i&lt;&#x3D;n</p><h4 id="（3）代码：-1"><a href="#（3）代码：-1" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            dp[i] += dp[j] * dp[i - <span class="hljs-number">1</span> - j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode98-验证二叉树-yes"><a href="#LeetCode98-验证二叉树-yes" class="headerlink" title="LeetCode98 验证二叉树 (yes)"></a>LeetCode98 验证二叉树 (yes)</h2><h4 id="（1）题目：-2"><a href="#（1）题目：-2" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><h4 id="（2）思路：-2"><a href="#（2）思路：-2" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>自己的解法<ul><li>递归(错误)，只考虑的根节点和左右子树的根节点的大小关系，没考虑和孙子节点的关系</li><li>中序遍历(正确)，中序遍历二叉搜索树，如何符合则应该是从小到大的排序</li></ul></li><li>官方题解递归的解法<ul><li>设计一个递归函数 <code>helper(root, lower, upper)</code> 来递归判断，函数表示考虑以 <code>root</code> 为根的子树，判断子树中所有节点的值是否都在 (<em>l</em>,<em>r</em>) 的范围内（<strong>注意是开区间</strong>）。如果 <code>root</code> 节点的值 <code>val</code> 不在 (<em>l</em>,<em>r</em>) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</li><li>那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 <code>upper</code> 改为 <code>root.val</code>，即调用 <code>helper(root.left, lower, root.val)</code>，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 <code>lower</code> 改为 <code>root.val</code>，即调用 <code>helper(root.right, root.val, upper)</code>。</li><li>函数递归调用的入口为 <code>helper(root, -inf, +inf)</code>， <code>inf</code> 表示一个无穷大的值。</li></ul></li></ul><h4 id="（3）代码：-2"><a href="#（3）代码：-2" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个解法错误，没有考虑[5,4,6,null,null,3,7]这种场景</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST1</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isValidBST1(root.left)<br>            &amp;&amp; isValidBST1(root.right)<br>            &amp;&amp; (<span class="hljs-literal">null</span> == root.left || root.val &gt; root.left.val)<br>            &amp;&amp; (<span class="hljs-literal">null</span> == root.right || root.val &lt; root.right.val);<br>&#125;<br><br><span class="hljs-comment">// 中序解法</span><br><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValidBST</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> isValidBST(root.left);<br>    <span class="hljs-keyword">if</span> (!left) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((res.size() &gt; <span class="hljs-number">0</span> &amp;&amp; res.get(res.size() - <span class="hljs-number">1</span>) &gt;= root.val)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res.add(root.val);<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> isValidBST(root.right);<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode99-恢复二叉树-no"><a href="#LeetCode99-恢复二叉树-no" class="headerlink" title="LeetCode99 恢复二叉树(no)"></a>LeetCode99 恢复二叉树(no)</h2><h4 id="（1）题目：-3"><a href="#（1）题目：-3" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>] 输出：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p><strong>进阶：</strong>使用 <code>O(n)</code> 空间复杂度的解法很容易实现。你能想出一个只使用 <code>O(1)</code> 空间的解决方案吗？</p><h4 id="（2）思路：-3"><a href="#（2）思路：-3" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>先通过先序遍历获取数组，校验数据的排序数</p><h4 id="（3）代码：-3"><a href="#（3）代码：-3" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    List&lt;TreeNode&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    goThrough(root, list);<br>    List&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; list.size(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (list.get(i - <span class="hljs-number">1</span>).val &gt; list.get(i).val) &#123;<br>            res.add(list.get(i - <span class="hljs-number">1</span>));<br>            res.add(list.get(i));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (res.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> res.get(<span class="hljs-number">0</span>).val;<br>        res.get(<span class="hljs-number">0</span>).val = res.get(res.size() - <span class="hljs-number">1</span>).val;<br>        res.get(res.size() - <span class="hljs-number">1</span>).val = temp;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goThrough</span><span class="hljs-params">(TreeNode root, List&lt;TreeNode&gt; list)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    goThrough(root.left, list);<br>    list.add(root);<br>    goThrough(root.right, list);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode102-二叉树的层序遍历"><a href="#LeetCode102-二叉树的层序遍历" class="headerlink" title="LeetCode102 二叉树的层序遍历"></a>LeetCode102 二叉树的层序遍历</h2><h4 id="（1）题目：-4"><a href="#（1）题目：-4" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><h4 id="（2）思路：-4"><a href="#（2）思路：-4" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-4"><a href="#（3）代码：-4" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    Deque&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    nodes.addLast(root);<br>    List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNode</span> <span class="hljs-operator">=</span> nodes.removeFirst();<br>        level.add(treeNode.val);<br>        up--;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != treeNode.left) &#123;<br>            nodes.addLast(treeNode.left);<br>            down++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != treeNode.right) &#123;<br>            nodes.addLast(treeNode.right);<br>            down++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (up == <span class="hljs-number">0</span>) &#123;<br>            res.add(level);<br>            level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            up = down;<br>            down = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode107-二叉树层序遍历"><a href="#LeetCode107-二叉树层序遍历" class="headerlink" title="LeetCode107 二叉树层序遍历"></a>LeetCode107 二叉树层序遍历</h2><h4 id="（1）题目：-5"><a href="#（1）题目：-5" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[3,9,20,null,null,15,7]</span> 输出：<span class="hljs-comment">[<span class="hljs-comment">[15,7]</span>,<span class="hljs-comment">[9,20]</span>,<span class="hljs-comment">[3]</span>]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-5"><a href="#（2）思路：-5" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-5"><a href="#（3）代码：-5" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrderBottom</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    queue.addLast(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>        list.add(node.val);<br>        up--;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != node.left) &#123;<br>            queue.addLast(node.left);<br>            down++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != node.right) &#123;<br>            queue.addLast(node.right);<br>            down++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == up) &#123;<br>            nodes.add(<span class="hljs-number">0</span>, list);<br>            list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            up = down;<br>            down = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nodes;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode109-有序链表转为二叉搜索树"><a href="#LeetCode109-有序链表转为二叉搜索树" class="headerlink" title="LeetCode109 有序链表转为二叉搜索树"></a>LeetCode109 有序链表转为二叉搜索树</h2><h4 id="（1）题目：-6"><a href="#（1）题目：-6" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个单链表的头节点 <code>head</code> ，其中的元素 <strong>按升序排序</strong> ，将其转换为高度平衡的二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差不超过 1。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: head = [<span class="hljs-string">-10</span>,<span class="hljs-string">-3</span>,0,5,9] 输出: [0,<span class="hljs-string">-3</span>,9,<span class="hljs-string">-10</span>,null,5]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-6"><a href="#（2）思路：-6" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-6"><a href="#（3）代码：-6" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 先转成数组，在组成树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedListToBST</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == head) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    List&lt;Integer&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        values.add(head.val);<br>        head = head.next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sortedArray(values, <span class="hljs-number">0</span>, values.size() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArray</span><span class="hljs-params">(List&lt;Integer&gt; values, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s &gt; e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s == e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(values.get(e));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (e - s == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(values.get(s));<br>        root.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(values.get(e));<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (e + s) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(values.get(mid));<br>    root.left = sortedArray(values, s, mid - <span class="hljs-number">1</span>);<br>    root.right = sortedArray(values, mid + <span class="hljs-number">1</span>, e);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode114-二叉树展开为链表"><a href="#LeetCode114-二叉树展开为链表" class="headerlink" title="LeetCode114 二叉树展开为链表"></a>LeetCode114 二叉树展开为链表</h2><h4 id="（1）题目：-7"><a href="#（1）题目：-7" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>] 输出：[<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-7"><a href="#（2）思路：-7" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-7"><a href="#（3）代码：-7" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    add(root, res);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">assembly</span> <span class="hljs-operator">=</span> assembly(res);<br>    root.val = assembly.val;<br>    root.left = <span class="hljs-literal">null</span>;<br>    root.right = assembly.right;<br>&#125;<br><br><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title function_">assembly</span><span class="hljs-params">(List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == res || res.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(res.get(<span class="hljs-number">0</span>));<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; res.size(); i++) &#123;<br>        index.right = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(res.get(i));<br>        index = index.right;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    res.add(root.val);<br>    add(root.left, res);<br>    add(root.right, res);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 官方题解，可以一边遍历一边赋值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatten1</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;TreeNode&gt;();<br>    stack.push(root);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>            prev.left = <span class="hljs-literal">null</span>;<br>            prev.right = curr;<br>        &#125;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> curr.left, right = curr.right;<br>        <span class="hljs-keyword">if</span> (right != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(left);<br>        &#125;<br>        prev = curr;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 非递归先序遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">rlr</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    Deque&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    nodes.addLast(root);<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNode</span> <span class="hljs-operator">=</span> nodes.removeLast();<br>        res.add(treeNode.val);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != treeNode.right) &#123;<br>            nodes.addLast(treeNode.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != treeNode.left) &#123;<br>            nodes.addLast(treeNode.left);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode116-填充每个节点的下一个右侧节点指针-no"><a href="#LeetCode116-填充每个节点的下一个右侧节点指针-no" class="headerlink" title="LeetCode116 填充每个节点的下一个右侧节点指针(no)"></a>LeetCode116 填充每个节点的下一个右侧节点指针(no)</h2><h4 id="（1）题目：-8"><a href="#（1）题目：-8" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><br><span class="hljs-title">  int</span> val;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<br>  <span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p><p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><h4 id="（2）思路：-8"><a href="#（2）思路：-8" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>利用队列来实现，需要额外的队列空间</li><li>优化思路：每一层都相当于是一个链表，不用放在队列而直接遍历上一层链表</li></ul><h4 id="（3）代码：-8"><a href="#（3）代码：-8" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    Deque&lt;Node&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    deque.addLast(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">up</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">down</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (!deque.isEmpty()) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> deque.removeFirst();<br>        up--;<br><br>        <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>) &#123;<br>            last = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            last.next = node;<br>            last = last.next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            deque.addLast(node.left);<br>            down++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            deque.addLast(node.right);<br>            down++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (up == <span class="hljs-number">0</span>) &#123;<br>            up = down;<br>            down = <span class="hljs-number">0</span>;<br>            node.next = <span class="hljs-literal">null</span>;<br>            last = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 优化思路</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">connect2</span><span class="hljs-params">(Node root)</span> &#123;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//cur我们可以把它看做是每一层的链表</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//遍历当前层的时候，为了方便操作在下一</span><br>            <span class="hljs-comment">//层前面添加一个哑结点（注意这里是访问</span><br>            <span class="hljs-comment">//当前层的节点，然后把下一层的节点串起来）</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-comment">//pre表示访下一层节点的前一个节点</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummy;<br>            <span class="hljs-comment">//然后开始遍历当前层的链表</span><br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (cur.left != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">//如果当前节点的左子节点不为空，就让pre节点</span><br>                    <span class="hljs-comment">//的next指向他，也就是把它串起来</span><br>                    pre.next = cur.left;<br>                    <span class="hljs-comment">//然后再更新pre</span><br>                    pre = pre.next;<br>                &#125;<br>                <span class="hljs-comment">//同理参照左子树</span><br>                <span class="hljs-keyword">if</span> (cur.right != <span class="hljs-literal">null</span>) &#123;<br>                    pre.next = cur.right;<br>                    pre = pre.next;<br>                &#125;<br>                <span class="hljs-comment">//继续访问这一行的下一个节点</span><br>                cur = cur.next;<br>            &#125;<br>            <span class="hljs-comment">//把下一层串联成一个链表之后，让他赋值给cur，</span><br>            <span class="hljs-comment">//后续继续循环，直到cur为空为止</span><br>            cur = dummy.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode129-根节点到叶节点之和"><a href="#LeetCode129-根节点到叶节点之和" class="headerlink" title="LeetCode129 根节点到叶节点之和"></a>LeetCode129 根节点到叶节点之和</h2><h4 id="（1）题目：-9"><a href="#（1）题目：-9" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个二叉树的根节点 <code>root</code> ，树中每个节点都存放有一个 <code>0</code> 到 <code>9</code> 之间的数字。</p><p>每条从根节点到叶节点的路径都代表一个数字：</p><ul><li>例如，从根节点到叶节点的路径 <code>1 -&gt; 2 -&gt; 3</code> 表示数字 <code>123</code> 。</li></ul><p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p><p><strong>叶节点</strong> 是指没有子节点的节点。</p><h4 id="（2）思路：-9"><a href="#（2）思路：-9" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>先存入队列中，然后到叶子节点则计算当前路径的值</li><li>需要注意的是，这里用到了回溯，一个add对应一个remove</li></ul><h4 id="（3）代码：-9"><a href="#（3）代码：-9" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumNumbers</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    add(root);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 回溯add值</span><br>    res.add(root.val);<br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">revert</span> <span class="hljs-operator">=</span> revert(res);<br>        sum += revert;<br>    &#125;<br><br>    add(root.left);<br>    add(root.right);<br>  <span class="hljs-comment">// 回溯remove值</span><br>    <span class="hljs-keyword">if</span> (res.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        res.remove(res.size() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">revert</span><span class="hljs-params">(List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span> (res.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> res.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        count += l * res.get(i);<br>        l = l * <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>树</tag>
      
      <tag>medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树easy专题</title>
    <link href="/2023/02/07/%E5%88%B7%E9%A2%98/%E6%A0%91easy%E4%B8%93%E9%A2%98/"/>
    <url>/2023/02/07/%E5%88%B7%E9%A2%98/%E6%A0%91easy%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>树跟链表一样，很多场景可以使用递归求解</li></ol><h2 id="LeetCode94-二叉树的中序遍历-yes"><a href="#LeetCode94-二叉树的中序遍历-yes" class="headerlink" title="LeetCode94 二叉树的中序遍历 (yes)"></a>LeetCode94 二叉树的中序遍历 (yes)</h2><h4 id="（1）题目："><a href="#（1）题目：" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><h4 id="（2）思路："><a href="#（2）思路：" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>- </p><h4 id="（3）代码："><a href="#（3）代码：" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前序：根左右</span><br><span class="hljs-comment"> * 中序：左根右</span><br><span class="hljs-comment"> * 后序：左右根</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    addTree(root);<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    addTree(root.left);<br>    result.add(root.val);<br>    addTree(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode100-相同的树-yes"><a href="#LeetCode100-相同的树-yes" class="headerlink" title="LeetCode100 相同的树 (yes)"></a>LeetCode100 相同的树 (yes)</h2><h4 id="（1）题目：-1"><a href="#（1）题目：-1" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><h4 id="（2）思路：-1"><a href="#（2）思路：-1" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>- </p><h4 id="（3）代码：-1"><a href="#（3）代码：-1" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSameTree</span><span class="hljs-params">(TreeNode p, TreeNode q)</span> &#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> &amp;&amp; q == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p.val == q.val<br>            &amp;&amp; isSameTree(p.left, q.left)<br>            &amp;&amp; isSameTree(p.right, q.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode101-对称二叉树-yes"><a href="#LeetCode101-对称二叉树-yes" class="headerlink" title="LeetCode101 对称二叉树 (yes)"></a>LeetCode101 对称二叉树 (yes)</h2><h4 id="（1）题目：-2"><a href="#（1）题目：-2" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><h4 id="（2）思路：-2"><a href="#（2）思路：-2" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>- </p><h4 id="（3）代码：-2"><a href="#（3）代码：-2" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> symmetric(root.left, root.right);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">symmetric</span><span class="hljs-params">(TreeNode left, TreeNode right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-literal">null</span> &amp;&amp; right != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-literal">null</span> &amp;&amp; right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> left.val == right.val &amp;&amp; symmetric(left.right, right.left) &amp;&amp; symmetric(left.left, right.right);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode104-二叉树的最大深度-yes"><a href="#LeetCode104-二叉树的最大深度-yes" class="headerlink" title="LeetCode104 二叉树的最大深度 (yes)"></a>LeetCode104 二叉树的最大深度 (yes)</h2><h4 id="（1）题目：-3"><a href="#（1）题目：-3" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><h4 id="（2）思路：-3"><a href="#（2）思路：-3" class="headerlink" title="（2）思路："></a>（2）思路：</h4><p>- </p><h4 id="（3）代码：-3"><a href="#（3）代码：-3" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode108-将有序数组转为二叉搜索树-yes"><a href="#LeetCode108-将有序数组转为二叉搜索树-yes" class="headerlink" title="LeetCode108 将有序数组转为二叉搜索树 (yes)"></a>LeetCode108 将有序数组转为二叉搜索树 (yes)</h2><h4 id="（1）题目：-4"><a href="#（1）题目：-4" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p><p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><h4 id="（2）思路：-4"><a href="#（2）思路：-4" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>只要左右子树是平衡二叉树，那么当前树就是平衡二叉树</li></ul><h4 id="（3）代码：-4"><a href="#（3）代码：-4" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == nums || <span class="hljs-number">0</span> == nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildBST(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">buildBST</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> e)</span> &#123;<br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span> || e &lt; <span class="hljs-number">0</span> || s &gt;= nums.length || e &gt;= nums.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s == e) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[s]);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (e - s == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[s]);<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[e]);<br>        root.left = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (e + s) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> buildBST(nums, s, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> buildBST(nums, mid + <span class="hljs-number">1</span>, e);<br>    root.left = left;<br>    root.right = right;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 官方解法，更简洁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 总是选择中间位置左边的数字作为根节点</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (left + right) / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(nums[mid]);<br>    root.left = helper(nums, left, mid - <span class="hljs-number">1</span>);<br>    root.right = helper(nums, mid + <span class="hljs-number">1</span>, right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode110-判断平衡二叉树-no"><a href="#LeetCode110-判断平衡二叉树-no" class="headerlink" title="LeetCode110 判断平衡二叉树 (no)"></a>LeetCode110 判断平衡二叉树 (no)</h2><h4 id="（1）题目：-5"><a href="#（1）题目：-5" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p></blockquote><h4 id="（2）思路：-5"><a href="#（2）思路：-5" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>自顶向下，暴力法，时间复杂度Nlongn</li><li>自底向上，时间复杂度为N，最优解。思考：就是在遍历的过程中加上剪枝，当高度超过2，必定不是平衡树，-1这个结果会向上传递</li></ul><h4 id="（3）代码：-5"><a href="#（3）代码：-5" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自顶向下，暴力法，时间复杂度Nlongn</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.abs(maxDepth(root.left) - maxDepth(root.right)) &lt;= <span class="hljs-number">1</span><br>            &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自底向上，时间复杂度为N，最优解</span><br><span class="hljs-comment"> * 思考：就是在遍历的过程中加上剪枝，当高度超过2，必定不是平衡树，-1这个结果会向上传递</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBalanced2</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">return</span> recur(root) != -<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> recur(root.left);<br>    <span class="hljs-keyword">if</span> (left == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> recur(root.right);<br>    <span class="hljs-keyword">if</span> (right == -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Math.abs(left - right) &lt; <span class="hljs-number">2</span> ? Math.max(left, right) + <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode111-二叉树最小深度-no"><a href="#LeetCode111-二叉树最小深度-no" class="headerlink" title="LeetCode111 二叉树最小深度 (no)"></a>LeetCode111 二叉树最小深度 (no)</h2><h4 id="（1）题目：-6"><a href="#（1）题目：-6" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p><h4 id="（2）思路：-6"><a href="#（2）思路：-6" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>非递归解法，使用栈，先进先出<ul><li>记录当前层和下一层节点数量</li><li>记录层的高度</li><li>当节点的左右子节点为null，返回层的高度，因为是第一个遇到的，所以是最小高度</li></ul></li><li>递归解法<ul><li>左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</li><li>如果左孩子和由孩子其中一个为空，那么<strong>需要返回比较大的那个孩子的深度</strong></li><li>最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</li></ul></li></ul><h4 id="（3）代码：-6"><a href="#（3）代码：-6" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Deque&lt;TreeNode&gt; nodes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    nodes.push(root);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">level</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countUp</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countDown</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (!nodes.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> nodes.removeFirst();<br>        countUp--;<br><br>        <span class="hljs-keyword">if</span> (pop.left == <span class="hljs-literal">null</span> &amp;&amp; pop.right == <span class="hljs-literal">null</span>) &#123;<br><br>            <span class="hljs-keyword">return</span> level;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != pop.left) &#123;<br>            nodes.addLast(pop.left);<br>            countDown++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != pop.right) &#123;<br>            nodes.addLast(pop.right);<br>            countDown++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (countUp == <span class="hljs-number">0</span>) &#123;<br>            countUp = countDown;<br>            countDown = <span class="hljs-number">0</span>;<br>            level++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> level;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDepth1</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 这道题递归条件里分为三种情况</span><br>    <span class="hljs-comment">// 1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> minDepth(root.left);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> minDepth(root.right);<br>    <span class="hljs-comment">// 这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span><br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> || root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> m1 + m2 + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span><br>    <span class="hljs-keyword">return</span> Math.min(m1, m2) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode112-路径总和-yes"><a href="#LeetCode112-路径总和-yes" class="headerlink" title="LeetCode112 路径总和 (yes)"></a>LeetCode112 路径总和 (yes)</h2><h4 id="（1）题目：-7"><a href="#（1）题目：-7" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><h4 id="（2）思路：-7"><a href="#（2）思路：-7" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li><p>自己的思路</p><ul><li>自顶向下，依次计算经过节点的和，判断符合条件则跳出循环</li></ul></li><li><p>题解思路</p><ul><li>这道题提供了一种思路，求和sum，不一定非要+，也可以减</li><li>就像这道题，是从根节点依次减去当前节点的val，然后判断&#x3D;&#x3D;0</li></ul></li></ul><h4 id="（3）代码：-7"><a href="#（3）代码：-7" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    curSum(root, <span class="hljs-number">0</span>, targetSum);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从根节点当当前节点的和</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">curSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    sum += root.val;<br>    <span class="hljs-keyword">if</span> (sum == target &amp;&amp; <span class="hljs-literal">null</span> == root.left &amp;&amp; <span class="hljs-literal">null</span> == root.right) &#123;<br>        res = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    curSum(root.left, sum, target);<br>    curSum(root.right, sum, target);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题解1：DFS解法</span><br><span class="hljs-comment"> * 这道题提供了一种思路，求和sum，不一定非要+，也可以减</span><br><span class="hljs-comment"> * 就像这道题，是从根节点依次减去当前节点的val，然后判断==0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPathSum1</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> sum)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left == <span class="hljs-literal">null</span> &amp;&amp; root.right == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root.val == sum;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hasPathSum1(root.left, sum - root.val) || hasPathSum1(root.right, sum - root.val);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode113-路径总和2-yes"><a href="#LeetCode113-路径总和2-yes" class="headerlink" title="LeetCode113 路径总和2 (yes)"></a>LeetCode113 路径总和2 (yes)</h2><h4 id="（1）题目：-8"><a href="#（1）题目：-8" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><h4 id="（2）思路：-8"><a href="#（2）思路：-8" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>自己的思路<ul><li>自顶向下，dfs&#x2F;回溯的思想</li><li>回溯的关键是需要把在结果不符合的时候需要能够回到之前的状态</li><li>最开始做的时候，在符合条件的地方只add，没有remove，这样会导致多条path时，后续的path会多节点，因为第一条path没有去除</li><li>回溯的思想，有add就要有remove</li></ul></li></ul><h4 id="（3）代码：-8"><a href="#（3）代码：-8" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;List&lt;Integer&gt;&gt; allPaths = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> targetSum)</span> &#123;<br>    count(root, targetSum, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    <span class="hljs-keyword">return</span> allPaths;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">count</span><span class="hljs-params">(TreeNode root, <span class="hljs-type">int</span> tar, List&lt;Integer&gt; path)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root.left &amp;&amp; <span class="hljs-literal">null</span> == root.right &amp;&amp; root.val == tar) &#123;<br>        path.add(root.val);<br>        allPaths.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(path));<br>      <span class="hljs-comment">// 注意这里，需要把结果存入的时候去除</span><br>        path.remove(path.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    path.add(root.val);<br>    count(root.left, tar - root.val, path);<br>    count(root.right, tar - root.val, path);<br>    path.remove(path.size()-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode226-翻转二叉树-yes"><a href="#LeetCode226-翻转二叉树-yes" class="headerlink" title="LeetCode226 翻转二叉树 (yes)"></a>LeetCode226 翻转二叉树 (yes)</h2><h4 id="（1）题目：-9"><a href="#（1）题目：-9" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>输入：</strong>root &#x3D; [4,2,7,1,3,6,9] <strong>输出：</strong>[4,7,2,9,6,3,1]</p><h4 id="（2）思路：-9"><a href="#（2）思路：-9" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-9"><a href="#（3）代码：-9" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title function_">invertTree</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> invertTree(root.left);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> invertTree(root.right);<br>    root.left = right;<br>    root.right = left;<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode257-二叉树的所有路径-yes"><a href="#LeetCode257-二叉树的所有路径-yes" class="headerlink" title="LeetCode257 二叉树的所有路径 (yes)"></a>LeetCode257 二叉树的所有路径 (yes)</h2><h4 id="（1）题目：-10"><a href="#（1）题目：-10" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>输入：</strong>root &#x3D; [4,2,7,1,3,6,9] <strong>输出：</strong>[4,7,2,9,6,3,1]</p><h4 id="（2）思路：-10"><a href="#（2）思路：-10" class="headerlink" title="（2）思路："></a>（2）思路：</h4><h4 id="（3）代码：-10"><a href="#（3）代码：-10" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">binaryTreePaths</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root) &#123;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root.left &amp;&amp; <span class="hljs-literal">null</span> == root.right) &#123;<br>        res.add(<span class="hljs-string">&quot;&quot;</span> + root.val);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    printPath(root.left, <span class="hljs-string">&quot;&quot;</span> + root.val);<br>    printPath(root.right, <span class="hljs-string">&quot;&quot;</span> + root.val);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printPath</span><span class="hljs-params">(TreeNode root, String path)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    path += <span class="hljs-string">&quot;-&gt;&quot;</span> + root.val;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == root.left &amp;&amp; <span class="hljs-literal">null</span> == root.right) &#123;<br>        res.add(path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    printPath(root.left, path);<br>    printPath(root.right, path);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>easy</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表medium专题</title>
    <link href="/2023/01/29/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8medium%E4%B8%93%E9%A2%98/"/>
    <url>/2023/01/29/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8medium%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>yes代表独立做出来,no代表没有独立做出来(no越多代表越没有思路)，需要看一下解法</li><li>递归，链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。</li><li>链表的关键就是断链和重链，无论是递归还是非递归，都需要在合适的地方断链和重链</li><li>对于链表问题，如果需要对头节点可能发生变更，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。</li></ol><h2 id="LeetCode2-合并两个有序链表-yes"><a href="#LeetCode2-合并两个有序链表-yes" class="headerlink" title="LeetCode2 合并两个有序链表 (yes)"></a>LeetCode2 合并两个有序链表 (yes)</h2><h4 id="（1）题目："><a href="#（1）题目：" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[2,4,3]</span>, l2 = <span class="hljs-comment">[5,6,4]</span> 输出：<span class="hljs-comment">[7,0,8]</span> 解释：342 + 465 = 807.<br></code></pre></td></tr></table></figure><h4 id="（2）思路："><a href="#（2）思路：" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li><p>处理不同的长度的链表</p></li><li><p>处理十进制导致链表长度+1的情况</p><ul><li>一种结果链表长度为二者最长长度</li><li>一种结果链表长度为二者最长长度+1</li></ul></li><li><p>利用本身函数递归来计算1，999这种极端情况</p></li></ul><h4 id="（3）代码："><a href="#（3）代码：" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l1 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (l2 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tenCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        index.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(countSingle(l1.val + l2.val + tenCount));<br>        tenCount = l1.val + l2.val + tenCount &gt; <span class="hljs-number">9</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        index = index.next;<br>        l1 = l1.next;<br>        l2 = l2.next;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (tenCount &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 利用本身函数递归来计算1，999这种极端情况</span><br>        index.next = addTwoNumbers(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(tenCount), l1 != <span class="hljs-literal">null</span> ? l1 : l2);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        index.next = l1 != <span class="hljs-literal">null</span> ? l1 : l2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countSingle</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">return</span> value &gt; <span class="hljs-number">9</span> ? value - <span class="hljs-number">10</span> : value;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode24-两两交换链表中的节点-yes"><a href="#LeetCode24-两两交换链表中的节点-yes" class="headerlink" title="LeetCode24 两两交换链表中的节点 (yes)"></a>LeetCode24 两两交换链表中的节点 (yes)</h2><h4 id="（1）题目：-1"><a href="#（1）题目：-1" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>] 输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-1"><a href="#（2）思路：-1" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>最开始想用非递归，用循环遍历的方式去解，声明P,Q两个节点，循环交换，但是发现后面链接的时候需要先交换在链接，而不能先链接在交换，这就无法使用循环，转而使用递归</li><li>递归和循环在链表中不能同时出现</li></ul><h4 id="（3）代码：-1"><a href="#（3）代码：-1" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    nHead.next = head.next;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head, q = head.next;<br>    p.next = swapPairs(q.next);<br>    q.next = p;<br><br>    <span class="hljs-keyword">return</span> nHead.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode61-旋转链表-yes"><a href="#LeetCode61-旋转链表-yes" class="headerlink" title="LeetCode61 旋转链表 (yes)"></a>LeetCode61 旋转链表 (yes)</h2><h4 id="（1）题目：-2"><a href="#（1）题目：-2" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[0,1,2]</span>, k = 4 输出：<span class="hljs-comment">[2,0,1]</span><br><br>输入：head = <span class="hljs-comment">[1,2,3,4,5]</span>, k = 2 输出：<span class="hljs-comment">[4,5,1,2,3]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-2"><a href="#（2）思路：-2" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>先计算链表长度n，并对k取余，计算出真正的k</li><li>在倒数K的位置截断链表，这里用到了双指针(倒数k的方式，先走k，然后再走到末尾间距K，从而使倒数)</li><li>还有一种思路代替双指针，首位相接，变成环然后在从首部进行遍历</li></ul><h4 id="（3）代码：-2"><a href="#（3）代码：-2" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">rotateRight</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || k == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>        index = index.next;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">real</span> <span class="hljs-operator">=</span> k % count;<br>    <span class="hljs-keyword">if</span> (count - real == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    index = head;<br>    <span class="hljs-keyword">while</span> (real != <span class="hljs-number">0</span>) &#123;<br>        index = index.next;<br>        real--;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (index.next != <span class="hljs-literal">null</span>) &#123;<br>        index = index.next;<br>        temp = temp.next;<br>    &#125;<br><br>    index.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> temp.next;<br>    temp.next = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> nHead;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode82-旋转链表2-no"><a href="#LeetCode82-旋转链表2-no" class="headerlink" title="LeetCode82 旋转链表2 (no)"></a>LeetCode82 旋转链表2 (no)</h2><h4 id="（1）题目：-3"><a href="#（1）题目：-3" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回 已排序的链表 。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1,2,3,3,4,4,5]</span> 输出：<span class="hljs-comment">[1,2,5]</span><br><br>输入：head = <span class="hljs-comment">[1,1,1,2,3]</span> 输出：<span class="hljs-comment">[2,3]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-3"><a href="#（2）思路：-3" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>不同于83旋转链表对于重复的节点只保留一个，本题需要把所有重复的节点都要删除</li><li>引入pre前置节点，当head删除时能够更优雅的处理</li><li>需要在遍历的过程中再次引入循环来处理多个重复节点的问题</li></ul><h4 id="（3）代码：-3"><a href="#（3）代码：-3" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    pre.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> pre;<br><br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head.val != head.next.val) &#123;<br>            head = head.next;<br>            p = p.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.next != <span class="hljs-literal">null</span> &amp;&amp; head.val == head.next.val) &#123;<br>                head = head.next;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>                p.next = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p.next = head.next;<br>                head = head.next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pre.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode86-分隔链表-no"><a href="#LeetCode86-分隔链表-no" class="headerlink" title="LeetCode86 分隔链表 (no)"></a>LeetCode86 分隔链表 (no)</h2><h4 id="（1）题目：-4"><a href="#（1）题目：-4" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,4,3,2,5,2]</span>, x = <span class="hljs-number">3</span> 输出：<span class="hljs-string">[1,2,2,4,3,5]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-4"><a href="#（2）思路：-4" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>pre:哑节点</li><li>p:遇到小于x的最后一个</li><li>q:遇到大于等于x的第一个</li><li>遍历过程，从大于开始，遇到小于的则把这个节点追加到小于的链表下。整个过程是不断链的</li><li>还有一种解法就是断链，分别持有一个大于链表和一个小于链表，遍历过程中根据条件分别在尾部进行追加，最后把两个链表合并</li></ul><h4 id="（3）代码：-4"><a href="#（3）代码：-4" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    pre.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> pre;<br>    ListNode q, temp, qq;<br>    <span class="hljs-keyword">while</span> (p.next != <span class="hljs-literal">null</span> &amp;&amp; p.next.val &lt; x) &#123;<br>        p = p.next;<br>    &#125;<br>    q = p.next;<br>    <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> q;<br>        qq = index;<br>        <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (index.val &lt; x) &#123;<br>                temp = index.next;<br>                p.next = index;<br>                index.next = q;<br>                p = index;<br>                index = temp;<br>                <span class="hljs-keyword">if</span> (qq != <span class="hljs-literal">null</span>) &#123;<br>                    qq.next = index;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                qq = index;<br>                index = index.next;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pre.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode143-重排链表-no"><a href="#LeetCode143-重排链表-no" class="headerlink" title="LeetCode143 重排链表 (no)"></a>LeetCode143 重排链表 (no)</h2><h4 id="（1）题目：-5"><a href="#（1）题目：-5" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-symbol">L1</span> → … → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-built_in">Ln</span><br></code></pre></td></tr></table></figure><p>请将其重新排列后变为：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-symbol">L0</span> → <span class="hljs-built_in">Ln</span> → <span class="hljs-symbol">L1</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">1</span> → <span class="hljs-symbol">L2</span> → <span class="hljs-built_in">Ln</span> - <span class="hljs-number">2</span> → …<br></code></pre></td></tr></table></figure><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span> 输出：<span class="hljs-string">[1,5,2,4,3]</span><br></code></pre></td></tr></table></figure><h4 id="（2）思路：-5"><a href="#（2）思路：-5" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li><p>思路一：</p><ul><li>把链表转成数组，然后操作下标处理数组，最后把处理好的数组转成链表</li></ul></li><li><p>思路二：</p><ul><li>获取中间节点，使用快慢指针</li><li>把中间节点进行逆转，从而后半段链接是逆序</li><li>前半段和后半段进行遍历链接</li></ul></li></ul><h4 id="（3）代码：-5"><a href="#（3）代码：-5" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span> || head.next.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">middleNode</span> <span class="hljs-operator">=</span> middleNode(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> reverse(middleNode.next);<br>    middleNode.next = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head, temp, temp1;<br>    <span class="hljs-keyword">while</span> (reverse != <span class="hljs-literal">null</span>) &#123;<br>        temp = index.next;<br>        temp1 = reverse.next;<br>        index.next = reverse;<br>        reverse.next = temp;<br>        reverse = temp1;<br>        index = temp;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head, q = head;<br>    <span class="hljs-keyword">while</span> (q.next != <span class="hljs-literal">null</span> &amp;&amp; q.next.next != <span class="hljs-literal">null</span>) &#123;<br>        p = p.next;<br>        q = q.next.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> reverse(head.next);<br>    head.next.next = head;<br>    head.next = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">return</span> reverse;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode147-排序链表-no"><a href="#LeetCode147-排序链表-no" class="headerlink" title="LeetCode147 排序链表 (no)"></a>LeetCode147 排序链表 (no)</h2><h4 id="（1）题目：-6"><a href="#（1）题目：-6" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定单个链表的头 <code>head</code> ，使用 <strong>插入排序</strong> 对链表进行排序，并返回 <em>排序后链表的头</em> 。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>] 输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-6"><a href="#（2）思路：-6" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>链表的插入排序: 插入时不需要移动链表元素，但是需要遍历到插入的位置，需要从头向后遍历</li><li>数组的插入排序: 需要移动数组元素，是从后向前遍历</li></ul><h4 id="（3）代码：-6"><a href="#（3）代码：-6" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 链表的插入排序</span><br><span class="hljs-comment"> * 插入时不需要移动链表元素，但是需要遍历到插入的位置，需要从头向后遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertionSortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(head.val - <span class="hljs-number">1</span>);<br>    pre.next = head;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">lastSort</span> <span class="hljs-operator">=</span> head, cur = head.next, index, temp, temp1;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cur.val &gt;= lastSort.val) &#123;<br>            <span class="hljs-comment">// 有序，无序插入</span><br>            lastSort = cur;<br>            cur = cur.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从头遍历进行插入</span><br>            index = pre;<br>            temp1 = cur.next;<br>            <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (index.next.val &gt; cur.val) &#123;<br>                    temp = index.next;<br>                    index.next = cur;<br>                    cur.next = temp;<br>                    lastSort.next = temp1;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    index = index.next;<br>                &#125;<br>            &#125;<br>            cur = temp1;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pre.next;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 数组的插入排序</span><br><span class="hljs-comment"> * 需要移动数组元素，是从后向前遍历</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == nums || nums.length == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        temp = nums[i];<br>        <span class="hljs-comment">// 从尾部遍历进行移动元素并插入</span><br>        <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; nums[j]; j--) &#123;<br>            nums[j + <span class="hljs-number">1</span>] = nums[j];<br>        &#125;<br>        nums[j + <span class="hljs-number">1</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode148-排序链表-nono"><a href="#LeetCode148-排序链表-nono" class="headerlink" title="LeetCode148 排序链表 (nono)"></a>LeetCode148 排序链表 (nono)</h2><h4 id="（1）题目：-7"><a href="#（1）题目：-7" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">4,2,1,3</span>] 输出：[<span class="hljs-number">1,2,3,4</span>]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-7"><a href="#（2）思路：-7" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>获取链表中间节点，使用快慢指针</li><li>递归对子链表排序</li><li>合并两个有序链表leetcode21</li></ul><h4 id="（3）代码：-7"><a href="#（3）代码：-7" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">sortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> middleNode(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> mid.next;<br>    mid.next = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> sortList(head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> sortList(middle);<br><br>    <span class="hljs-keyword">return</span> merge(left, right);<br>&#125;<br><br><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head, q = head;<br>    <span class="hljs-keyword">while</span> (q.next != <span class="hljs-literal">null</span> &amp;&amp; q.next.next != <span class="hljs-literal">null</span>) &#123;<br>        p = p.next;<br>        q = q.next.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br><span class="hljs-keyword">private</span> ListNode <span class="hljs-title function_">merge</span><span class="hljs-params">(ListNode h1, ListNode h2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (h1 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> h2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (h2 == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> h1;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span> (h1 != <span class="hljs-literal">null</span> &amp;&amp; h2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (h1.val &lt; h2.val) &#123;<br>            index.next = h1;<br>            h1 = h1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            index.next = h2;<br>            h2 = h2.next;<br>        &#125;<br>        index = index.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (h1 == <span class="hljs-literal">null</span>) &#123;<br>        index.next = h2;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (h2 == <span class="hljs-literal">null</span>) &#123;<br>        index.next = h1;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode237-删除链表中的节点-nono"><a href="#LeetCode237-删除链表中的节点-nono" class="headerlink" title="LeetCode237 删除链表中的节点 (nono)"></a>LeetCode237 删除链表中的节点 (nono)</h2><h4 id="（1）题目：-8"><a href="#（1）题目：-8" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>有一个单链表的 <code>head</code>，我们想删除它其中的一个节点 <code>node</code>。</p><p>给你一个需要删除的节点 <code>node</code> 。你将 <strong>无法访问</strong> 第一个节点 <code>head</code>。</p><p>链表的所有值都是 <strong>唯一的</strong>，并且保证给定的节点 <code>node</code> 不是链表中的最后一个节点。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], <span class="hljs-keyword">node</span> <span class="hljs-title">= 5</span> 输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="（2）思路：-8"><a href="#（2）思路：-8" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>不删node，而是删node的下一个节点，不过是把value给更换，因为值唯一，所以看起来是删除掉node</li></ul><h4 id="（3）代码：-8"><a href="#（3）代码：-8" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteNode</span><span class="hljs-params">(ListNode node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> node.next.val;<br>    node.next = node.next.next;<br>    node.val = temp;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>medium</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表easy专题</title>
    <link href="/2023/01/16/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8easy%E4%B8%93%E9%A2%98/"/>
    <url>/2023/01/16/%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8easy%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>yes代表独立做出来,no代表没有独立做出来(no越多代表越没有思路)，需要看一下解法</li><li>递归，链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。</li><li>链表的关键就是断链和重链，无论是递归还是非递归，都需要在合适的地方断链和重链</li><li>对于链表问题，如果需要对头节点可能发生变更，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点 head。</li></ol><h2 id="LeetCode21-合并两个有序链表-yes"><a href="#LeetCode21-合并两个有序链表-yes" class="headerlink" title="LeetCode21 合并两个有序链表 (yes)"></a>LeetCode21 合并两个有序链表 (yes)</h2><h4 id="（1）题目："><a href="#（1）题目：" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><h4 id="（2）思路："><a href="#（2）思路：" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>双指针：声明头部指针，声明index索引指针，通过比较value来确定index.next的指向</li><li>递归：处理好边界跳出的时机</li></ul><h4 id="（3）代码："><a href="#（3）代码：" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 双指针</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists1</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>      <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> list2;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> list1;<br>      &#125;<br>      ListNode head, index;<br>      <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;<br>          head = index = list2;<br>          list2 = list2.next;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          head = index = list1;<br>          list1 = list1.next;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (list2 != <span class="hljs-literal">null</span> &amp;&amp; list1 != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;<br>              index.next = list2;<br>              list2 = list2.next;<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              index.next = list1;<br>              list1 = list1.next;<br>          &#125;<br>          index = index.next;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (list1 != <span class="hljs-literal">null</span>) &#123;<br>          index.next = list1;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (list2 != <span class="hljs-literal">null</span>) &#123;<br>          index.next = list2;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> head;<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 递归</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>      <span class="hljs-keyword">if</span> (list1 == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> list2;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list2 == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> list1;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list1.val &gt; list2.val) &#123;<br>          list2.next = mergeTwoLists(list1, list2.next);<br>          <span class="hljs-keyword">return</span> list2;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          list1.next = mergeTwoLists(list1.next, list2);<br>          <span class="hljs-keyword">return</span> list1;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode83-删除链表中重复元素-yes"><a href="#LeetCode83-删除链表中重复元素-yes" class="headerlink" title="LeetCode83 删除链表中重复元素(yes)"></a>LeetCode83 删除链表中重复元素(yes)</h2><h4 id="（1）题目：-1"><a href="#（1）题目：-1" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。</p><h4 id="（2）思路：-1"><a href="#（2）思路：-1" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>断链和重链</li></ul><h4 id="（3）代码：-1"><a href="#（3）代码：-1" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 递归</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> head;<br>      &#125;<br><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> deleteDuplicates(head.next);<br>      <span class="hljs-keyword">if</span> (nHead != <span class="hljs-literal">null</span> &amp;&amp; nHead.val == head.val) &#123;<br>          head.next = nHead.next;<br>          <span class="hljs-comment">// nHead.next = null;</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> head;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode141-环形链表-yes"><a href="#LeetCode141-环形链表-yes" class="headerlink" title="LeetCode141 环形链表(yes)"></a>LeetCode141 环形链表(yes)</h2><h4 id="（1）题目：-2"><a href="#（1）题目：-2" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个链表的头节点 head ，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h4 id="（2）思路：-2"><a href="#（2）思路：-2" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>快慢指针，指针能够再次相遇则代表有环</li></ul><h4 id="（3）代码：-2"><a href="#（3）代码：-2" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 快慢指针</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">quick</span> <span class="hljs-operator">=</span> head;<br>      <span class="hljs-keyword">while</span> (quick != <span class="hljs-literal">null</span> &amp;&amp; quick.next != <span class="hljs-literal">null</span>) &#123;<br>          quick = quick.next.next;<br>          head = head.next;<br>          <span class="hljs-keyword">if</span> (quick == head) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode-环形链表2-no-no"><a href="#LeetCode-环形链表2-no-no" class="headerlink" title="LeetCode 环形链表2 (no,no)"></a>LeetCode 环形链表2 (no,no)</h2><h4 id="（1）题目：-3"><a href="#（1）题目：-3" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null</p><h4 id="（2）思路：-3"><a href="#（2）思路：-3" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li><p>设定head到入口节点长度为a(不包含入口), 环的长度为b，则在二者相遇时可以得到以下公式</p><ul><li>quick &#x3D; slow + n * b</li><li>quick &#x3D; 2 * slow</li></ul></li><li><p>上述两个公式通过合并的方式可以得到quick和slow</p><ul><li>slow &#x3D; n * b</li><li>quick &#x3D; 2 * n * b</li></ul></li><li><p>综上分析</p><ul><li>在相遇点时，slow已经走了nb长度，而quick走了2nb</li><li>在quick走到到相遇点之前的入口点是走了a + nb(先走了a，在绕环走了nb，然后在走了一段达到相遇点)</li><li>所以slow想到达quick走过的相遇点，则需要再走a。而此时只要一个节点index从head出发，slow和index就可以在入口处相遇</li></ul></li></ul><h4 id="（3）代码：-3"><a href="#（3）代码：-3" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双指针、快慢指针</span><br><span class="hljs-comment"> * 设定head到入口节点长度为a(不包含入口), 环的长度为b</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">quick</span> <span class="hljs-operator">=</span> head.next.next, slow = head.next;<br>    <span class="hljs-keyword">while</span> (quick != <span class="hljs-literal">null</span> &amp;&amp; quick.next != <span class="hljs-literal">null</span> &amp;&amp; quick != slow) &#123;<br>        quick = quick.next.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (quick != slow) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (slow != head) &#123;<br>        slow = slow.next;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode160-相交链表-no"><a href="#LeetCode160-相交链表-no" class="headerlink" title="LeetCode160 相交链表 (no)"></a>LeetCode160 相交链表 (no)</h2><h4 id="（1）题目：-4"><a href="#（1）题目：-4" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null</p><h4 id="（2）思路：-4"><a href="#（2）思路：-4" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>每次A,B同时移动，如果相同且不为空则证明存在相同节点 </li><li>A先从自身开始遍历，到尾部在从B继续遍历 </li><li>B先从自身开始遍历，到尾部在从A继续遍历 </li><li>这样AB遍历相同长度，此时在任意一个节点相同则证明是相同节点</li></ul><h4 id="（3）代码：-4"><a href="#（3）代码：-4" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> &#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-literal">null</span> || headB == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">indexA</span> <span class="hljs-operator">=</span> headA;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">indexB</span> <span class="hljs-operator">=</span> headB;<br>    <span class="hljs-keyword">while</span> (indexA != indexB) &#123;<br>        indexA = indexA != <span class="hljs-literal">null</span> ? indexA.next : headB;<br>        indexB = indexB != <span class="hljs-literal">null</span> ? indexB.next : headA;<br>    &#125;<br>    <span class="hljs-keyword">return</span> indexA;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode203-移除链表元素-yes"><a href="#LeetCode203-移除链表元素-yes" class="headerlink" title="LeetCode203 移除链表元素 (yes)"></a>LeetCode203 移除链表元素 (yes)</h2><h4 id="（1）题目：-5"><a href="#（1）题目：-5" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 新的头节点 。</p><h4 id="（2）思路：-5"><a href="#（2）思路：-5" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>非递归，处理头部相同、中间相同、尾部相同的不同情况</li><li>递归，链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。</li></ul><h4 id="（3）代码：-5"><a href="#（3）代码：-5" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 相同的value在头部</span><br><span class="hljs-comment"> * 相同的value在中间</span><br><span class="hljs-comment"> * 相同的value在尾部</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements1</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> head, index = head;<br>    <span class="hljs-comment">// 第一个元素相同</span><br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span> &amp;&amp; head.val == val) &#123;<br>        nHead = head.next;<br>        index = nHead;<br>        head = head.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> nHead;<br>    &#125;<br><br>    head = head.next;<br>    <span class="hljs-comment">// 第一个元素不相同</span><br>    <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (head.val == val) &#123;<br>            index.next = head.next;<br>            head = head.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = head.next;<br>            index = index.next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nHead;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeElements</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    head.next = removeElements(head.next, val);<br><br>    <span class="hljs-keyword">return</span> head.val == val ? head.next : head;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode206-反转链表-no"><a href="#LeetCode206-反转链表-no" class="headerlink" title="LeetCode206 反转链表(no)"></a>LeetCode206 反转链表(no)</h2><h4 id="（1）题目：-6"><a href="#（1）题目：-6" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><h4 id="（2）思路：-6"><a href="#（2）思路：-6" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>非递归，需要额外处理1,2,3个元素的不同情况</li><li>递归，</li></ul><h4 id="（3）代码：-6"><a href="#（3）代码：-6" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 递归解法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList1</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> head;<br>      &#125;<br><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">nHead</span> <span class="hljs-operator">=</span> reverseList1(head.next);<br>      head.next.next = head; <span class="hljs-comment">// 核心内容，让中间的元素变更指向</span><br>      head.next = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> nHead;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 非递归解法</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> head;<br>      &#125;<br><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> head, suf = head.next, temp;<br>      <span class="hljs-keyword">do</span> &#123;<br>          temp = suf.next;<br>          suf.next = pre;<br>          <span class="hljs-keyword">if</span> (pre == head) &#123; <span class="hljs-comment">// 核心内容，第一个元素需要断链，而后面的不需要，因为已经通过赋值的方式断链</span><br>              pre.next = <span class="hljs-literal">null</span>;<br>          &#125;<br><br>          pre = suf;<br>          suf = temp;<br>      &#125; <span class="hljs-keyword">while</span> (suf != <span class="hljs-literal">null</span>);<br><br>      <span class="hljs-keyword">return</span> pre;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 非递归解法2, 比第一种非递归更简洁</span><br><span class="hljs-comment">   */</span><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>          head.next = prev;<br>          prev = head;<br>          head = next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> prev;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode234-回文链表-no"><a href="#LeetCode234-回文链表-no" class="headerlink" title="LeetCode234 回文链表(no)"></a>LeetCode234 回文链表(no)</h2><h4 id="（1）题目：-7"><a href="#（1）题目：-7" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><h4 id="（2）思路：-7"><a href="#（2）思路：-7" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>计数+栈，先计算链表的长度，在中间的问题通过入栈出栈对比元素</li><li>快慢指针，通过快慢指针定位到中间为止，在反转后半段链表，比较值</li></ul><h4 id="（3）代码：-7"><a href="#（3）代码：-7" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 计数 + 栈</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome1</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>      <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>          count++;<br>          index = index.next;<br>      &#125;<br><br>      Deque&lt;ListNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>      index = head;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count / <span class="hljs-number">2</span>; i++) &#123;<br>          stack.push(index);<br>          index = index.next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (count % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>          index = index.next;<br>      &#125;<br><br>      <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (index.val != stack.pop().val) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          index = index.next;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 快慢指针</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">quick</span> <span class="hljs-operator">=</span> head, slow = head;<br>      <span class="hljs-keyword">while</span> (quick.next != <span class="hljs-literal">null</span> &amp;&amp; quick.next.next != <span class="hljs-literal">null</span>) &#123;<br>          quick = quick.next.next;<br>          slow = slow.next;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (quick.next != <span class="hljs-literal">null</span>) &#123;<br>          slow = slow.next;<br>      &#125;<br><br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> reverse(slow);<br>      quick = head;<br>      <span class="hljs-keyword">while</span> (reverse != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">if</span> (quick.val != reverse.val) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          &#125;<br>          quick = quick.next;<br>          reverse = reverse.next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 反转链表</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>      <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> head.next;<br>          head.next = prev;<br>          prev = head;<br>          head = next;<br>      &#125;<br>      <span class="hljs-keyword">return</span> prev;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer06-倒序打印链表-yes"><a href="#剑指Offer06-倒序打印链表-yes" class="headerlink" title="剑指Offer06 倒序打印链表 (yes)"></a>剑指Offer06 倒序打印链表 (yes)</h2><h4 id="（1）题目：-8"><a href="#（1）题目：-8" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h4 id="（2）思路：-8"><a href="#（2）思路：-8" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>递归更优雅的方式，不使用数组拷贝，而是建立一个arraylist，这样可以避免使用System.arraycopy从而减少遍历次数和内存</li></ul><h4 id="（3）代码：-8"><a href="#（3）代码：-8" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-type">int</span>[] ints = reversePrint(head.next);<br>    <span class="hljs-type">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[ints.length + <span class="hljs-number">1</span>];<br>    System.arraycopy(ints, <span class="hljs-number">0</span>, res, <span class="hljs-number">0</span>, ints.length);<br>    res[ints.length] = head.val;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指Offer22-链表中倒数第k个节点-yes"><a href="#剑指Offer22-链表中倒数第k个节点-yes" class="headerlink" title="剑指Offer22 链表中倒数第k个节点 (yes)"></a>剑指Offer22 链表中倒数第k个节点 (yes)</h2><h4 id="（1）题目：-9"><a href="#（1）题目：-9" class="headerlink" title="（1）题目："></a>（1）<strong>题目</strong>：</h4><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p><h4 id="（2）思路：-9"><a href="#（2）思路：-9" class="headerlink" title="（2）思路："></a>（2）思路：</h4><ul><li>先让一个指针走K，然后另一个从头部出发，当第一个达到尾部则后一个出发的是倒数第K个</li><li>需要处理k大于链表和等于链表的特殊情况</li></ul><h4 id="（3）代码：-9"><a href="#（3）代码：-9" class="headerlink" title="（3）代码："></a>（3）代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">getKthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || k &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i != k &amp;&amp; index!= <span class="hljs-literal">null</span>) &#123;<br>        index = index.next;<br>        i++;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i==k &amp;&amp; index == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i != k &amp;&amp; index == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (index != <span class="hljs-literal">null</span>) &#123;<br>        head = head.next;<br>        index = index.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>刷题/Leetcode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>easy</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>好用的工具轮子(持续更新~)</title>
    <link href="/2023/01/06/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BD%AE%E5%AD%90-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2023/01/06/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E8%BD%AE%E5%AD%90-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>（1）Hutool  <a href="https://github.com/dromara/hutool/">https://github.com/dromara/hutool/</a></p><p>Hutool是一个小而全的Java工具类库，通过静态方法封装，降低相关API的学习成本，提高工作效率，使Java拥有函数式语言般的优雅，让Java语言也可以“甜甜的”。</p><p>Hutool中的工具方法来自每个用户的精雕细琢，它涵盖了Java开发底层代码中的方方面面，它既是大型项目开发中解决小问题的利器，也是小型项目中的效率担当；</p><p>Hutool是项目中“util”包友好的替代，它节省了开发人员对项目中公用类和公用工具方法的封装时间，使开发专注于业务，同时可以最大限度的避免封装不完善带来的bug。</p><p>（2）apache的common-lang3</p><p>（3） 低代码生成工具 <a href="https://github.com/jeecgboot/jeecg-boot">https://github.com/jeecgboot/jeecg-boot</a></p><p>JeecgBoot 是一款基于代码生成器的<code>低代码开发平台</code>！前后端分离架构 SpringBoot2.x，SpringCloud，Ant Design&amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发! JeecgBoot 引领新的低代码开发模式(OnlineCoding-&gt; 代码生成器-&gt; 手工MERGE)， 帮助解决Java项目70%的重复工作，让开发更多关注业务。既能快速提高效率，节省研发成本，同时又不失灵活性！</p><p>JeecgBoot 提供了一系列<code>低代码模块</code>，实现在线开发<code>真正的零代码</code>：Online表单开发、Online报表、报表配置能力、在线图表设计、大屏设计、移动配置能力、表单设计器、在线设计流程、流程自动化配置、插件能力（可插拔）等等！</p><p><code>JEECG宗旨是:</code> 简单功能由OnlineCoding配置实现，做到<code>零代码开发</code>；复杂功能由代码生成器生成进行手工Merge 实现<code>低代码开发</code>，既保证了<code>智能</code>又兼顾<code>灵活</code>；实现了低代码开发的同时又支持灵活编码，解决了当前低代码产品普遍不灵活的弊端！</p>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他技能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Service注解的value属性</title>
    <link href="/2023/01/06/Spring/Service%E6%B3%A8%E8%A7%A3%E7%9A%84value%E5%B1%9E%E6%80%A7/"/>
    <url>/2023/01/06/Spring/Service%E6%B3%A8%E8%A7%A3%E7%9A%84value%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>  <code>@service</code>注解工作原理：在service层类上面添加<code>@Service</code>注解，会自动创建<code>Bean</code>，<code>Bean</code>的名字为类的名字首字母小写，也可以自己指定名字<code>@Service(value=&quot;XXXX&quot;)</code></p><p> 对象属性注入：如果是使用类来创建对象，使用数据类型注入方式AutoWired属性注入就直接生成一个对象，因为一个类时唯一的。当使用接口创建对象时，使用@AutoWired它会去找该数据类型接口的实现类来创建对象。但是当该接口有多个实现类时，就需要加上通过名字进行注入属性，即Bean的名字，此时使用的就是@Service(value&#x3D;”XXX”)里面的 XXX </p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">IService</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">base</span><span class="hljs-params">()</span>;<br>&#125;<br><br><br><span class="hljs-meta">@Service(&quot;service1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IService</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">base</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-meta">@Service(&quot;service2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IService</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">base</span><span class="hljs-params">()</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用方式一</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Map&lt;String, IService&gt; serviceMap;<br>serviceMap.get(<span class="hljs-string">&quot;service1&quot;</span>).base()<br><br><br><span class="hljs-comment">// 使用方式二</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;service1&quot;)</span><br><span class="hljs-keyword">private</span> Iservice service;<br>service.base();<br><br></code></pre></td></tr></table></figure><p>补充：</p><p>（1）@Resource和@Autowired注解的区别</p><ul><li><p>resource，是j2ee的注解，并不是spring原生的注解，默认是byName注入。但是可以通过byname或者byType两种属性来指定是通过name还是通过type来注入</p></li><li><p>autowired是spring的注解，默认是byType来注入，可以跟@Qualifier来指定name，从而以name的方式注入</p></li></ul><p>（2）spring的bean有5中scope，单例、原型、request、session、global session。其中controller都是单例模式，而自定义的service都是原型，即每次声明都会get一个新的实例</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何提升工作能力</title>
    <link href="/2022/12/28/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E8%83%BD%E5%8A%9B/"/>
    <url>/2022/12/28/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E8%83%BD%E5%8A%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、面试能力"><a href="#一、面试能力" class="headerlink" title="一、面试能力"></a>一、面试能力</h2><blockquote><p> <strong>[亮点项目]</strong></p></blockquote><blockquote><p><strong>[八股文]</strong></p></blockquote><ul><li>java</li><li>spring</li><li>关系型数据库</li><li>分布式，redis，mq</li></ul><blockquote><p><strong>[算法]</strong></p></blockquote><ul><li>每周至少精练3道LeetCode</li></ul><blockquote><p><strong>[系统设计]</strong></p></blockquote><ul><li>学习先进的架构设计</li><li>对比业界成熟的设计</li><li>多看相关的讲座和汇报</li></ul><h2 id="二、代码能力"><a href="#二、代码能力" class="headerlink" title="二、代码能力"></a>二、代码能力</h2><ol><li>代码CR</li><li>学习好的代码实现方案，多模仿，多总结，多思考</li></ol><h2 id="三、业务能力"><a href="#三、业务能力" class="headerlink" title="三、业务能力"></a>三、业务能力</h2><blockquote><p><strong>[个人业务能力定义]</strong></p></blockquote><ul><li>个人的业务能力是依赖于公司和平台的</li><li>对于大部分人来说，都是站在巨人的肩膀上，是巨人牛逼而不是个人牛逼</li><li>当你离开公司，能否在从零开始建立起你当前做的项目</li></ul><blockquote><p><strong>[让项目成为你的资产]</strong></p></blockquote><ul><li>技术架构：总结项目的关键技术</li><li>代码：整理项目关键实现代码</li><li>产品PM：截屏项目关键实现页面</li></ul>]]></content>
    
    
    <categories>
      
      <category>个人成长</category>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始搭建一个酷炫的个人博客</title>
    <link href="/2022/11/18/%E9%9A%8F%E7%AC%94/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%B7%E7%82%AB%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/11/18/%E9%9A%8F%E7%AC%94/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%85%B7%E7%82%AB%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、搭建网站"><a href="#一、搭建网站" class="headerlink" title="一、搭建网站"></a>一、搭建网站</h2><h3 id="git和hexo准备"><a href="#git和hexo准备" class="headerlink" title="git和hexo准备"></a>git和hexo准备</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/103268406">注册GitHub</a></li><li><a href="https://zhuanlan.zhihu.com/p/103325381">本地安装Git</a></li><li><a href="https://zhuanlan.zhihu.com/p/103391101">绑定GitHub并提交文件</a></li><li><a href="https://zhuanlan.zhihu.com/p/105715224">安装npm和hexo，并绑定github上的仓库</a></li><li>注意：上述教程都是Windows系统，Mac系统会更简单！</li></ol><h3 id="域名准备"><a href="#域名准备" class="headerlink" title="域名准备"></a>域名准备</h3><ol><li>购买域名，买的是<a href="https://buy.cloud.tencent.com/domain?from=console">腾讯云域名</a>，购买完成之后的<a href="https://console.cloud.tencent.com/domain/all-domain">域名管理</a></li><li><a href="https://zhuanlan.zhihu.com/p/103813944">解析域名</a></li><li><a href="https://console.cloud.tencent.com/beian">域名备案</a></li></ol><h2 id="二、优化网站"><a href="#二、优化网站" class="headerlink" title="二、优化网站"></a>二、优化网站</h2><ol><li><p>使用的Fluid主题，<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Hexo Fluid 用户手册</a></p></li><li><p>增加图床，图片可以放在git中一起上传，但是图片多了会拖慢网站打开速度，推荐使用外链图床</p><ul><li>采用的是腾讯云的对象存储，直接购买资源包，然后上传图片即可，价格：10元&#x2F;1年</li><li><a href="https://cloud.tencent.com/product/cos">购买界面</a></li><li><a href="https://console.cloud.tencent.com/cos">使用界面</a></li></ul></li><li><p>增加评论</p></li><li><p>增加页面统计</p></li><li><p>变更图标和界面图片</p><ul><li><p>把想要显示的图片放到：<code>themes/fluid/source/img</code>文件夹下</p></li><li><p>在<code>themes/fluid/_config.yml</code>配置文件中通过<code>img/xx.png</code>来定位图片</p></li></ul></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 用于浏览器标签的图标</span><br><span class="hljs-comment"># Icon for browser tab</span><br><span class="hljs-attr">favicon:</span> <span class="hljs-string">/img/icon</span><br></code></pre></td></tr></table></figure><ol start="6"><li><p>GitHub的网站增加README.md</p><ul><li><p>在根目录 source 文件夹下新建README.md</p></li><li><p>在根目录的 _config.yml 配置文件里，找到 skip_render 关键字，添加 README.md</p></li></ul></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 解释器跳过md渲染为html的过程</span><br><span class="hljs-attr">skip_render:</span> <span class="hljs-string">README.md</span><br></code></pre></td></tr></table></figure><h2 id="三、发布第一篇文章"><a href="#三、发布第一篇文章" class="headerlink" title="三、发布第一篇文章"></a>三、发布第一篇文章</h2><p><a href="https://hexo.io/zh-cn/docs/writing">官方文档</a></p><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><ol><li><code>hexo new post &quot;第一篇文章&quot;</code></li><li>在博客目录下的&#x2F;source&#x2F;_posts&#x2F; 文件夹下，可以看到已经生成了标题为<code>第一篇文章.md</code>的博客文件，可以在_posts&#x2F;文件夹下创建子目录，用以更好的管理文章<br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-1.png" alt="目录结构"></li><li>Hexo 发布的文章是 Markdown 格式的文件</li></ol><h3 id="新建一篇草稿"><a href="#新建一篇草稿" class="headerlink" title="新建一篇草稿"></a>新建一篇草稿</h3><ol><li><code>hexo new draft &quot;第一篇草稿&quot;</code></li><li>在博客目录下的&#x2F;source&#x2F;_drafts&#x2F; 文件夹下，可以看到已经生成了标题为<code>第一篇文草稿.md</code>的草稿文件，</li><li>草稿文章不会被其他人看到，直到通过<code>hexo publish draft &quot;第一篇草稿&quot;</code>才会把草稿推送为正式文章，从而被观测到</li></ol><h3 id="给文章添加分类和标签"><a href="#给文章添加分类和标签" class="headerlink" title="给文章添加分类和标签"></a>给文章添加分类和标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 个人博客搭建完整攻略<br>date: 2022-12-27 14:47:08<br>tags:<br><span class="hljs-bullet">-</span> 博客<br><span class="hljs-bullet">-</span> hexo             // 多个标签<br>  categories:<br><span class="hljs-section">- [其他技能, 博客搭建]   // 多层级分类，中间用英文逗号分隔</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-2.png" alt="添加的分类结构"></p><h3 id="设置文章摘要"><a href="#设置文章摘要" class="headerlink" title="设置文章摘要"></a>设置文章摘要</h3><ol><li><p>关闭自动摘要，在主题配置文件&#x2F;themes&#x2F;fluid&#x2F;_config.yml中找到auto_excerpt，设置enable&#x3D;false</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">index:</span><br>  <span class="hljs-attr">auto_excerpt:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>在文章中指定摘要</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: 这是标题<br><span class="hljs-section">excerpt: 这是摘要</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="设置文章模板"><a href="#设置文章模板" class="headerlink" title="设置文章模板"></a>设置文章模板</h3><ol><li>scaffolds&#x2F;post.md 设置正式文章模板</li><li>scaffolds&#x2F;draft.md 设置草稿模板</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>title: &#123;&#123; title &#125;&#125;<br>date: &#123;&#123; date &#125;&#125;<br>tags:<br><span class="hljs-bullet">-</span><br>categories:<br><span class="hljs-bullet">-</span> []<br><span class="hljs-section">  excerpt: &#123;&#123; title &#125;&#125;</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure><h3 id="启动博客服务器"><a href="#启动博客服务器" class="headerlink" title="启动博客服务器"></a>启动博客服务器</h3><ol><li>启动并本地测试：<code>hexo server </code></li><li>发布到Github上<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>demo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引的记账本</title>
    <link href="/2022/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%B0%E8%B4%A6%E6%9C%AC/"/>
    <url>/2022/11/13/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%B0%E8%B4%A6%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<hr><ul><li>建立（a,b,c）索引</li><li>a&#x3D;xxx,b&#x3D;xxx,c&#x3D;xxx 走（a,b,c）索引</li><li>a&#x3D;xxx,c&#x3D;xxx,b&#x3D;xxx 走（a,b,c）索引，这种情况数据库会自动优化成联合索引</li><li>a&#x3D;xxx,c&#x3D;xxx 走的是a索引</li><li>a&#x3D;xxx,b!&#x3D;xxx 走的是a索引</li><li>a&#x3D;xxx,b&lt;xxx,c&#x3D;xxx 走的是(a,b)索引，会在&lt;停止</li><li>a&#x3D;xxx,order by b 走的是a索引，因为联合索引（a,b,c）是先排序a，在排序b，在排序c，而先排序b显然是不行的</li><li>a&#x3D;xxx or d&#x3D;xxx ,不走索引</li><li>a&#x3D;xxx and d&#x3D;xxx 只有a索引</li><li>a&lt;xxx, 可能走a索引，也可能不走a索引，具体要看记录中符合<code>a&lt;xxx</code>的数量，如果符合的数量很多，那么优化器就会认为此时走索引的价值不大，会进行全表扫描，如果符合的数量很少，那么优化器会任务走索引的更快，从而走索引。这和<code>a=xxx,b&lt;xxx</code>走(a, b)索引并不冲突，因为先走a导致大部分数据已经被剔除了，索引此时走b索引是有价值的</li></ul><p>补充：如何看联合索引走的那几个所以，只要通过explain看一下key_len字段就可以了</p><hr><blockquote><p><strong>核心概念</strong></p></blockquote><ul><li><strong>主键索引&#x2F;二级索引</strong></li><li><strong>聚簇索引&#x2F;非聚簇索引</strong></li><li><strong>回表&#x2F;索引覆盖</strong></li><li><strong>索引下推</strong></li><li><strong>联合索引&#x2F;最左联合匹配</strong></li><li><strong>前缀索引</strong></li></ul><h2 id="一、-索引定义"><a href="#一、-索引定义" class="headerlink" title="一、[索引定义]"></a>一、[索引定义]</h2><blockquote><p><strong>1.索引定义</strong></p></blockquote><p>在数据之外，数据库系统还维护着<strong>满足特定查找算法的数据结构</strong>，这些数据结构以<strong>某种方式引用（指向）数据</strong>，这样就可以在这些数据结构上实现高级查找算法。<strong>这种数据结构，就是索引。</strong></p><blockquote><p><strong>2.索引的数据结构</strong></p></blockquote><ul><li>B树 &#x2F; B+树 (mysql的innodb引擎默认选择B+树作为索引的数据结构)</li><li>HASH表</li><li>有序数组</li></ul><blockquote><p><strong>3.选用B+树而不选用B树作为索引</strong></p></blockquote><ul><li>B树的数据结构：record记录存放在树的节点中</li><li>B+树的数据结构: record记录只存放在树的叶子节点中</li></ul><p><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E8%AE%B0%E8%B4%A6%E6%9C%AC/%E7%B4%A2%E5%BC%95%E8%AE%B0%E8%B4%A6%E6%9C%AC-1.png" alt="B树"><br><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%B4%A2%E5%BC%95%E8%AE%B0%E8%B4%A6%E6%9C%AC/%E7%B4%A2%E5%BC%95%E8%AE%B0%E8%B4%A6%E6%9C%AC-2.png" alt="B+树"></p><ul><li>假设一条数据大小1KB，索引大小16B，数据库采用磁盘数据页存储，磁盘页默认大小是16K。同样三次IO:<ol><li>B树能获取16*16*16&#x3D;4096条数据</li><li>B+树能够获取1000*1000*1000&#x3D;10亿条数据</li></ol></li></ul><h2 id="二、-索引类型"><a href="#二、-索引类型" class="headerlink" title="二、[索引类型]"></a>二、[索引类型]</h2><blockquote><p><strong>1.主键索引和二级索引</strong></p></blockquote><ul><li>主键索引：索引的叶子节点是数据行</li><li>二级索引：索引的叶子节点是KEY字段加主键索引，因此，通过二级索引询首先查到是主键值，然后InnoDB再根据查到的主键值通过主键索引找到相应的数据块。</li><li>innodb的主索引文件上 直接存放该行数据,称为聚簇索引,次索引指向对主键的引用</li><li>myisam中, 主索引和次索引,都指向物理行(磁盘位置).</li></ul><blockquote><p><strong>2.聚簇索引和非聚簇索引</strong></p></blockquote><ul><li><p>聚簇索引是对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致。一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引（理由：数据一旦存储，顺序只能有一种）。</p></li><li><p>相较于聚簇索引的叶子点击是数据记录，非聚簇索引的叶子节点是指向数据记录的指针。非聚簇索引与聚簇索引最大的不同就是数据记录的顺序跟索引是不一致的，因此在数据</p></li><li><p>我们知道 Mysql 底层是用 B+ 树来存储索引的，且数据都存在叶子节点。对于 InnoDB 来说，它的主键索引和行记录是存储在一起的，因此叫做聚集索引（clustered index)。</p><p>PS：MyISAM 的行记录是单独存储的，不和索引在一起，因此 MyISAM也就没有聚集索引。</p><p>除了聚集索引，其它索引都叫做非聚集索引（secondary index）。包括普通索引，唯一索引等。</p><p>另外需要注意，在 InnoDB 中有且只有一个聚集索引。它有三种情况：</p><ol><li>若表存在主键，则主键索引就是聚集索引。</li><li>若不存在主键，则会把第一个非空的<strong>唯一索引</strong>作为聚集索引。</li><li>否则，就会隐式的定义一个 rowid 作为聚集索引。</li></ol></li></ul><blockquote><p><strong>3.聚簇索引优劣</strong></p></blockquote><ul><li><p>优势: 根据主键查询条目比较少时，不用回行(数据就在主键节点下)</p></li><li><p>劣势: 如果碰到不规则数据插入时，造成频繁的页分裂。</p></li></ul><p>![image-20221109205205643](&#x2F;Users&#x2F;xieshijie&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221109205205643.png)</p><h2 id="三、-索引概念引申"><a href="#三、-索引概念引申" class="headerlink" title="三、[索引概念引申]"></a>三、[索引概念引申]</h2><blockquote><p><strong>1.回表</strong></p></blockquote><p>回表的概念涉及到主键索引和非主键索引的查询区别</p><ul><li>如果语句是 <code>select * from T where ID=500</code>，<strong>即主键查询，则只需要搜索 ID 这棵树。</strong></li><li>如果语句是 <code>select * from T where k=5</code>，即非主键索引查询，则需要<strong>先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。</strong></li><li><strong>从非主键索引回到主键索引的过程称为回表。</strong></li></ul><p><strong>基于非主键索引的查询需要多扫描一棵索引树。</strong>因此，我们在应用中应该尽量使用主键查询。而从存储空间的角度讲，因为非主键索引树的叶结点存放的是主键的值，那么，应该<strong>考虑让主键的字段尽量短，这样非主键索引的叶子结点就越小，非主键索引占用的空间也就越小。</strong>一般情况下，建议创建一个自增主键，这样非主键索引占用的空间最小。</p><blockquote><p><strong>2.索引覆盖</strong></p></blockquote><ul><li>如果where子句中的一个条件是非主键索引，那么查询的时候，<strong>先通过非主键索引定位到主键索引（主键位于非主键索引搜索树的叶子节点）</strong>；然后通过主键索引定位到查询的内容。在这个过程中，回到主键索引树的过程，称为回表。</li><li>但是当我们的<strong>查询内容是主键值，那么可以直接提供查询结果，不需要回表</strong>。也就是说，<strong>在这个查询里，非主键索引 已经 “覆盖了” 我们的查询需求，故称为覆盖索引。</strong></li><li><strong>覆盖索引就是从辅助索引中就能直接得到查询结果，而不需要回表到聚簇索引中进行再次查询</strong>，所以可以减少搜索次数（不需要从辅助索引树回表到聚簇索引树），或者说减少 IO 操作（通过辅助索引树可以一次性从磁盘载入更多节点），从而提升性能。</li></ul><blockquote><p><strong>3.联合索引</strong></p></blockquote><p><strong>联合索引是指对表上的多个列进行索引。</strong></p><p><strong>场景一：</strong></p><p>联合索引 (a, b) 是<strong>根据 a, b 进行排序（先根据 a 排序，如果 a 相同则根据 b 排序）</strong>。因此，下列语句可以直接使用联合索引得到结果（事实上，也就是用到了最左前缀原则）</p><ul><li><strong>select … from xxx where a&#x3D;xxx;</strong></li><li><strong>select … from xxx where a&#x3D;xxx order by b;</strong></li></ul><p>而下列语句则不能使用联合查询：</p><ul><li><strong>select … from xxx where b&#x3D;xxx;</strong></li></ul><p><strong>场景二：</strong></p><p>对于联合索引 (a, b, c)，下列语句同样可以直接通过联合索引得到结果：</p><ul><li><strong>select … from xxx where a&#x3D;xxx order by b;</strong></li><li><strong>select … from xxx where a&#x3D;xxx and b&#x3D;xxx order by c;</strong></li></ul><p>而下列语句则不行，需要执行一次 filesort 排序操作。</p><ul><li><strong>select … from xxx where a&#x3D;xxx order by c;</strong></li></ul><p><strong>总结：</strong></p><p><strong>以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引。</strong>一个索引顶三个索引当然是好事，毕竟每多一个索引，都会增加写操作的开销和磁盘空间的开销。</p><blockquote><p><strong>4.最左匹配原则</strong></p></blockquote><ul><li>从上面联合索引的例子，可以体会到最左前缀原则。</li><li><strong>不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</strong>利用索引的 “最左前缀” 原则来定位记录，避免重复定义索引。</li><li>因此，基于最左前缀原则，我们在定义联合索引的时候，考虑如何安排索引内的字段顺序就至关重要了！评估的标准就是索引的复用能力，比如，<strong>当已经有了 (a,b) 字段的索引，一般就不需要再单独在 a 上建立索引了。</strong></li></ul><blockquote><p><strong>5.索引下推</strong></p></blockquote><p>MySQL 5.6 引入了索引下推优化，<strong>可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。</strong></p><ul><li>建表</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `test` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;自增主键&#x27;</span>,<br>  `age` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span>,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> utf8 <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`),<br>  KEY `idx_name_age` (`name`,`age`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure><ul><li>创建数据</li></ul><p>![image-20221113182446821](&#x2F;Users&#x2F;xieshijie&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221113182446821.png)</p><ul><li><p><code>SELECT * from user where  name like &#39;陈%&#39;</code> 最左匹配原则，命中idx_name_age索引</p></li><li><p><code>SELECT * from user where  name like &#39;陈%&#39; and age=20</code></p><ul><li>5.6版本之前，先根据name索引(此时是忽略<code>age=20</code>这个条件的)，匹配2条记录，然后找到对应的2个id。回表之后，在根据age&#x3D;20进行过滤</li><li>5.6版本之后，会加入索引下推，在根据name匹配到2条数据之后，此时不会忽略<code>age=20</code>条件，在回表之前就会根据age进行过滤。此即索引下推，可以减少回表的数据量，增加查询性能</li></ul></li></ul><blockquote><p><strong>6.前缀索引</strong></p></blockquote><p>当<strong>索引是很长的字符序列时，这个索引将会很占内存，而且会很慢</strong>，这时候就会用到前缀索引了。通常可以索引开始的几个字符，而不是全部值，以节约空间并得到好的性能。所谓的<strong>前缀索引就是使用索引的前面几个字母作为索引</strong>，但是要降低索引的重复率，索引我们还必须要判断前缀索引的重复率。</p><ul><li>先计算当前字符串字段的唯一性占比：<code>select 1.0*count(distinct name)/count(*) from test </code></li><li>在计算不同前缀的唯一性占比：<ul><li><code>select 1.0*count(distinct left(name,1))/count(*) from test</code> 取name字符串第一个作为前缀索引的占比</li><li><code>select 1.0*count(distinct left(name,2))/count(*) from test</code> 取name字符串前两个作为前缀索引的占比</li><li>…</li></ul></li><li>当<code>left(str, n)</code>的n不在显著增加时，此时可以选取n作为前缀索引的截取数</li><li>创建索引<code>alter table test add key(name(n));</code></li></ul><p><strong>[引自]：</strong></p><p>1.<a href="https://mp.weixin.qq.com/s?__biz=MzIxNzM0NjA1OQ==&mid=2247483878&idx=1&sn=cb23e89199530981136ab2a7c1b90d92&chksm=97fa7882a08df194efe0ce71d3b091bfdd6391573b48fdc21f179d1cb89c145c4b334d46a5d9&token=1235000206&lang=zh_CN#rd">再谈数据库索引</a></p><p>2.<a href="https://segmentfault.com/a/1190000041290817">MySQL聚簇索引和非聚簇索引的理解</a></p><p>3.<a href="https://www.jianshu.com/p/01313459b5a1">B+树作为Mysql索引结构的优点</a></p><p>4.<a href="https://zhuanlan.zhihu.com/p/121084592">Mysql性能优化：什么是索引下推？</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reflections使用总结</title>
    <link href="/2022/11/13/java/reflections%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/13/java/reflections%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h1><blockquote><p>背景：项目中有解析jar的业务场景，通过解析指定注解标注的class获取指定注解标注的方法</p></blockquote><h1 id="二、reflections能力概览"><a href="#二、reflections能力概览" class="headerlink" title="二、reflections能力概览"></a>二、reflections能力概览</h1><p>reflections的部分能力如下</p><ul><li>类处理<ul><li>获取jar包中的所有class对象</li><li>获取jar中指定注解的所有class对象</li><li>获取jar中指定类及其所有的子类的class对象</li><li>…</li></ul></li><li>方法处理<ul><li>获取jar包中所有的method对象</li><li>获取jar中被指定注解标记的method对象</li><li>获取jar中返回值为指定类的method对象</li><li>获取jar中入参为指定类的method对象</li><li>…</li></ul></li><li>字段处理<ul><li>获取jar中被指定注解标记的filed对象</li><li>…</li></ul></li><li>资源处理<ul><li>获取jar中resource中的properties文件</li><li>…</li></ul></li><li>工具类：<ul><li>过滤类中方法(类似stream流式写法)</li><li>…</li></ul></li><li>序列化为xml&#x2F;json</li><li>更多能力见官方文档：<a href="https://github.com/ronmamo/reflections">https://github.com/ronmamo/reflections</a></li></ul><h1 id="三、使用demo"><a href="#三、使用demo" class="headerlink" title="三、使用demo"></a>三、使用demo</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Set&lt;Class&lt;?&gt;&gt; queryClass(String jarPath, String url) <span class="hljs-keyword">throws</span> MalformedURLException &#123;<br>  <span class="hljs-comment">// 根据jarPath去构建classloader，此处是自定义classloader</span><br>        <span class="hljs-type">WarClassLoader</span> <span class="hljs-variable">warClassLoader</span> <span class="hljs-operator">=</span><br>                SwaggerGenerator.getWarClassLoader(jarPath, Thread.currentThread().getContextClassLoader());<br><br>  <span class="hljs-comment">// 构建configuration，设置classloader和要解析的url</span><br>        <span class="hljs-type">ConfigurationBuilder</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> ConfigurationBuilder.build();<br>        config.addClassLoader((URLClassLoader) warClassLoader.getParent());<br>        config.setScanners(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourcesScanner</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeAnnotationsScanner</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTypesScanner</span>());<br>        config.getUrls().clear();<br>        config.getUrls().add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(url)); <span class="hljs-comment">// 需要解析哪一个jar就传入对应的url地址</span><br><br>  <span class="hljs-comment">// 构建Reflection对象，获取符合指定注解的class</span><br>        <span class="hljs-type">Reflections</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Reflections</span>(config);<br>        Stream&lt;Class&lt;?&gt;&gt; apiStream = ref.getTypesAnnotatedWith(Api.class).stream();<br>        Stream&lt;Class&lt;?&gt;&gt; restStream = ref.getTypesAnnotatedWith(RestController.class).stream();<br>        Stream&lt;Class&lt;?&gt;&gt; apiAndDef = Stream.concat(apiStream, restStream);<br><br>        <span class="hljs-comment">// 反击class的set集合</span><br>        <span class="hljs-keyword">return</span> apiAndDef.collect(Collectors.toSet());<br>    &#125;<br></code></pre></td></tr></table></figure><ol><li>通过reflections.classes() 获取所有的class文件</li><li>reflections需要传入configuration才能进行初始化</li><li>configuration配置<ol><li>classloader：声明要扫描哪一个classloader下的class</li><li>scanner：声明需要扫描哪些内容：type和annotation的scanner</li><li>url：真实要扫描的jar执行流程</li></ol></li><li>初始化configuration并设置<ol><li>classloader：声明要扫描哪一个classloader下的class</li><li>scanner：声明需要扫描哪些内容：type和annotation的scanner</li><li>url：真实要扫描的jar</li></ol></li></ol><h1 id="四、主要流程源码分析"><a href="#四、主要流程源码分析" class="headerlink" title="四、主要流程源码分析"></a>四、主要流程源码分析</h1><ol><li><p>初始化, 调用 <code>new Reflections(config)</code>执行如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Reflections</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Configuration configuration)</span> &#123;<br>  <span class="hljs-comment">// 设置configuration</span><br>        <span class="hljs-built_in">this</span>.configuration = configuration;<br>  <span class="hljs-comment">// 设置存在class元信息的store对象，其内部维护 Map&lt;String, Multimap&lt;String, String&gt;&gt; storeMap</span><br>        store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Store</span>(configuration);<br><br>        <span class="hljs-keyword">if</span> (configuration.getScanners() != <span class="hljs-literal">null</span> &amp;&amp; !configuration.getScanners().isEmpty()) &#123;<br>            <span class="hljs-comment">//inject to scanners</span><br>            <span class="hljs-keyword">for</span> (Scanner scanner : configuration.getScanners()) &#123;<br>                scanner.setConfiguration(configuration);<br>                scanner.setStore(store.getOrCreate(scanner.getClass().getSimpleName()));<br>            &#125;<br><span class="hljs-comment">// 扫描configuration中持有的所有url</span><br>            scan();<br>        &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>扫描url, 调用<code>scan()</code>执行如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 一些代码...</span><br>  <br>  <span class="hljs-comment">// 遍历configuration中的所有url</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> URL url : configuration.getUrls()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 如果configuration配置了线程池，则把scan加入到线程池异步执行</span><br>                <span class="hljs-keyword">if</span> (executorService != <span class="hljs-literal">null</span>) &#123;<br>                    futures.add(executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                            <span class="hljs-keyword">if</span> (log != <span class="hljs-literal">null</span> &amp;&amp; log.isDebugEnabled()) log.debug(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().toString() + <span class="hljs-string">&quot;] scanning &quot;</span> + url);<br>                            scan(url);<br>                        &#125;<br>                    &#125;));<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    scan(url);<br>                &#125;<br>                scannedUrls++;<br>            &#125; <span class="hljs-keyword">catch</span> (ReflectionsException e) &#123;<br>                <span class="hljs-keyword">if</span> (log != <span class="hljs-literal">null</span> &amp;&amp; log.isWarnEnabled()) log.warn(<span class="hljs-string">&quot;could not create Vfs.Dir from url. ignoring the exception and continuing&quot;</span>, e);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 一些代码...</span><br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(URL url)</span> &#123;<br>      <span class="hljs-comment">// 通过迭代器遍历url中的所有符合要求的文件</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> Vfs.File file : Vfs.fromURL(url).getFiles()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> file.getRelativePath().replace(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;.&#x27;</span>);<br>            <span class="hljs-keyword">if</span> (configuration.getInputsFilter() == <span class="hljs-literal">null</span> || configuration.getInputsFilter().apply(input)) &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">classObject</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>              <span class="hljs-comment">// 遍历configuration中的声明的scanner实现类，扫描不同的内容并加入store</span><br>                <span class="hljs-keyword">for</span> (Scanner scanner : configuration.getScanners()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (scanner.acceptsInput(input)) &#123;<br>                            classObject = scanner.scan(file, classObject);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>存储, 根据传入的scanner的不同，执行不同的scan扫描逻辑，这里以<code>new TypeAnnotationsScanner()</code>为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scan</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object cls)</span> &#123;<br>  <span class="hljs-comment">// 获取class name</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> getMetadataAdapter().getClassName(cls);<br><br>        <span class="hljs-keyword">for</span> (String annotationType : (List&lt;String&gt;) getMetadataAdapter().getClassAnnotationNames(cls)) &#123;<br><br>            <span class="hljs-keyword">if</span> (acceptResult(annotationType) ||<br>                annotationType.equals(Inherited.class.getName())) &#123; <span class="hljs-comment">//as an exception, accept Inherited as well</span><br>                <span class="hljs-comment">// 以(注解，class name)为键值对，存入private Multimap&lt;String, String&gt; store;</span><br>                getStore().put(annotationType, className);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>获取class对象, 通过注解去store中获取类集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Set&lt;Class&lt;?&gt;&gt; getTypesAnnotatedWith(<span class="hljs-keyword">final</span> Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&gt; annotation, <span class="hljs-type">boolean</span> honorInherited) &#123;<br>  <span class="hljs-comment">// 直接去store中根据注解name去获取对应的class列表</span><br>        Iterable&lt;String&gt; annotated = store.get(index(TypeAnnotationsScanner.class), annotation.getName());<br>        Iterable&lt;String&gt; classes = getAllAnnotated(annotated, annotation.isAnnotationPresent(Inherited.class), honorInherited);<br>        <span class="hljs-keyword">return</span> Sets.newHashSet(concat(forNames(annotated, loaders()), forNames(classes, loaders())));<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>reflections需要传入configuration才能进行初始化</p></li><li><p>configuration配置</p><ol><li>classloader：声明要扫描哪一个classloader下的class</li><li>scanner：声明需要扫描哪些内容：type和annotation的scanner</li><li>url：真实要扫描的jar</li></ol></li><li><p>执行流程</p><ol><li><p>初始化configuration并设置</p></li><li><p>classloader：声明要扫描哪一个classloader下的class</p></li><li><p>scanner：声明需要扫描哪些内容：type和annotation的scanner</p></li><li><p>url：真实要扫描的jar</p></li><li><p>执行scan，扫描指定url</p></li><li><p>根据设置的scanner，把对应的信息存入store</p></li><li><p>根据key去store获取指定信息</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>搭建demo</title>
    <link href="/2022/05/18/%E9%9A%8F%E7%AC%94/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%90%AD%E5%BB%BAdemo/"/>
    <url>/2022/05/18/%E9%9A%8F%E7%AC%94/%E5%85%B6%E4%BB%96%E6%8A%80%E8%83%BD/%E6%90%AD%E5%BB%BAdemo/</url>
    
    <content type="html"><![CDATA[<ol><li>索引和数据，都是存放在磁盘。读取的时候，优先把索引加载到内存中的</li><li>引擎存放数据的方式是不一样的<ol><li>innodb，数据和索引放在同一个文件中</li><li>myisam，数据和索引是分开放在不同文件的</li></ol></li><li>mysql的数据存储格式是B+树，为什么<ol><li>目前的数据读取速度瓶颈就是IO</li><li>因此需要 1.减少IO数量，2.减少IO次数</li><li>可选方案：<ol><li>hash表，1.需要好的hash算法、2.存储内容无序，范围查找需要遍历</li><li>二叉树，BST，AVL树，黑红树。缺点是数据量大的时候，树会很高。树深了就会导致IO次数</li><li><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/%E4%B8%8D%E5%90%8C%E7%9A%84%E6%A0%91.png" alt="不同的树"></li><li>B树，磁盘中存放这索引和数据，数据占据了磁盘的大部分空间，假如一行数据1k，一个磁盘块就是16行，那么三层的B树就是16*16*16（每一个节点都有16个孩子）&#x3D;4096</li><li><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/B%E6%A0%91.png" alt="B树"></li><li>B+树，磁盘中只存放索引</li><li><img src="https://coder-xieshijie-img-1253784930.cos.ap-beijing.myqcloud.com/img/B%2B%E6%A0%91.png" alt="B+树"></li><li></li></ol></li></ol></li><li>操作系统<ol><li>局部性原理<ol><li>之前被访问的数据可能被再次访问</li><li>数据和程序都有聚集成群的倾向</li></ol></li><li>磁盘预读<ol><li>内存和磁盘交互存在最小的逻辑单位，页 (4K或者8K)</li><li>INNODB引擎进行数据加载的时候，读取是16K (4页或者2页)</li></ol></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他技能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>demo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
